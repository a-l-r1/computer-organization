## 技巧

### 慌了怎么办

1. Don't panic! 做出来是最重要的
2. 深呼吸，专心想实现和调试的事情，不要害怕干不出来
3. 看看哪里的逻辑出错了，**不要逃避！**
4. 用小数据、边界数据、特殊数据测试
5. 踏踏实实想逻辑、定义、算法，必要的时候自己再描述一遍 / 写一遍，不要根据原来做出来的

### 如何加新指令

1. 看好 RTL，把它转换成数据通路的连线
  * 注意流水线分级
  * 可能需要引入新的流水线寄存器
2. 如果有多对一的情况，就应该用 MUX
  * MUX 是原来的值，改控制信号
  * MUX 是新的值，改控制信号，**可能要改 MUX 的位宽和对应接线的位宽**
3. 改好控制信号
  * 对指令域进行识别
    * 尽量把新指令归约到原来的 `dptype` 上，**可以使用 `$0`，也可以利用其它特殊寄存器，毕竟控制模块里对读写寄存器的指定是 arbitrary 的**
  * 如果需要一个新的 `dptype`
    * 计算好控制信号
    * 计算好 Tuse 和 Tnew
    * 看好如何转发、是否需要改转发路径
  * 如果需要改转发路径
    * 确定转发的源和目的
    * **注意数据通路里的转发 MUX 和控制单元里的控制信号需要同时改**
    * **注意关于 `cp0.epc` 的转发**
  * 如果有新的跳转规则
    * 尽量改 `npc`，让 `npc` 基于比较结果判断
    * 如果引入了新的比较方式，就需要改 `cmp`，**注意有符号 / 无符号和运算溢出问题和改 `cmp` 的接口**，同时也要改数据通路和 `npc` 的接口
    * 如果要跟立即数比较，**先看一下立即数的扩展模式**，能用 `npc` 解决的尽量用 `npc` 解决，p5 以后有时不用改 `cmp`
    * 如果根据一个寄存器跳转，那么按照引入了新的比较方式处理，改 `cmp` 的比较方式
    * 如果跳转时涉及 `retaddr`，那么有时可以按照 `JUMP_[IR]` 处理
    * 如果跳转时涉及 `cp0.epc`，那么可能可以归约到 `JUMP_C0` 处理，**如果不能，注意转发**
  * 如果有新的立即数扩展方式
    * 如果还是 `im.result[15:0]` 改 `ext`，**注意有符号 / 无符号的区别**
    * 如果是 `im.result` 的其它部分，记得加 MUX 信号来源，**注意位宽和有符号 / 无符号的区别**
  * 如果有新的寄存器号表示方法
    * 加 MUX 信号来源，**记得改位宽**，控制信号用 sane defaults
    * 可以根据指令类型特判
  * 如果 `alu` 有新的运算
    * **抓好定义**，例如补码的相反数，最小的负数没有相反数
    * **注意地址计算是无符号计算、指令给定了是不是有符号运算要注意**
    * 如果是两个输入的运算，直接写新运算
    * 如果是三个输入的运算，看看能不能省下一个运算源，**有的时候要改控制的输入**，比如条件传送指令需要根据第二个寄存器的值判断 `rf.we`
      * 如果新值能够比较快地出来，**注意改转发路径，但是为了正确定不改也可以**，比如条件传送指令
    * 如果是输入带附加参数的运算，可以开一个 `alu` 端口，然后在控制器上接过去，也可以通过正常数据通路传过去（不推荐），比如移位运算可以直接在控制器和 `alu` 上开端口
      * 注意一般都有 Python，**可以自动代码生成**
  * 如果 `md` 有新的运算
    * **抓好定义**，比如补码的乘除法运算
    * **注意有 / 无符号计算**
    * **注意掌握好 `md` 的内部状态机，`md` 利用了时钟的下降沿**
    * **如果需要检测特殊情况，最好在收到数据后马上检测**，比如检测除法是否除 0
      * **这时错误号可能也要马上更新**
    * **注意暂停机制，现在是把跟 `md` 相关的指令串行化，但是可能有更复杂的暂停控制**
    * 注意 `md` 存的数据恢复到以前时使用的机制
      * **有时可能数据寄存器不改也要保存，为了应对计算过程中可能出现的异常**
  * 如果有新的 `dm` 存取方式
    * 如果是特殊的读写范围，那么因为是单周期，可以在 `dm` 上开端口 `mode`，让控制单元控制 `mode`，注意 sane defaults 和**小端序**
    * 如果是同时读写，那么也可以用上面的方法，注意 `dm` 的读写地址端口是分开的，注意开 MUX 的端口和 sane defaults
    * 如果是根据其它来源读写，注意开 MUX 的端口和 sane defaults
      * **注意这样的话转发多了一个新的消费者**
    * 注意在 `ac` 里允许这种方式，**并针对 4 种出错情况做进一步的适配**
  * 如果有新的设备
    * 注意把设备的基地址抽象出来
    * 注意在无效地址和无效写入模式的时候忽略操作，因为**`ac` 会检测出来并报告**
    * 注意在 `ac` 里允许新设备的范围，**并针对 4 种出错情况做进一步的适配，尤其要是配好权限**
    * 注意设备的时序，**尤其是状态机的时序，必要的时候可以先画出状态转移图**
    * 如果设备能产生 IRQ，**注意把设备的 IRQ 接线给 `bridge` 接上**
  * 如果有新的 `cp0` 异常
    * **注意按照异常的具体情况做进一步适配，有时不是单纯地按照级判断**
    * 注意加上新的异常的定义
    * **如果要扩展新的 `cp0` 寄存器，看情况改 `MARS\_COMPAT` 模式里的寄存器值，有的时候其实也不能改**
    * **注意新的 `cp0` 寄存器更新的优先级顺序，一般是异常 > 写入 > 正常更新，但是注意 `hwirq` 这样的寄存器更新逻辑就不一样**
    * **如果有新的 `cp0` 寄存器要读或者用到了 `cp0.epc`，注意双重转发和 `JUMP\_C0` 类指令的 D 级插入气泡效果**
  * 如果有新的 `rf` 的值
    * 注意要接线接过来，然后加 MUX
      * **注意补上每级的 `pff` 和对应的 `wire`，一定要声明，否则默认是 1 位的**
    * 如果是返回地址，**最好是先接当前 PC，然后无符号数 +8**
      * **一般这种指令可以归约到 `JUMP_[IR]` 里**
    * 注意 `rf` 的值是否写入可以跟 `rf.we` 配合，**也可以妙用写入 `$0`**
    * **注意 `rf` 的值是否写入一般跟 `cp0.have2handle` 无关**

### 如何有效调试

1. 定位出错指令
  * 平时可以用 `diff`
  * 在考场上主要靠看数据和猜
    * 看数据大法
      * 前面一堆 0 位或者 1 位出错的，一般是移位指令
      * 前面数据乱了的，一般是乘除法指令
      * 数据差 1 的，一般是条件设置指令
      * 数据有些位有差别的，可能是读写 `cp0` 的指令
    * 瞎猜大法
      * 最近加了什么指令
      * 哪条指令原理不确定
      * 哪条指令是说了的重点
      * 哪条指令比较复杂，不好实现
      * 课下测试一直没过哪条指令
    * 看 PC 大法
      * 看是 `.text` 还是 ISR
    * 实在不行就把感觉错了的指令都检查一遍
2. 分析每级的行为
  * 先把 RTL 在心里分解成每级
  * 然后比较出错指令或者觉得出错指令的差异
  * 然后看转发和暂停是不是写对了
    * 首先检查**每级得出的寄存器结果、Tuse 和 Tnew**
    * 然后检查控制器的转发是否写对
      * **注意双重转发**
    * 然后检查数据通路的转发是否正确反映了逻辑
    * 最后检查一下转发相关的接线
  * 然后检查每级的行为
    * 先检查控制信号对不对，**尤其是新加的控制信号和它们对应的 defaults**
      * 如果上面检查了的话，转发和暂停检查一下 defaults
    * `npc` 看与 `cmp` 的配合和 `npc` 模式本身的实现，注意**大小比较、有无符号数和指令取立即数的扩展**
    * `rf` 看取寄存器号对不对，不要乱改改折了，**注意 MUX、数据位宽、有无符号数和扩展模式**
      * **检查一下对应的控制信号**
    * `ext` 看扩展模式对不对，**注意扩展的是哪些位和扩展模式**
    * `alu` 看实现的运算对不对，**要踏实地看定义以及和 `rf` 的配合，不要读哪个寄存器都读错了**
      * **如果有第三个参数，检查一下关于第三个参数的逻辑**
    * `md` 看实现的运算和错误检查机制、复位机制对不对，**要踏实地看定义以及内部寄存器的值，注意好时钟周期**
      * 注意 `md` 的内部状态机和错误检测机制
    * `dm` 看实现的读写模式和读写地址对不对，**注意端序和读写地址的对应 MUX，和它们与控制信号的对应关系**
      * 注意可能读写地址要分开转发，**这里的接线需要仔细看然后调一下**
    * `bridge` 看实现的设备的基址和 `hwirq` 的接线对不对，**注意地址不能有重叠的情况，题目不会给地址重叠的情况，因为这样不合理**
      * 注意还有 `hwirq` 到 `cp0` 的接线
    * `ac` 看 4 种情况是不是更新到了能够反映现在设备拓扑的情况，**尤其是设备的 MMIO 地址及其访问权限**
      * 注意 4 种情况一定要全面，可以重叠
    * `cp0` 看 `have2handle` 能不能正确复位流水线、加上钩子，以及新的异常号能不能被识别
      * **注意来了异常会被识别，但是没有异常 `cp0` 应该更新 `hwirq` 等寄存器，下一个时钟周期发中断信号**
      * 注意 `cp0` 没有异常的时候不能乱发 `have2handle`
    * 新加入的设备看实现的设备状态机，还有设备写入值的逻辑
      * **注意写入值如果有错误就忽略，让 `ac` 来检测**
    * `rf` 还要看实现的钩子对不对，**尤其是根据寄存器值判断的那部分，因为需要控制器配合**
      * **注意要先实现钩子再转发**
3. 分析指令之间的关系
  * 跟上一条指令之间的关系
  * 如果是跳转指令，跟以前指令和对应寄存器的关系
  * 如果是 L/S 指令，跟内存的关系
  * 如果是乘除法指令，跟乘除法器及其串行化的关系
  * 如果是 ISR 指令，跟受害指令、受害指令的状态、`cp0` 的状态都有关系
  * CPU 的初始状态

### 如何改数据通路

1. 分析为什么要改数据通路
  * 改数据通路代价比较大
    * 加入流水线后更是如此，**转发、暂停、流水线寄存器都要重新 evaluate 一遍**
    * 加入异常机制以后更是如此，**出异常、来了异常以后的 hook 机制也都要重新 evaluate 一遍**
  * 必须安装新部件吗？
    * 可能有的部件可以通过 hook 来解决
    * 有的部件可以通过改部件本身的方式来解决
    * 可能可以重新把指令的 RTL fit 到现有的数据通路里
    * 可能可以直接 hook 控制机制
    * 如果要求加新部件，那必须加，没有办法
  * 新部件部署在哪一级？
    * **直接决定转发、暂停和流水线寄存器的 evaluation**
    * **也决定出异常和来了异常以后的 hook 机制的 evaluation**
    * 对类比同级的 MUX 和部件有帮助
    * 对分清这个部件的功能有描述
  * 改了新部件，如何既服务好新指令，又能与原来的指令兼容？
    * sane defaults
    * 弄好回退机制
    * 原来的指令可能需要在控制层面避开新部件带来的影响，不过这一点一般不大可能
    * 对 `md` 这种自带状态机的部件，弄好状态机
2. 分析怎么改数据通路
  * 如果没安装新部件
    * 如果在 `npc` 这里加上 hook 机制，记得跟 `cmp` 和控制配合好，**扩展指令的立即数时，源、目的和扩展哪个部分一定要注意**
    * 如果在控制加上 hook 机制，**要注意 sane defaults 和 hook 机制能不能方便之后修改代码**
    * 如果在 `alu / ext / md / dm` 加了新功能，**注意实现是否正确，要紧扣定义**
    * 可能需要在 `cp0` 处加上新的异常代码 / 寄存器，而且要识别异常，**注意保持 `cp0` 原来正常的机制**
  * 如果安装了新部件
    * 重构一遍新指令的数据通路，**注意 sane defaults**
    * **evaluate 一遍转发、暂停和流水线寄存器，并且仔细地改转发和暂停规则**
      * **看一下有没有多重转发，有的话可以暂停也可以多重转发，不过一般这不大可能**
    * **evaluate 一遍出异常和来了异常以后的 hook 机制**
      * **尤其是产生的异常和来了异常以后的 hook 机制，这跟时序和状态机都有关系**
      * **保证 `cp0` 原来正常的机制**
    * 分析一下新部件的功能
    * **看一下数据通路的更改，注意跟流水线寄存器之间的微妙的关系**
    * 如果比较有空，可以稍微测试一下

### 如何比较方便地改设计

1. 可以在加 hook 机制的时候认为这是必须的
2. 可以在扩展时认为这样可以简化数据通路
3. 可以在部署部件时部署到比较方便实现的级
4. 可以在实现内部流水线时认为这样方便调试
5. 可以在暂停时认为这样可以简化设计

