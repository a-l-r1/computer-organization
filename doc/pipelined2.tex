\PassOptionsToPackage{unicode=true}{hyperref} % options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
%

\documentclass[12pt,AutoFakeBold,AutoFakeSlant]{article}
% 12pt == 小四

\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{unicode-math}

% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available

\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}

\usepackage{hyperref}
\hypersetup{
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls

\usepackage{longtable,booktabs}

% Fix footnotes in tables (requires footnote package)
\IfFileExists{footnote.sty}{\usepackage{footnote}\makesavenoteenv{longtable}}{}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}

\usepackage{fontspec}
\usepackage{ctex}

\usepackage{indentfirst}
\usepackage{fullpage}

\setmainfont{Times New Roman}
\setmonofont{Courier New}
\setCJKmainfont{SimSun}
\setCJKmonofont{SimSun}

\usepackage{listings}
\lstset{basicstyle=\ttfamily,breaklines=true}

\usepackage[table,svgnames]{xcolor}
\usepackage{cellspace}
\usepackage{etoolbox}
\definecolor{headercolor}{RGB}{198,217,241} % #c6d9f1

\linespread{1.5} % https://tex.stackexchange.com/questions/30073/why-is-the-linespread-factor-as-it-is
\usepackage[tmargin=1in,bmargin=1in,lmargin=1.25in,rmargin=1.25in]{geometry} % word-like, see https://tex.stackexchange.com/questions/35892/latex-optimal-settings-for-ms-word-like-document
\setlength{\arrayrulewidth}{0.5pt}

\AtBeginEnvironment{longtable}{\rowcolors{0}{\ifnumless{\rownum}{3}{white}{headercolor}}{}}
\AtBeginEnvironment{longtable}{\zihao{5}}

\usepackage{nameref}
\makeatletter
\newcommand*{\currentname}{\@currentlabelname}
\makeatother
\newcounter{tablecaption}
\AtBeginEnvironment{longtable}{\stepcounter{tablecaption}\flushright{{\setlength\parskip{0pt}\heiti{表 \arabic{tablecaption} \currentname{}}}}\vspace*{-7pt}} % NOTE: hack since \caption in longtable breaks the current way of setting colors for table header

\newcommand{\headingcellfirst}[1]{\multicolumn{1}{|c|}{\heiti{#1}}} % NOTE: \DeclareRobustCommand has issues
\newcommand{\headingcellmiddle}[1]{\multicolumn{1}{c|}{\heiti{#1}}}
\newcommand{\headingcelllast}[1]{\multicolumn{1}{c|}{\heiti{#1}}}

\usepackage{makecell}
\usepackage{multirow}

\usepackage{mips}

\begin{document}

{
\setlength{\parskip}{\baselineskip}%

\begin{center}
\zihao{3}
\heiti{计算机组成原理实验报告}
\end{center}
}

\tableofcontents
\newpage

\hypertarget{npc}{%
\section{NPC}\label{npc}}

\hypertarget{ux539fux7406}{%
\subsection{原理}\label{ux539fux7406}}

NPC 是下个 PC 值的意思。它能做到根据当前的 PC 值，计算出下一个 32 位的
PC 值。

一般来说，PC 值的转换是顺序转换。但是，NPC
必须要听控制模块的指令，做到在某些条件下进行符号转换。

\hypertarget{ux63a5ux53e3ux5b9aux4e49}{%
\subsection{接口定义}\label{ux63a5ux53e3ux5b9aux4e49}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{curr\_pc} & 输入 & 32 & 当前 PC\tabularnewline\hline
\texttt{jump\_mode} & 输入 & 4 & 是否可以跳转\tabularnewline\hline
\texttt{cmp\_result} & 输入 & 2 & \texttt{cmp} 的比较结果\tabularnewline\hline
\texttt{cmp\_sig\_result} & 输入 & 2 & \texttt{cmp}
的有符号比较结果\tabularnewline\hline
\texttt{num} & 输入 & 16 & 输入的立即数\tabularnewline\hline
\texttt{jnum} & 输入 & 26 & 输入的 J 型指令的立即数\tabularnewline\hline
\texttt{reg\_} & 输入 & 32 & 输入的寄存器值\tabularnewline\hline
\texttt{next\_pc} & 输出 & 32 & 下一个 PC\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49}}

用把宏定义成宏的方法，定义表中值为宏的宏。把一个宏定义成另一个宏，那该宏的意义与定义它的宏一样，表中省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{jump\_mode} & \texttt{NPC\_JUMP\_DISABLED} & 4'b0000 &
不要跳转\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_JUMP\_WHEN\_EQUAL} & 4'b0001 &
当输入的比较结果相等时跳转\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_JUMP\_WHEN\_NOT\_EQUAL} & 4'b0010 &
当输入的比较结果不等时跳转\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_REG} & 4'b1111 &
按照寄存器内地址跳转\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_J} & 4'b1110 & 按照 J
型指令的立即数跳转\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_LARGER} & 4'b0011 &
\makecell{当输入的比较结果为\\大于时跳转}\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_SMALLER} & 4'b0100 &
\makecell{当输入的比较结果为\\小于时跳转}\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_LARGER\_OR\_EQUAL} & 4'b0101 &
\makecell{当输入的比较结果为大于\\或等于时跳转}\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_SMALLER\_OR\_EQUAL} & 4'b0110 &
\makecell{当输入的比较结果为小于\\或等于时跳转}\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_SIG\_LARGER} & 4'b0111 &
\makecell{当输入的有符号比较结果\\为大于时跳转}\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_SIG\_SMALLER} & 4'b1000 &
\makecell{当输入的有符号比较结果\\为小于时跳转}\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_SIG\_LARGER\_OR\_EQUAL} & 4'b1001 &
\makecell{当输入的有符号比较结果\\为大于或等于时跳转}\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_SIG\_SMALLER\_OR\_EQUAL} & 4'b1010 &
\makecell{当输入的有符号比较结果为\\小于或等于时跳转}\tabularnewline\hline

\end{longtable}

\texttt{comp\_result} 的相应数值代表的意义，与相应的宏有关，这些宏在
\texttt{alu.h} 中。

\hypertarget{ux529fux80fd}{%
\subsection{功能}\label{ux529fux80fd}}

令跳转基准地址 \texttt{base\ =\ \$unsigned(curr\_pc)}。

若 \texttt{jump\_mode\ ==\ NPC\_JUMP\_DISABLE}，则令
\texttt{next\_pc\ =\ \$unsigned(base)\ +\ \$unsigned(4)}。

若 \texttt{jump\_mode\ ==\ NPC\_JUMP\_WHEN\_EQUAL}，则
\texttt{alu\_comp\_result\ ==\ ALU\_EQUAL} 时，首先把 \texttt{num}
扩展成 32 位有符号立即数，扩展方式是首先把 \texttt{num} 后面加上
\texttt{2\textquotesingle{}b0}，然后把这 18 位二进制数扩展成 32
位有符号二进制数。然后令
\texttt{next\_pc\ =\ \$signed(base)\ +\ \$signed(num)}。否则做跟
\texttt{jump\_mode\ ==\ NPC\_JUMP\_DISABLE} 时相同的步骤。

若 \texttt{jump\_mode} 对应的意义有其它的比较类型，则 \texttt{cmp\_result}
或 \texttt{cmp\_sig\_result}
满足相应条件时，做跟上面相同的步骤。否则做跟
\texttt{jump\_mode\ ==\\\ NPC\_JUMP\_DISABLE} 时相同的步骤。

若 \texttt{jump\_mode\ ==\ NPC\_REG}，则令 \texttt{next\_pc\ =\ reg\_}。

若 \texttt{jump\_mode\ ==\ NPC\_J}，则令
\texttt{next\_pc\ =\ \{base{[}31:28{]},\ jnum,\ 2\textquotesingle{}b0\}}。

若 \texttt{jump\_mode} 为其它值，则做跟
\texttt{jump\_mode\ ==\ NPC\_JUMP\_DISABLE} 时相同的步骤。

\hypertarget{ux6ce8ux610fux4e8bux9879}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  NPC 是在内部进行符号扩展，不用 ext。
\item
  \texttt{reg\_} 是为了避免和 \texttt{reg} 冲突。
\item
  \texttt{base} 抽象出来是为了方便调试和维护，它是跟 MIPS
  指令集手册相符的。
\end{enumerate}

\hypertarget{pc}{%
\section{PC}\label{pc}}

\hypertarget{ux539fux7406-1}{%
\subsection{原理}\label{ux539fux7406-1}}

PC
是程序计数器的意思，负责对当前的指令进行计数。它是标记程序执行到哪里的一种方法，同时输出的信息也被送入指令内存
IM，用来取指。

PC 只负责表示程序执行到哪里，而 PC 的更新由 NPC
模块负责。这样可以做到更简便地处理跳转指令、也对流水线 CPU
插入气泡有帮助。

\hypertarget{ux7aefux53e3ux5b9aux4e49}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & 输入 & 1 & 时钟信号\tabularnewline\hline
\texttt{rst} & 输入 & 1 & 同步复位信号\tabularnewline\hline
\texttt{next\_pc} & 输入 & 32 & NPC 计算得来的下一个 PC
地址\tabularnewline\hline
\texttt{enable} & 输入 & 1 & PC 使能\tabularnewline\hline
\texttt{curr\_pc} & 输出 & 32 & PC 地址\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-1}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-1}}

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{enable} & \texttt{PC\_ENABLED} & 1'b1 & PC 使能\tabularnewline\hline
\texttt{enable} & \texttt{PC\_DISABLED} & 1'b0 & PC
非使能\tabularnewline\hline
\texttt{curr\_pc} & \texttt{PC\_START\_ADDRESS} & 32'h00003000 & PC
的起始地址\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-1}{%
\subsection{功能}\label{ux529fux80fd-1}}

该部件是时序部件。

有一个 32 位的寄存器保存当前 PC 的值，初值为
\texttt{PC\_START\_ADDRESS}。

在每个时钟上升沿，首先处理同步复位。然后，若 \texttt{enable\ ==\ PC\_ENABLED}，则把 PC
部件中保存的当前 PC 的值更新成 \texttt{next\_pc} 的值。否则，保存的当前
PC 的值不变。

无论什么时候，输出端口 \texttt{curr\_pc} 的值都是 PC 部件中保存的当前 PC
的值。

\hypertarget{ux6ce8ux610fux4e8bux9879-1}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-1}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  PC 和 IM 的起始地址是分开定义的，改的时候要注意。
\end{enumerate}

\hypertarget{ux7a0bux5e8fux5b58ux50a8ux5668}{%
\section{程序存储器}\label{ux7a0bux5e8fux5b58ux50a8ux5668}}

\hypertarget{ux539fux7406-2}{%
\subsection{原理}\label{ux539fux7406-2}}

程序存储器是存储程序指令的地方。为了加载程序指令，它可以通过系统任务读取编译后的指令内容。

为了简便，程序存储器由许多寄存器实现。

\hypertarget{ux7aefux53e3ux5b9aux4e49-1}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-1}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{addr} & 输入 & \texttt{IM\_ADDR\_WIDTH} & 读地址\tabularnewline\hline
\texttt{enable} & 输入 & 1 & 使能信号\tabularnewline\hline
\texttt{result} & 输出 & 32 & 读到的结果\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-2}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-2}}

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{enable} & \texttt{IM\_ENABLE} & \texttt{1\textquotesingle{}b1} &
IM 使能\tabularnewline\hline
\texttt{enable} & \texttt{IM\_DISABLE} & \texttt{1\textquotesingle{}b0}
& IM 非使能\tabularnewline\hline
\texttt{addr} & \texttt{IM\_ADDR\_WIDTH} & 14 & \texttt{addr}
的位宽\tabularnewline\hline
\texttt{addr} & \texttt{IM\_START\_ADDRESS} & 32'h00003000 & IM
对外表现的起始地址\tabularnewline\hline
指令存储器 & \texttt{IM\_SIZE} & 4096 & 能存储指令的个数\tabularnewline\hline
指令存储器 & \texttt{IM\_CODE\_FILENAME} & \texttt{"code/code.hex"} &
要加载的机器码\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-2}{%
\subsection{功能}\label{ux529fux80fd-2}}

有 \texttt{IM\_SIZE} 个 32
位存储器，代表其中存储的指令。它们初值应该使用加载文件的系统任务加载。加载文件名由
\texttt{IM\_CODE\_FILENAME} 指定。

若 \texttt{addr} 作为无符号数小于 \texttt{IM\_START\_ADDRESS}，则也返回
\texttt{32\textquotesingle{}b0}。否则，\texttt{result} 为
\texttt{addr\ -\ IM\_START\_ADDRESS} 这个地址再取
\texttt{{[}IM\_ADDR\_WIDTH\ -\ 1:2{]}}
对应的指令（从存储器中取得，是两个无符号数相减）。若相减后的结果超出了已经加载的指令所占的地址空间，则
\texttt{result} 为 \texttt{32\textquotesingle{}b0}。

\hypertarget{ux6ce8ux610fux4e8bux9879-2}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-2}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{IM\_ADDR\_WIDTH} 和 \texttt{IM\_SIZE}
  需要一块改，因为它们的大小有关系
\item
  有 offset 了，注意跟 offset 相减是无符号数相减
\item
  offset 主要是为了和 MARS 兼容
\end{enumerate}

\hypertarget{ux5bc4ux5b58ux5668ux5806}{%
\section{寄存器堆}\label{ux5bc4ux5b58ux5668ux5806}}

\hypertarget{ux539fux7406-3}{%
\subsection{原理}\label{ux539fux7406-3}}

寄存器堆保存着 32 位 32 个通用寄存器，负责存储 CPU
立刻想要的数据，它是存储器层次结构中的最高一级，负责暂存数据。第 0
号寄存器 \texttt{\$0} 的值永远是
\texttt{32\textquotesingle{}b0}，写入不会改变它的值。

由于 MIPS
体系结构中的指令最多读两个寄存器，写一个寄存器，所以寄存器输入两个要读的地址，输出两个要读的数据；输入一个要写的地址和一个要写的数据；同时还有写使能端口。

寄存器的使用没有规定，这一般是软件关心的问题。

\hypertarget{ux7aefux53e3ux5b9aux4e49-2}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-2}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & 输入 & 1 & 时钟信号\tabularnewline\hline
\texttt{rst} & 输入 & 1 & 同步复位信号\tabularnewline\hline
\texttt{curr\_pc} & 输入 & 32 & 当前 PC 的值\tabularnewline\hline
\texttt{read\_addr1} & 输入 & 5 & 第一个读地址\tabularnewline\hline
\texttt{read\_addr2} & 输入 & 5 & 第二个读地址\tabularnewline\hline
\texttt{write\_addr} & 输入 & 5 & 写地址\tabularnewline\hline
\texttt{write\_data} & 输入 & 32 & 要写入的数据\tabularnewline\hline
\texttt{write\_enable} & 输入 & 1 & 写使能\tabularnewline\hline
\texttt{read\_result1} & 输出 & 32 &
第一个读地址读出的数据\tabularnewline\hline
\texttt{read\_result2} & 输出 & 32 &
第二个读地址读出的数据\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-3}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-3}}

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{.*\_addr.*} & \texttt{RF\_ADDR\_ZERO} & 5'b0 &
零寄存器的地址\tabularnewline\hline
\texttt{.*\_addr.*} & \texttt{RF\_ZERO} & \texttt{RF\_ADDR\_ZERO}
&\tabularnewline\hline
\texttt{write\_enable} & \texttt{RF\_WRITE\_ENABLED} & 1'b1 &
寄存器堆使能\tabularnewline\hline
\texttt{write\_enable} & \texttt{RF\_WRITE\_ENABLE} &
\texttt{RF\_WRITE\_ENABLED} &\tabularnewline\hline
\texttt{write\_enable} & \texttt{RF\_WRITE\_DISABLED} & 1'b0 &
寄存器堆非使能\tabularnewline\hline
\texttt{write\_enable} & \texttt{RF\_WRITE\_DISABLE} &
\texttt{RF\_WRITE\_DISABLED} &\tabularnewline\hline
输出 & \texttt{RF\_OUTPUT\_FORMAT} &
\texttt{"\%d@\%h: *\%h <= \%h"} &
输出模板\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-3}{%
\subsection{功能}\label{ux529fux80fd-3}}

该部件为时序部件。

有 31 个 32 位寄存器，代表
\texttt{\$1}\textasciitilde{}\texttt{\$31}，它们初值都为
\texttt{32\textquotesingle{}b0}。\texttt{\$0} 实际上不需要寄存器。

在每个时钟上升沿，首先处理同步复位。若 \texttt{write\_enable\ ==\\\ RF\_WRITE\_ENABLED} 且
\texttt{write\_addr\ !=\ RF\_ADDR\_ZERO}，则说明可以执行写操作，且写到的寄存器是可以保存数值的寄存器。此时把
\texttt{write\_addr} 指代的寄存器的值更新为
\texttt{write\_data}。更新时，以模版中的格式打印出数据变化，第一个参数是当前的模拟时钟的时间，第二个参数是当前
PC 的值，第三个参数是寄存器号，第四个参数是更新后的值。

无论什么时候，若 \texttt{read\_addr1\ !=\ RF\_ADDR\_ZERO}，则把
\texttt{read\_addr1} 指代的寄存器的值输出到 \texttt{read\_result1}
中，否则把 \texttt{32\textquotesingle{}b0} 输出到 \texttt{read\_result1}
中。对 \texttt{read\_addr2} 和 \texttt{read\_result2} 的相应操作相同。

\hypertarget{ux6ce8ux610fux4e8bux9879-3}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-3}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  暂时还没有内部转发。
\item
  寄存器可以定义为 \texttt{reg\ {[}31:1{]}\ registers\ {[}31:0{]}}，把
  \texttt{\$0} 空出来。
\end{enumerate}

\hypertarget{ux6bd4ux8f83ux6a21ux5757}{%
\section{比较模块}\label{ux6bd4ux8f83ux6a21ux5757}}

\hypertarget{ux539fux7406-4}{%
\subsection{原理}\label{ux539fux7406-4}}

比较模块通过比较两个寄存器的数据，实现分支指令和条件传送指令的提前跳转，提高跳转的效率。

\hypertarget{ux63a5ux53e3ux5b9aux4e49-1}{%
\subsection{接口定义}\label{ux63a5ux53e3ux5b9aux4e49-1}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{reg1} & 输入 & 32 & 第一个寄存器的输入\tabularnewline\hline
\texttt{reg2} & 输入 & 32 & 第二个寄存器的输入\tabularnewline\hline
\texttt{cmp} & 输出 & 2 & 无符号比较结果输出\tabularnewline\hline
\texttt{sig\_cmp} & 输出 & 2 & 有符号比较结果输出\tabularnewline\hline
\texttt{reg2\_sig\_cmp} & 输出 & 2 & \texttt{reg2} 与 0
的有符号比较结果输出\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-4}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-4}}

把 \texttt{CMP\_LARGER,\ CMP\_SMALLER,\ CMP\_EQUAL} 分别定义成
\texttt{ALU\_LARGER,\ ALU\_SMALLER,\ ALU\_EQUAL}。

\hypertarget{ux529fux80fd-4}{%
\subsection{功能}\label{ux529fux80fd-4}}

在 \texttt{comp,\ sig\_comp,\ reg2comp}
三个输出端口分别输出第一个寄存器与第二个寄存器作为无符号数的比较结果、它们作为有符号数的比较结果和第二个寄存器与
0 作为有符号数的比较结果。

\hypertarget{ux6269ux5c55ux5668}{%
\section{扩展器}\label{ux6269ux5c55ux5668}}

\hypertarget{ux529fux80fd-5}{%
\subsection{功能}\label{ux529fux80fd-5}}

扩展器是专门执行扩展整数功能的运算。它能做到小于 32 位的整数向 32
位整数的转换，其中有符号转换，也有无符号转换。

转换器的模式由宏定义的方式指定，有符号扩展，也有无符号扩展，也有其它模式。由于没有明显的层次和类别关系，采用顺序编号和按常见顺序编号的方法。

\hypertarget{ux63a5ux53e3ux5b9aux4e49-2}{%
\subsection{接口定义}\label{ux63a5ux53e3ux5b9aux4e49-2}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{num} & 输入 & 16 & 输入的数字\tabularnewline\hline
\texttt{mode} & 输入 & 3 & 模式\tabularnewline\hline
\texttt{result} & 输出 & 32 & 扩展的结果\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-5}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-5}}

用把宏定义成宏的方法，定义表中值为宏的宏。把一个宏定义成另一个宏，那该宏的意义与定义它的宏一样，表中省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{mode} & \texttt{EXT\_MODE\_SIGNED} & 3'b000 &
符号扩展\tabularnewline\hline
\texttt{mode} & \texttt{EXT\_MODE\_UNSIGNED} & 3'b001 &
无符号扩展\tabularnewline\hline
\texttt{mode} & \texttt{EXT\_MODE\_PAD} & 3'b010 & \makecell{把输入的 16 位填充到输出结果的高 16 位，\\输出结果低 16 位置零的扩展}\tabularnewline\hline
\texttt{mode} & \texttt{EXT\_MODE\_ONE} & 3'b011 & 在数字前面填充二进制
1 的扩展\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-6}{%
\subsection{功能}\label{ux529fux80fd-6}}

若 \texttt{mode}
的值为合法操作（即上面``宏定义''一节中列出的操作），按照 \texttt{mode}
中给出的操作计算出结果，并把结果放入 \texttt{result} 中。

若 \texttt{mode} 的值为非法操作，就令
\texttt{result\ =\ 32\textquotesingle{}b0}。

\hypertarget{alu}{%
\section{ALU}\label{alu}}

\hypertarget{ux539fux7406-5}{%
\subsection{原理}\label{ux539fux7406-5}}

ALU 是运算控制单元的意思，负责两个 32
位整数的运算。它可以负责各种运算，包括数学运算和逻辑运算。易知它是纯组合逻辑。

由于定义运算的时候需要给运算编码，所以表示运算就有点类似于 C 语言中的
\texttt{enum}。因此，需要对各种运算进行宏定义，以保证系统的可维护性。宏定义也可以把定义的数据空间分隔开，以及对运算按照逻辑进行排序，从而得到对端口运算编码的更好理解。

\hypertarget{ux7aefux53e3ux5b9aux4e49-3}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-3}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{num1} & 输入 & 32 & 第一个操作数\tabularnewline\hline
\texttt{num2} & 输入 & 32 & 第二个操作数\tabularnewline\hline
\texttt{shamt} & 输入 & 5 & 移位运算的移位位数\tabularnewline\hline
\texttt{op} & 输入 & 5 & 操作符\tabularnewline\hline
\texttt{result} & 输出 & 32 & 结果\tabularnewline\hline
\texttt{cmp\_result} & 输出 & 2 & 作为无符号数的比较结果\tabularnewline\hline
\texttt{sig\_cmp\_result} & 输出 & 2 &
作为有符号数的比较结果\tabularnewline\hline
\texttt{overflow} & 输出 & 1 & 计算过程中是否发生溢出\tabularnewline\hline
\texttt{op\_invalid} & 输出 & 1 & 操作符是否无效\tabularnewline\hline

\end{longtable}

由于在硬件层级对数的加减都是无符号数加减法，所以这里的溢出，是指操作过程中出现了做无符号数加减法时结果超出无符号数范围的现象。

\hypertarget{ux5b8fux5b9aux4e49-6}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-6}}

采用操作符最高两位区分类别的方法定义宏。用把宏定义成宏的方法，定义表中值为宏的宏。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{op} & \texttt{ALU\_ADD} & 5'b00000 & 加法运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_UNSIGNED\_ADD} & \texttt{ALU\_ADD} &
同上\tabularnewline\hline
\texttt{op} & \texttt{ALU\_SUB} & 5'b00001 & 减法运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_UNSIGNED\_SUB} & \texttt{ALU\_SUB} &
同上\tabularnewline\hline
\texttt{op} & \texttt{ALU\_AND} & 5'b10000 & 按位与运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_BITWISE\_AND} & \texttt{ALU\_AND} &
同上\tabularnewline\hline
\texttt{op} & \texttt{ALU\_OR} & 5'b10001 & 按位或运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_BITWISE\_OR} & \texttt{ALU\_OR} &
同上\tabularnewline\hline
\texttt{op} & \texttt{ALU\_NOT} & 5'b10010 & 按位非运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_BITWISE\_NOT} & \texttt{ALU\_NOT} &
同上\tabularnewline\hline
\texttt{op} & \texttt{ALU\_XOR} & 5'b10011 & 按位异或运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_MOVZ} & 5b'00010 &
数据转移运算\textsuperscript{[1]}\tabularnewline\hline
\texttt{op} & \texttt{ALU\_NOR} & 5'b10100 & 按位或非运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_SLT} & 5'b00011 &
若小于则设置运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_SLTU} & 5'b00100 &
\makecell{无符号的若小于\\则设置运算}\tabularnewline\hline
\texttt{op} & \texttt{ALU\_SLL} & 5'b10101 & 左移位运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_SRL} & 5'b10110 &
逻辑右移位运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_SRA} & 5'b10111 &
算数右移位运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_SLLV} & 5'b11000 &
\makecell{寄存器为参数的\\左移位运算}\tabularnewline\hline
\texttt{op} & \texttt{ALU\_SRLV} & 5'b11001 &
\makecell{寄存器为参数的\\逻辑右移位运算}\tabularnewline\hline
\texttt{op} & \texttt{ALU\_SRAV} & 5'b11110 &
\makecell{寄存器为参数的\\算数右移位运算}\tabularnewline\hline
\texttt{.*cmp\_result} & \texttt{ALU\_EQUAL} & 2b'00 &
等于\tabularnewline\hline
\texttt{.*cmp\_result} & \texttt{ALU\_EQUAL\_TO} & \texttt{ALU\_EQUAL} &
同上\tabularnewline\hline
\texttt{.*cmp\_result} & \texttt{ALU\_LARGER} & 2b'01 &
大于\tabularnewline\hline
\texttt{.*cmp\_result} & \texttt{ALU\_LARGER\_THAN} &
\texttt{ALU\_LARGER} & 同上\tabularnewline\hline
\texttt{.*cmp\_result} & \texttt{ALU\_SMALLER} & 2b'10 &
小于\tabularnewline\hline
\texttt{.*cmp\_result} & \texttt{ALU\_SMALLER\_THAN} &
\texttt{ALU\_SMALLER} & 同上\tabularnewline\hline
\texttt{overflow} & \texttt{ALU\_OVERFLOW} & 1'b1 & 溢出\tabularnewline\hline
\texttt{overflow} & \texttt{ALU\_NOT\_OVERFLOW} & 1'b0 &
未溢出\tabularnewline\hline
\texttt{op\_invalid} & \texttt{ALU\_INVALID\_OP} & 1'b1 &
操作符无效\tabularnewline\hline
\texttt{op\_invalid} & \texttt{ALU\_INVALID} & \texttt{ALU\_INVALID\_OP}
& 同上\tabularnewline\hline
\texttt{op\_invalid} & \texttt{ALU\_VALID\_OP} & 1'b0 &
操作符有效\tabularnewline\hline
\texttt{op\_invalid} & \texttt{ALU\_VALID} & \texttt{ALU\_VALID\_OP} &
同上\tabularnewline\hline

\end{longtable}

注：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  数据转移运算只是简单地让结果等于第一个操作数，因为真正转不转移是控制模块判断写入哪个寄存器决定的。
\end{enumerate}

\hypertarget{ux529fux80fd-7}{%
\subsection{功能}\label{ux529fux80fd-7}}

若 \texttt{op} 的值为合法操作（即上面``宏定义''一节中列出的操作），按照
\texttt{op} 中给出的操作计算出结果，并把结果放入 \texttt{result}
中。然后把输入的数看成无符号数并比较，若发生上面提到的溢出现象，就令
\texttt{overflow} 为 \texttt{1\textquotesingle{}b1}，否则为
\texttt{1\textquotesingle{}b0}。注意不管 \texttt{num{[}12{]}}
输入的原来意义是什么，都把它看成无符号数进行计算。

检查溢出的方式是用一个 33
位的中间变量，在加减法时用同样的方法算出该中间变量的值。如果有溢出，那它的最高位应该为
1，否则为 0。在做其它运算时，把这个中间变量变为恒 0。

如果 \texttt{op} 的值为非法操作，就令 \texttt{op\_invalid} 为
\texttt{1\textquotesingle{}b1}，否则为
\texttt{1\textquotesingle{}b0}。此时令 \texttt{result} 为
\texttt{32\textquotesingle{}b0}。

\texttt{.*cmp\_result} 的值仅由 \texttt{num{[}12{]}}
确定，与其它输入无关。\texttt{.*cmp\_result}
的比较方式，在端口定义中。比较的输出结果，在宏定义中。不会输出宏定义中没有定义的结果。

若小于则设置运算指的是把 \texttt{alu.num1} 和 \texttt{alu.num2}
作为有符号数比较，若 \texttt{alu.num1\ \textless{}\ alu.num2}，则
\texttt{result\ =\ 32\textquotesingle{}b1}，否则
\texttt{result\ =\ 32\textquotesingle{}b0}。无符号的若小于则设置运算是把要比较的两个数作为无符号数比较，之后和若小于则设置运算相同。

左右移位运算如果不说以寄存器为参数，就用 \texttt{shamt}
作为移位位数，否则用 \texttt{num1} 的最后 5
位作为移位位数。所有的移位运算都是对 \texttt{num2} 进行移位。如果当前
\texttt{op} 不对应移位运算，则移位位数为 0。

\hypertarget{ux6ce8ux610fux4e8bux9879-4}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-4}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  添加新运算时注意同时改 \texttt{op\_invalid} 的输出和 \texttt{result}
  的输出
\item
  如果不确定符号，就加上 \texttt{{[}un\textbar{}{]}signed}
\item
  由于 ISE 不支持以变量为位数对标量切片，所以只能提前穷举移位位数的 31
  种情况，然后进行切片，如果移位位数不属于 {[}0,
  31{]}，那么切片结果是原来的标量
\end{enumerate}

\hypertarget{ux4e58ux9664ux6cd5ux5668}{%
\section{乘除法器}\label{ux4e58ux9664ux6cd5ux5668}}

\hypertarget{ux539fux7406-6}{%
\subsection{原理}\label{ux539fux7406-6}}

乘除法器是 MIPS 体系结构中运算代价比较高的部件，需要多个时钟周期进行运算。因此，它必须要有
\texttt{busy} 信号指定它是不是忙，通过是不是忙来让控制模块决定暂停和转发。

两个 32 位数的乘法结果是 64 位，所以需要两个 32
位寄存器。同样地，除法有商和余数，所以也需要两个 32
位寄存器。总结起来，乘除法器需要两个 32
位寄存器。乘法有高低位的区别，把它们叫做 \texttt{HI} 和 \texttt{LO}
寄存器能区分过来。

乘除法需要多个周期，但是模拟时乘除法只要一个周期。因此，需要在乘除法器内部设定一个计时器，模拟需要多个周期乘除法的行为。还没有准备好时，就在
\texttt{HI} 和 \texttt{LO} 寄存器输出代替的值。

\hypertarget{ux7aefux53e3ux5b9aux4e49-4}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-4}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
clk & 输入 & 1 & 时钟信号\tabularnewline\hline
rst & 输入 & 1 & 同步复位信号\tabularnewline\hline
dh & 输入 & 32 & 第一个输入的数据\tabularnewline\hline
dl & 输入 & 32 & 第二个输入的数据\tabularnewline\hline
op & 输入 & 4 & 需要的操作\tabularnewline\hline
busy & 输出 & 1 & 乘除法器是否繁忙\tabularnewline\hline
invalid & 输出 & 1 & 乘除法操作是否非法\tabularnewline\hline
hi & 输出 & 32 & \texttt{HI} 寄存器的值\tabularnewline\hline
lo & 输出 & 32 & \texttt{LO} 寄存器的值\tabularnewline\hline
out & 输出 & 32 & 乘除法模块要输出的值\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-7}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-7}}

各宏的意义如果是对应的操作，就省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{op} & \texttt{MD\_NONE} & \texttt{4\textquotesingle{}d0000}
& 无操作 \tabularnewline\hline
\texttt{op} & \texttt{MD\_MFHI} & \texttt{4\textquotesingle{}d0001}
&\tabularnewline\hline
\texttt{op} & \texttt{MD\_MFLO} & \texttt{4\textquotesingle{}d0010}
&\tabularnewline\hline
\texttt{op} & \texttt{MD\_MTHI} & \texttt{4\textquotesingle{}d0011}
&\tabularnewline\hline
\texttt{op} & \texttt{MD\_MTLO} & \texttt{4\textquotesingle{}d0100}
&\tabularnewline\hline
\texttt{op} & \texttt{MD\_MULT} & \texttt{4\textquotesingle{}d0101}
&\tabularnewline\hline
\texttt{op} & \texttt{MD\_MULTU} & \texttt{4\textquotesingle{}d0110}
&\tabularnewline\hline
\texttt{op} & \texttt{MD\_DIV} & \texttt{4\textquotesingle{}d0111}
&\tabularnewline\hline
\texttt{op} & \texttt{MD\_DIVU} & \texttt{4\textquotesingle{}d1000}
&\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-8}{%
\subsection{功能}\label{ux529fux80fd-8}}

该部件为时序部件，所有寄存器初值为 0.

有一个 4 位宽的计时器 \texttt{ctr}。

无论什么时候，\texttt{hi} 和 \texttt{lo} 都分别是 \texttt{hi\_reg} 和
\texttt{lo\_reg} 的内容。

无论什么时候，\texttt{busy} 都是 \texttt{ctr} 作为无符号数大于 0 时为 \texttt{1\textquotesingle{}b1}，否则为
\texttt{1\textquotesingle{}b0}。\texttt{invalid} 都是
\texttt{(op\_i\ ==\ MD\_DIV\ \textbar{}\textbar{}\ op\_i\ ==\ MD\_DIVU)\ \&\&\ dl\_i\ ==\ 32\textquotesingle{}b0} 时为 1'b1，否则为 1'b0。

无论什么时候，\texttt{out} 都是 \texttt{op == MD\_MFHI} 时为 \texttt{hi\_reg} 的内容，\texttt{op == MD\_MFLO} 时为 \texttt{lo\_reg} 的内容，否则为 \texttt{32'b0}。

检查内部寄存器是因为内部寄存器才是 \texttt{md} 内保存的真正状态，而且在一个时钟周期内检查来得及。

每个时钟上升沿，首先处理同步复位。然后，若 \texttt{op == MD\_MULT || op == MD\_MULTU || op == MD\_DIV || op == MD\_DIVU}，则令 \texttt{dh\_i <= dh, dl\_i <= dl, op\_i <= op}，\texttt{ctr} 为对应操作的延迟周期数。乘法操作是 5，除法操作是10。若 \texttt{op == MD\_MTHI} 或 \texttt{op == MD\_MTLO}，则把 \texttt{dh} 写入对应的内部寄存器。若 \texttt{op == MD\_NONE}，则若计时器 \texttt{ctr} 的值作为无符号数大于等于 1，则把 \texttt{ctr} 减 1。否则，若 \texttt{ctr} 的值作为无符号数等于 0，则令 \texttt{hi\_reg} 和 \texttt{lo\_reg} 分别为 \texttt{dh\_i} 和 \texttt{dl\_i} 寄存器在 \texttt{op\_i} 对应运算下的结果，同时令 \texttt{op\_i <= MD\_NONE}。否则，什么也不做。


注意：\textbf{除法是把 \texttt{dh} 当被除数，\texttt{dl}
当除数。但结果表示的时候，\texttt{hi} 当余数，\texttt{lo} 当商。若
\texttt{dl\ ==\ 32\textquotesingle{}b0}，则结果为 64'b0。}

注意：\textbf{\texttt{md} 这样设计比标准的实现会慢一个周期，但是暂停的考虑简化了。而且，这种设计主要把 \texttt{md} 的地位降低，设计成了一个从属部件，所以可以在执行连续两条乘除法指令时放弃第一条运算的结果，起到加速的作用。}

\hypertarget{ux6570ux636eux5b58ux50a8ux5668}{%
\section{数据存储器}\label{ux6570ux636eux5b58ux50a8ux5668}}

\hypertarget{ux539fux7406-7}{%
\subsection{原理}\label{ux539fux7406-7}}

数据存储器是存储数据的地方。

为了简便，数据存储器由许多寄存器实现。

\hypertarget{ux7aefux53e3ux5b9aux4e49-5}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-5}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & 输入 & 1 & 时钟信号\tabularnewline\hline
\texttt{rst} & 输入 & 1 & 同步复位信号\tabularnewline\hline
\texttt{curr\_pc} & 输入 & 32 & 当前 PC 值\tabularnewline\hline
\texttt{read\_addr} & 输入 & 32 & 读地址\tabularnewline\hline
\texttt{write\_addr} & 输入 & 32 & 写地址\tabularnewline\hline
\texttt{write\_data} & 输入 & 32 & 写数据\tabularnewline\hline
\texttt{write\_enable} & 输入 & 1 & 写使能信号\tabularnewline\hline
\texttt{mode} & 输入 & 3 & 模式选择\tabularnewline\hline
\texttt{read\_result} & 输出 & 32 & 读到的结果\tabularnewline\hline
\texttt{invalid} & 输出 & 1 & 地址是否错误\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-8}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-8}}

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{write\_enable} & \texttt{DM\_WRITE\_ENABLE} &
\texttt{1\textquotesingle{}b1} & DM 使能\tabularnewline\hline
\texttt{write\_enable} & \texttt{DM\_WRITE\_DISABLE} &
\texttt{1\textquotesingle{}b0} & DM 非使能\tabularnewline\hline
\texttt{mode} & \texttt{DM\_NONE} & 3'b000 & 不操作
\texttt{dm}\tabularnewline\hline
\texttt{mode} & \texttt{DM\_W} & 3'b001 & 读取/写入一个字\tabularnewline\hline
\texttt{mode} & \texttt{DM\_H} & 3'b011 & 读取/写入半个字\tabularnewline\hline
\texttt{mode} & \texttt{DM\_HU} & 3'b010 &
\makecell{读取半个字，\\按无符号数读取}\tabularnewline\hline
\texttt{mode} & \texttt{DM\_B} & 3'b101 &
读取/写入一个字节\tabularnewline\hline
\texttt{mode} & \texttt{DM\_BU} & 3'b110 &
\makecell{读取一个字节，\\按无符号数读取}\tabularnewline\hline
\texttt{.*\_addr} & \texttt{DM\_ADDR\_WIDTH} & 14 & \texttt{.*\_addr}
的位宽\tabularnewline\hline
数据存储器 & \texttt{DM\_SIZE} & 4096 & 能存储 32 位字的个数\tabularnewline\hline
输出 & \texttt{DM\_OUTPUT\_FORMAT} & \texttt{\%d@\%h: *\%h <= \%h} & 输出模板\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-9}{%
\subsection{功能}\label{ux529fux80fd-9}}

该部件为时序部件。

有 \texttt{DM\_SIZE} 个 32 位存储器，代表其中存储的指令。它们初值都为
\texttt{32\textquotesingle{}b0}。

首先得出操作地址 \texttt{op\_addr}。若
\texttt{write\_enable\ ==\ DM\_ENABLED}，则操作地址为写地址，否则操作地址为读地址。

然后确定操作是否合法。若
\texttt{mode\ ==\ DM\_NONE\ \textbar{}\textbar{}\ (mode\ ==\ DM\_W\ \&\&\ op\_addr{[}1:0{]}\ ==\ 2\textquotesingle{}b0)\ \textbar{}\textbar{}\ (mode\ ==\ DM\_H\ \&\&\ op\_addr{[}0{]}\ ==\ 1\textquotesingle{}b0)\ \textbar{}\textbar{}\ (mode\ ==\ DM\_HU\ \&\&\ op\_addr{[}0{]}\ =\ 1\textquotesingle{}b0)\ \textbar{}\textbar{}\ mode\ ==\ DM\_B\ \textbar{}\textbar{}\ mode\ ==\ DM\_BU}，则操作合法，否则操作不合法。

在每个时钟上升沿，若
\texttt{write\_enable\ ==\ DM\_ENABLED\ \&\&\ invalid\ ==\ 0}，则根据操作模式写入相应地址对应的数据。写入半个字和字节分别取
\texttt{write\_data} 的低 16 位和低 8 位。同时，打印模拟时间、当前 PC
的值、\texttt{write\_addr}
对应的字和它对应字的新值。如果是写入半个字或者字节，也打印对应字的新值。

任何时候，若 \texttt{invalid\ ==\ 1\textquotesingle{}b1}，则
\texttt{read\_result\ ==\ 32\textquotesingle{}b0}。否则，若 \texttt{mode\ ==\ DM\_NONE}，则
\texttt{read\_result\ ==\ 32\textquotesingle{}b0}。若 \texttt{mode}
为其它 \texttt{dm} 宏的值，则按照相应宏的意义读出数据，读到
\texttt{read\_result} 中。若 \texttt{mode} 为其他值，则
\texttt{read\_result\ ==\ 32\textquotesingle{}b0}。

注意 \texttt{dm} 内部对 \texttt{write\_addr} 和 \texttt{read\_addr}
都截取了一部分。这样可以把 \texttt{dm}
直接接入数据通路，在数据通路中假定地址是 32 位的；同时 \texttt{dm}
的实现不需要那么多寄存器，更现实。但是实际上这样对地址空间进行了限制。

\hypertarget{ux6ce8ux610fux4e8bux9879-5}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-5}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{DM\_ADDR\_WIDTH} 和 \texttt{DM\_ADDR\_SIZE} 要一块改
\item
  地址空间是被截断的，看起来是 32 位，实际上不是
\item
  \textbf{CPU 是小端序的}
\item
  为了能打印出写到的字的值，可以把值提前用组合电路算出来
\item \textbf{注意 \texttt{\$display} 的时候，参数应该是新值，因为赋值用的是异步赋值}
\end{enumerate}

\hypertarget{ux6d41ux6c34ux7ebfux5bc4ux5b58ux5668}{%
\section{流水线寄存器}\label{ux6d41ux6c34ux7ebfux5bc4ux5b58ux5668}}

\hypertarget{ux539fux7406-8}{%
\subsection{原理}\label{ux539fux7406-8}}

流水线中需要很多寄存器来保存中间状态，而直接使用 \texttt{always}
块写，有不容易管理的缺点。所以更好的方法是设置流水线寄存器。

\hypertarget{ux7aefux53e3ux5b9aux4e49-6}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-6}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & 输入 & 1 & 时钟信号\tabularnewline\hline
\texttt{enable} & 输入 & 1 & 使能\tabularnewline\hline
\texttt{rst} & 输入 & 1 & 同步复位信号\tabularnewline\hline
\texttt{i} & 输入 & \texttt{BIT\_WIDTH} & 输入的数据\tabularnewline\hline
\texttt{o} & 输出 & \texttt{BIT\_WIDTH} & 输出的数据\tabularnewline\hline

\end{longtable}

\hypertarget{ux53c2ux6570ux5b9aux4e49}{%
\subsection{参数定义}\label{ux53c2ux6570ux5b9aux4e49}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{默认值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
寄存器位宽 & \texttt{BIT\_WIDTH} & 32 & 寄存器的位宽\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-9}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-9}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{enable} & \texttt{PFF\_ENABLED} & \texttt{1\textquotesingle{}b1}
& 使能\tabularnewline\hline
\texttt{enable} & \texttt{PFF\_DISABLED} &
\texttt{1\textquotesingle{}b0} & 使能\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-10}{%
\subsection{功能}\label{ux529fux80fd-10}}

该部件为时序部件。

该部件内部的寄存器初值为全 0。

每个时钟上升沿，如果
\texttt{rst\ ==\ 1\textquotesingle{}b1}，就令寄存器的值为全
\texttt{0}。否则，如果
\texttt{enable\ ==\ PFF\_ENABLED}，则令寄存器的值为 \texttt{i}
的值。否则寄存器的值不变。

输出端口 \texttt{o} 的值总是寄存器的值。

\hypertarget{ux6ce8ux610fux4e8bux9879-6}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-6}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  复位设成了同步复位，这是为了更好地插入气泡。
\end{enumerate}

\hypertarget{mux}{%
\section{MUX}\label{mux}}

\hypertarget{ux529fux80fd-11}{%
\subsection{功能}\label{ux529fux80fd-11}}

MUX
是多路选择器的意思，是从多个数据源中选择数据的部件。其实它也是数据通路和控制之间的接口，控制部件通过
MUX 来控制数据的流向，实现指令的功能。

\hypertarget{ux7c7bux522b}{%
\subsection{类别}\label{ux7c7bux522b}}

MUX 有多个类别。有 2 路 MUX、3 路 MUX 以至于多路 MUX。实际上，在单周期
CPU 中只能用到路数比较少的 MUX，多路的 MUX 要等到流水线 CPU
的时候才能用。

\hypertarget{ux547dux540d}{%
\subsection{命名}\label{ux547dux540d}}

由于 MUX 有多个类别，所以它也有多个
\texttt{module}，也有多个命名。\emph{n} 路 MUX 命名为
\texttt{mux}\emph{n}。

\hypertarget{ux5b8fux5b9aux4e49-10}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-10}}

暂无

但是仍然保留 \texttt{mux.h} 宏文件并填入模版，以备以后使用。

\hypertarget{ux53c2ux6570ux5b9aux4e49-1}{%
\subsection{参数定义}\label{ux53c2ux6570ux5b9aux4e49-1}}

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
\headingcellfirst{参数} & \headingcellmiddle{默认值} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{BIT\_WIDTH} & 32 & 输入和输出数据的位宽\tabularnewline\hline

\end{longtable}

\hypertarget{ux7aefux53e3ux5b9aux4e49-7}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-7}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{control} & 输入 & \textsuperscript{[1]} & 输入控制信号\tabularnewline\hline
\texttt{result} & 输出 & \texttt{BIT\_WIDTH} & 输出数据\tabularnewline\hline
\texttt{input}\emph{n} & 输入 & \texttt{BIT\_WIDTH} & \textsuperscript{[2]}\tabularnewline\hline

\end{longtable}

注：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  输入控制信号的位宽如下计算：有 \emph{n} 个输入信号，就取最小的使
  \emph{2\^{}width} 能够超过 \emph{n} 的 \emph{width}，这就是
  \texttt{control} 的位宽。
\item
  功能是输入端口，但是个数有 \emph{n} 个。输入端口\textbf{从 0
  开始计数}。
\end{enumerate}

\hypertarget{ux529fux80fd-12}{%
\subsection{功能}\label{ux529fux80fd-12}}

若 \texttt{control} 的值为
\emph{width}\texttt{\textquotesingle{}d}\emph{n}，则令 \texttt{result}
的值为 \texttt{input}\emph{n} 的值。但是若 \emph{n} 超出了 MUX
的输入端口个数（即路数）或 \emph{n} 为其它值，则令 \texttt{result}
的值为 \texttt{input0} 的值。

\hypertarget{ux6ce8ux610fux4e8bux9879-7}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-7}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{BIT\_WIDTH} 默认为 32，是因为一般传送的数据都是 32 位的。
\item
  接线时端口顺序\textbf{按照数据通路部分最终总结出来的接线表格中指定的顺序来！}
\item
  \textbf{\emph{n} 为其他值可能是 \texttt{x} 或 \texttt{z}！}
\end{enumerate}

\hypertarget{ux6d41ux6c34ux7ebf-cpu-ux6570ux636eux901aux8def}{%
\section{流水线 CPU
数据通路}\label{ux6d41ux6c34ux7ebf-cpu-ux6570ux636eux901aux8def}}

\hypertarget{ux539fux7406-9}{%
\subsection{原理}\label{ux539fux7406-9}}

流水线技术是通过指令级并行，缩短每级的执行时间从而提高频率的技术。这样可以让关键路径缩短，从而提升频率，因此提高了执行效率。

流水线要注意会出现冒险问题，因此会有暂停和转发机制。暂停和转发实际上是控制的内容，数据通路只需要留出需要的部件即可。

\hypertarget{ux5206ux6790}{%
\subsection{分析}\label{ux5206ux6790}}

p6 需要实现的指令为：

\begin{verbatim}
addu, subu, add, sub, sll, srl, sra, and, or, nor, xor, 
    slt, sltu, sllv, srlv, srav
lui, ori, addi, addiu, andi, xori, slti, sltiu
lw, lh, lhu, lb, lbu
sw, sh, sb
beq, bne, blez, bgez, bltz, bgtz
j, jal
jr, jalr
movz
mult, multu, div, divu
mfhi, mflo
mthi, mtlo
\end{verbatim}

\texttt{nop} 作为 \texttt{sll} 指令的一种特殊情况存在。

由于不同指令的数据通路可以归类，因此首先需要对数据通路进行分类，之后再对每类数据通路总结连接。数据通路分类表如下。

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcelllast{指令}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{UNKNOWN} & （未知指令）\tabularnewline\hline
\texttt{CAL\_R} &
\makecell{\texttt{addu,\ subu,\ add,\ sub,\ sll,\ srl,\ sra,\ and,\ or,\ nor,}\\\texttt{xor,\ slt,\ sltu,\ sllv,\ srlv,\ srav}}\tabularnewline\hline
\texttt{CAL\_I} &
\texttt{lui,\ ori,\ addi,\ addiu,\ andi,\ xori,\ slti,\ sltiu}\tabularnewline\hline
\texttt{LOAD} & \texttt{lw,\ lh,\ lhu,\ lb,\ lbu}\tabularnewline\hline
\texttt{STORE} & \texttt{sw,\ sh,\ sb}\tabularnewline\hline
\texttt{BRANCH} &
\texttt{beq,\ bne,\ blez,\ bgez,\ bltz,\ bgtz}\tabularnewline\hline
\texttt{JUMP\_I} & \texttt{j,\ jal}\tabularnewline\hline
\texttt{JUMP\_R} & \texttt{jr,\ jalr}\tabularnewline\hline
\texttt{CMOV} & \texttt{movz}\tabularnewline\hline
\texttt{CAL\_M} & \texttt{mult,\ multu,\ div,\ divu}\tabularnewline\hline
\texttt{LOAD\_M} & \texttt{mfhi,\ mflo}\tabularnewline\hline
\texttt{STORE\_M} & \texttt{mthi,\ mtlo}\tabularnewline\hline

\end{longtable}

通过分析它们的
RTL，可以得到每条指令对应的数据通路连接如下。其中表格某一列的值表示这个输入端口是哪个输出端口的输出。端口用
\texttt{流水线级:\ 部件.端口名字}
格式表示。空白的单元格表示不用关心相对应的端口的值，因为它们会被忽略，不影响指令的正常执行。未知指令只需要屏蔽各个写入的使能，这样就可以避免未知指令的影响，因此不用分析未知指令。

有时部件名称可能和级不对应。这表示相应端口的值是经过流水后的结果。

由于指令分析函数可以分析到指令读写的寄存器，因此把 D 级和 E
级的三个寄存器地址端口交给控制模块控制。这样也能避免在不该写寄存器的指令写寄存器，因为哪怕寄存器写入使能打开，要写入的寄存器也是
\texttt{ZERO}。

注意：\textbf{使用延迟槽来简化暂停和转发的分析。}

\hypertarget{f-ux7ea7if}{%
\paragraph{F 级（IF）}\label{f-ux7ea7if}}

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcellmiddle{\texttt{F: npc.alu\_comp\_result}} & \headingcelllast{\texttt{F: npc.num}} \\\hline
\endhead\hiderowcolors
\texttt{BRANCH} & \texttt{D: cmp.cmp} & \texttt{D: im.result[15:0]}\\\hline
其它 & & \\\hline
（综合）& \texttt{D: cmp.cmp} & \texttt{D: im.result[15:0]} \\\hline
\end{longtable}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcellmiddle{\texttt{F: npc.curr\_pc}} & \headingcelllast{\texttt{F: npc.jnum}} & \texttt{\texttt{F: npc.reg}}\\\hline
\endhead\hiderowcolors
\texttt{JUMP\_R} & \texttt{F: pc.curr\_pc} & & \texttt{D: rf.read\_result1} \\\hline 
\texttt{JUMP\_I} & \texttt{F: pc.curr\_pc} & \texttt{F: im.result[25:0]} & \\\hline
其它 & \texttt{F: pc.curr\_pc} & & \\\hline
（综合） & \texttt{F: pc.curr\_pc} & \texttt{D: im.result[25:0]} & \texttt{D: rf.read\_result1} \\\hline
\end{longtable}

\hypertarget{d-ux7ea7id}{%
\paragraph{D 级（ID）}\label{d-ux7ea7id}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcellmiddle{\texttt{D:\ ext.num}} & \headingcellmiddle{\texttt{D:\ cmp.reg1}} &
\headingcelllast{\texttt{D:\ cmp.reg2}}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{CAL\_R} & & &\tabularnewline\hline
\texttt{CAL\_I} & \texttt{D:\ im.result{[}15:0{]}} & &\tabularnewline\hline
\texttt{LOAD} & \texttt{D:\ im.result{[}15:0{]}} & &\tabularnewline\hline
\texttt{STORE} & & &\tabularnewline\hline
\texttt{BRANCH} & & \texttt{D:\ rf.read\_result1} &
\makecell{\texttt{D:\ rf.read\_}\\\texttt{result2}}\tabularnewline\hline
\texttt{NOP} & & &\tabularnewline\hline
\texttt{JUMP\_I} & & &\tabularnewline\hline
\texttt{JUMP\_R} & & &\tabularnewline\hline
\texttt{CAL\_M} & & &\tabularnewline\hline
\texttt{LOAD\_M} & & &\tabularnewline\hline
\texttt{STORE\_M} & & &\tabularnewline\hline
综合 & \texttt{D:\ im.result{[}15:0{]}} & \texttt{D:\ rf.read\_result1}
& \makecell{\texttt{D:\ rf.read\_}\\\texttt{result2}}\tabularnewline\hline

\end{longtable}

\hypertarget{e-ux7ea7ex}{%
\paragraph{E 级（EX）}\label{e-ux7ea7ex}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcellmiddle{\texttt{E:\ alu.num1}} & \headingcellmiddle{\texttt{E:\ alu.num2}} &
\headingcelllast{\texttt{E:\ alu.shamt}} \tabularnewline\hline

\endhead\hiderowcolors
\texttt{CAL\_R} & \texttt{D:\ rf.read\_result1} &
\texttt{D:\ rf.read\_result2} & \makecell{\texttt{D:\ im.result}\\\texttt{{[}10:6{]}}}\tabularnewline\hline
\texttt{CAL\_I} & \texttt{D:\ rf.read\_result1} &
\texttt{D:\ ext.result} & \tabularnewline\hline
\texttt{LOAD} & \texttt{D:\ rf.read\_result1} & \texttt{D:\ ext.result}
&\tabularnewline\hline
\texttt{STORE} & \texttt{D:\ rf.read\_result1} & \texttt{D:\ ext.result}
&\tabularnewline\hline
\texttt{BRANCH} & & & \tabularnewline\hline
\texttt{NOP} & & & \tabularnewline\hline
\texttt{JAL} & & & \tabularnewline\hline
\texttt{JR} & & & \tabularnewline\hline
\texttt{CMOV} & \texttt{D:\ rf.read\_result1} &
\texttt{D:\ rf.read\_result2} & \tabularnewline\hline
\texttt{CAL\_M} & & & \tabularnewline\hline
\texttt{LOAD\_M} & & & \tabularnewline\hline
\texttt{STORE\_M} & & & \tabularnewline\hline
综合 & \texttt{D:\ rf.read\_result1} &
\makecell{\texttt{D:\ rf.read\_result2,}\\\texttt{D:\ ext.result}} &
\makecell{\texttt{D:\ im.result}\\\texttt{{[}10:6{]}}} \tabularnewline\hline

\end{longtable}

\begin{longtable}[]{@{}|l|l|l|}
\hline
\headingcellfirst{数据通路类型} & \headingcellmiddle{\texttt{D: md.dh}} & \headingcellmiddle{\texttt{D: md.dl}}\\\hline
\endhead\hiderowcolors
\texttt{CAL\_M} & \texttt{D: rf.read\_result1} & \texttt{D: rf.read\_result2}\\\hline
\texttt{STORE\_M} & \texttt{D: rf.read\_result1} & \texttt{D: rf.read\_result2}\\\hline
其它 & & \\\hline
（综合） & \texttt{D: rf.read\_result1} & \texttt{D: rf.read\_result2}\\\hline

\end{longtable}

\hypertarget{m-ux7ea7mem}{%
\paragraph{M 级（MEM）}\label{m-ux7ea7mem}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcellmiddle{\texttt{M:\ dm.read\_addr}} & \headingcellmiddle{\texttt{M:\ dm.write\_addr}}
& \headingcelllast{\texttt{M:\ dm.write\_data}}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{CAL\_R} & & &\tabularnewline\hline
\texttt{CAL\_I} & & &\tabularnewline\hline
\texttt{LOAD} & \texttt{E:\ alu.result} & &\tabularnewline\hline
\texttt{STORE} & & \texttt{E:\ alu.result} &
\texttt{E:\ rf.read\_result2}\tabularnewline\hline
\texttt{BRANCH} & & &\tabularnewline\hline
\texttt{NOP} & & &\tabularnewline\hline
\texttt{JAL} & & &\tabularnewline\hline
\texttt{JR} & & &\tabularnewline\hline
\texttt{CMOV} & & &\tabularnewline\hline
\texttt{CAL\_M} & & &\tabularnewline\hline
\texttt{LOAD\_M} & & &\tabularnewline\hline
\texttt{STORE\_M} & & &\tabularnewline\hline
综合 & \texttt{E:\ alu.result} & \texttt{E:\ alu.result} &
\texttt{E:\ rf.read\_result2}\tabularnewline\hline

\end{longtable}

\hypertarget{w-ux7ea7wb}{%
\paragraph{W 级（WB）}\label{w-ux7ea7wb}}

\begin{longtable}[]{@{}|l|l|@{}}
\hline
数据通路类型 & \texttt{W:\ rf.write\_data}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{CAL\_R} & \texttt{E:\ alu.result}\tabularnewline\hline
\texttt{CAL\_I} & \texttt{E:\ alu.result}\tabularnewline\hline
\texttt{LOAD} & \texttt{M:\ dm.read\_result}\tabularnewline\hline
\texttt{STORE} &\tabularnewline\hline
\texttt{BRANCH} &\tabularnewline\hline
\texttt{NOP} &\tabularnewline\hline
\texttt{JAL} &
\texttt{F:\ \$unsigned(pc.curr\_pc)\ +\ \$unsigned(8)}\tabularnewline\hline
\texttt{JR} &\tabularnewline\hline
\texttt{CMOV} & \texttt{E:\ alu.result}\tabularnewline\hline
\texttt{CAL\_M} &\tabularnewline\hline
\texttt{LOAD\_M} & \texttt{E:\ md.out}\tabularnewline\hline
\texttt{STORE\_M} &\tabularnewline\hline
综合 &
\makecell{\texttt{E:\ alu.result}\\\texttt{E: md.out}\\\texttt{M:\ dm.read\_result}\\\texttt{F:\ \$unsigned(pc.curr\_pc)\ +\ \$unsigned(8)}\\\texttt{E:\ md.out}}\tabularnewline\hline

\end{longtable}

\hypertarget{ux6d41ux6c34ux7ebfux5bc4ux5b58ux5668-1}{%
\paragraph{流水线寄存器}\label{ux6d41ux6c34ux7ebfux5bc4ux5b58ux5668-1}}

由于流水线需要保存每一级流水线的执行结果，所以需要流水线寄存器。需要保存的执行结果，可以从上面数据通路表格中综合出来。为了方便和上面的表格对应，每一级流水线的流水线寄存器都保存上一级流水线的数据。

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
流水线级 & 信号 & 流水线寄存器名称\tabularnewline\hline

\endhead\hiderowcolors
D & \texttt{im.result} & \texttt{d\_im}\tabularnewline\hline
E & \texttt{rf.read\_result1} & \texttt{e\_reg1}\tabularnewline\hline
E & \texttt{rf.read\_result2} & \texttt{e\_reg2}\tabularnewline\hline
E & \texttt{ext.result} & \texttt{e\_ext}\tabularnewline\hline
M & \texttt{alu.result} & \texttt{m\_alu}\tabularnewline\hline
M & \texttt{rf.read\_result2} & \texttt{m\_reg2}\tabularnewline\hline
W & \texttt{alu.result} & \texttt{w\_alu}\tabularnewline\hline
W & \texttt{dm.read\_result} & \texttt{w\_dm}\tabularnewline\hline
W & \texttt{pc.curr\_pc} & \texttt{w\_pc}\tabularnewline\hline
W & \texttt{md.out} & \texttt{w\_md}\tabularnewline\hline

\end{longtable}

由于需要的流水线寄存器有跨级的（比如只有 D 级和 W
级），所以需要把漏掉的级补充上。

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
流水线级 & 信号 & 流水线寄存器名称\tabularnewline\hline

\endhead\hiderowcolors
D & \texttt{pc.curr\_pc} & \texttt{d\_pc}\tabularnewline\hline
E & \texttt{pc.curr\_pc} & \texttt{e\_pc}\tabularnewline\hline
M & \texttt{pc.curr\_pc} & \texttt{m\_pc}\tabularnewline\hline
M & \texttt{md.out} & \texttt{m\_md} \\\hline

\end{longtable}

这里没有补充 D 级 \texttt{BRANCH} 类指令需要的 \texttt{alu.comp\_result}
到 F 级的连接以及 \texttt{JAL} 和 \texttt{JR} 类指令相应数据到 F
级的连接，因为为了正确控制 PC
的转换，它们必须是实时的，不需要流水线寄存器。

注意：\textbf{返回 \texttt{PC\ +\ 8} 实际上是通过流水 \texttt{PC} 再加 8
实现的。}

注意：\textbf{D 级流水线寄存器都要接使能信号，E
级流水线寄存器都要接复位信号，因为要插入气泡。}

\hypertarget{ux6570ux636eux901aux8def-mux}{%
\paragraph{数据通路 MUX}\label{ux6570ux636eux901aux8def-mux}}

最后是把所有可能的连接综合起来以后，得到的结果。如果有多个可能的连接，就需要一个
MUX。把 MUX 的输出端口连接在相应的输入端口上，MUX
的输入端口要保证所有可能的输入端口都能连接上。

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
端口 & 所有的信号来源 & MUX 名称\tabularnewline\hline

\endhead\hiderowcolors
\texttt{E:\ alu.num2} & \texttt{D:\ rf.read\_result2,\ D:\ ext.result} &
\texttt{m\_alusrc}\tabularnewline\hline
\texttt{W:\ rf.write\_data} &
\makecell{（无）\\\texttt{E:\ alu.result}\\\texttt{M:\ dm.read\_result}\\\texttt{D:\ npc.next\_pc}\\\texttt{E:\ md.out}}
& \texttt{m\_regdata}\tabularnewline\hline

\end{longtable}

注意：\textbf{都是把信号来源从 0 开始编号，对应 MUX 的
\texttt{input}\emph{n} 接第 \emph{n} 个信号源。}

注意：\textbf{如果写了（无），那么相应端口的数据为全
0，不过这时相应端口实际上也没有作用。}

\hypertarget{ux8f6cux53d1}{%
\subsection{转发}\label{ux8f6cux53d1}}

需要转发是因为可能出现后面的指令需要使用前面的指令的结果，而前面的指令结果来不及写回（数据冒险）的情况。由于同一个时钟周期只有一条指令读写
\texttt{dm}，所以 \texttt{dm} 不需要转发。但是 \texttt{rf}
在同一个时钟周期内一般会有多条指令读写，所以 \texttt{rf} 需要转发。

转发的原则就是比较新的指令需要读的寄存器和比较老的指令需要写的寄存器一样。对这个条件的判断，在指令识别函数中已经有了。注意一条指令最多读
2 个寄存器，所以要判断 2 次。

转发是通过转发 MUX
来更改数据通路上寄存器的值，从而达到提前更新的目的。首先，数据通路上有寄存器值的地方，一共有五处：\texttt{D:\ rf.read\_result1,\ D:\ rf.read\_result2,\ E:\ rf.read\_result1,\ E:\ rf.read\_result2,\ M:\ dm.write\_data}。其中
E
级的两处是通过流水线寄存器暂存的。这五处可以分三类。对每类需要构造的转发
MUX 总结如下。

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
端口 & 所有的信号来源 & MUX 名称\tabularnewline\hline

\endhead\hiderowcolors
\texttt{D:\ rf.read\_result{[}12{]}} &
\makecell{\texttt{E:\ rf.read\_result1}\\\texttt{E:\ npc.next\_pc}\\\texttt{M:\ npc.next\_pc}\\\texttt{M:\ alu.result}\\\texttt{W:\ rf.write\_data}\\\texttt{M:\ md.out}}
& \texttt{fm\_d1}\tabularnewline\hline
\texttt{E:\ rf.read\_result{[}12{]}} &
\makecell{\texttt{M:\ npc.next\_pc}\\\texttt{M:\ alu.result}\\\texttt{W:\ rf.write\_data}\\\texttt{M:\ md.out}}
& \texttt{fm\_e1}\tabularnewline\hline
\texttt{M:\ dm.write\_data} & \texttt{W:\ rf.write\_data} &
\texttt{fm\_m}\tabularnewline\hline

\end{longtable}

\textbf{注意：不能在 M 级设置 MUX 转发 \texttt{dm} 的数据，因为这样 D
级或 E 级会等待 M 级 \texttt{dm}
的数据，关键路径会变得非常长，极大地降低流水线性能。同样地，也不能在 E
级设置 MUX 转发 \texttt{alu} 的数据。}

转发 MUX
最终是由控制模块控制的。但是控制模块也没法克服有些数据通路不能转发的现实（比如
\texttt{M:\ dm.read\_result}）。这就需要------

\hypertarget{ux6682ux505c}{%
\subsection{暂停}\label{ux6682ux505c}}

需要暂停是因为有些数据冒险靠转发解决不了，必须要让后面的指令暂停一个时钟周期。暂停的方式是在流水线中插入一个
NOP（这时候也叫气泡），从而让发生数据冒险的指令能够转发。

流水线 CPU 数据通路中能提供的暂停机制有锁定 \texttt{pc} 和清空 E
级各个流水线寄存器。这样就可以在流水线 E 级插入气泡。清空 E
级各个寄存器是通过流水线寄存器的同步复位功能实现的。

\hypertarget{ux6307ux4ee4ux8bc6ux522bux673aux5236}{%
\section{指令识别机制}\label{ux6307ux4ee4ux8bc6ux522bux673aux5236}}

\hypertarget{ux539fux7406-10}{%
\subsection{原理}\label{ux539fux7406-10}}

指令识别机制是为了判断指令的功能而设计的。它可以实现判断指令的具体类型、数据通路类型、需要的控制信号等功能。用这些函数识别出来的数据，就可以判断指令的数据流、转发和暂停相关信息和异常相关信息等。

\hypertarget{ux5b8fux5b9aux4e49-11}{%
\paragraph{宏定义}\label{ux5b8fux5b9aux4e49-11}}

由于有特殊的指令读写固定的寄存器，所以寄存器号也要宏定义。

由于函数的声明需要一定的范式保证健壮性，所以函数的声明本身也要定义。

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
寄存器号 & \texttt{ZERO} & \texttt{5\textquotesingle{}d0} & \makecell{0 号寄存器（或者表示某指令\\在某函数下对应的寄存器不存在）}\tabularnewline\hline
寄存器号 & \texttt{NULL} & \texttt{ZERO} &\tabularnewline\hline
寄存器号 & \texttt{RA} & \texttt{5\textquotesingle{}d31} & 31
号寄存器（\texttt{\$ra}，\texttt{jal} 指令要写入）\tabularnewline\hline

\end{longtable}

\hypertarget{ux7aefux53e3ux5b9aux4e49-8}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-8}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能} \\\hline
\endhead\hiderowcolors
\texttt{instr} & 输入 & 32 & 要分析的指令 \\\hline
\texttt{kind} & 输出 & 9 & 当前指令的具体类型 \\\hline
\end{longtable}

\hypertarget{ux529fux80fd-13}{%
\subsection{功能}\label{ux529fux80fd-13}}

获取当前指令的具体类型。返回的结果一共 9 位，前 4 位是数据通路类型，后 5 位是具体类型。

若指令的格式符合 MIPS
指令集中的相应格式，则返回对应指令的代码（在宏定义一节中描述）。否则，返回
0。

\hypertarget{ux5b8fux5b9aux4e49-12}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-12}}

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

编码方式为前 4 位为数据通路类型，后 5 位为其下的具体类型。

指令的意义在表示相应指令的情况下省略不写。但如果有相应备注，也会在这栏注明。

\hypertarget{ux6307ux4ee4ux5b57ux6bb5}{%
\paragraph{指令字段}\label{ux6307ux4ee4ux5b57ux6bb5}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
指令字段 & \texttt{OP(x)} & \texttt{(x{[}31:26{]})} & 指令的 \texttt{op}
字段\tabularnewline\hline
指令字段 & \texttt{RS(x)} & \texttt{(x{[}25:21{]})} & 指令的 \texttt{rs}
字段\tabularnewline\hline
指令字段 & \texttt{RT(x)} & \texttt{(x{[}20:16{]})} & 指令的 \texttt{rt}
字段\tabularnewline\hline
指令字段 & \texttt{RD(x)} & \texttt{(x{[}15:11{]})} & 指令的 \texttt{rd}
字段\tabularnewline\hline
指令字段 & \texttt{SHAMT(x)} & \texttt{(x{[}10:6{]})} & 指令的
\texttt{shamt} 字段\tabularnewline\hline
指令字段 & \texttt{FUNCT(x)} & \texttt{(x{[}5:0{]})} & 指令的
\texttt{funct} 字段\tabularnewline\hline
指令字段 & \texttt{IMM(x)} & \texttt{(x{[}15:0{]})} & 指令的
\texttt{imm} 字段\tabularnewline\hline
指令字段 & \texttt{IMM\_J(x)} & \texttt{(x{[}25:0{]})} & \texttt{j}
指令的 \texttt{imm} 字段\tabularnewline\hline

\end{longtable}

\hypertarget{ux6307ux4ee4ux7c7bux578b}{%
\paragraph{指令类型}\label{ux6307ux4ee4ux7c7bux578b}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
指令类型 & \texttt{UNKNOWN} & \texttt{9\textquotesingle{}b0000\_00000} &
未知指令\tabularnewline\hline
指令类型 & \texttt{UNK} & \texttt{UNKNOWN} &\tabularnewline\hline
指令类型 & \texttt{ADDU} & \texttt{9\textquotesingle{}b0001\_00000}
&\tabularnewline\hline
指令类型 & \texttt{SUBU} & \texttt{9\textquotesingle{}b0001\_00001}
&\tabularnewline\hline
指令类型 & \texttt{ADD} & \texttt{9\textquotesingle{}b0001\_00010}
&\tabularnewline\hline
指令类型 & \texttt{SUB} & \texttt{9\textquotesingle{}b0001\_00011}
&\tabularnewline\hline
指令类型 & \texttt{SLL} & \texttt{9\textquotesingle{}b0001\_00100}
&\tabularnewline\hline
指令类型 & \texttt{SRL} & \texttt{9\textquotesingle{}b0001\_00101}
&\tabularnewline\hline
指令类型 & \texttt{SRA} & \texttt{9\textquotesingle{}b0001\_00110}
&\tabularnewline\hline
指令类型 & \texttt{AND} & \texttt{9\textquotesingle{}b0001\_00111}
&\tabularnewline\hline
指令类型 & \texttt{OR} & \texttt{9\textquotesingle{}b0001\_01000}
&\tabularnewline\hline
指令类型 & \texttt{NOR} & \texttt{9\textquotesingle{}b0001\_01001}
&\tabularnewline\hline
指令类型 & \texttt{XOR} & \texttt{9\textquotesingle{}b0001\_01010}
&\tabularnewline\hline
指令类型 & \texttt{SLT} & \texttt{9\textquotesingle{}b0001\_01011}
&\tabularnewline\hline
指令类型 & \texttt{SLTU} & \texttt{9\textquotesingle{}b0001\_01100}
&\tabularnewline\hline
指令类型 & \texttt{SLLV} & \texttt{9\textquotesingle{}b0001\_01101}
&\tabularnewline\hline
指令类型 & \texttt{SRLV} & \texttt{9\textquotesingle{}b0001\_01110}
&\tabularnewline\hline
指令类型 & \texttt{SRAV} & \texttt{9\textquotesingle{}b0001\_01111}
&\tabularnewline\hline
指令类型 & \texttt{LUI} & \texttt{9\textquotesingle{}b0010\_00000}
&\tabularnewline\hline
指令类型 & \texttt{ORI} & \texttt{9\textquotesingle{}b0010\_00001}
&\tabularnewline\hline
指令类型 & \texttt{ADDI} & \texttt{9\textquotesingle{}b0010\_00010}
&\tabularnewline\hline
指令类型 & \texttt{ADDIU} & \texttt{9\textquotesingle{}b0010\_00011}
&\tabularnewline\hline
指令类型 & \texttt{ANDI} & \texttt{9\textquotesingle{}b0010\_00100}
&\tabularnewline\hline
指令类型 & \texttt{XORI} & \texttt{9\textquotesingle{}b0010\_00101}
&\tabularnewline\hline
指令类型 & \texttt{SLTI} & \texttt{9\textquotesingle{}b0010\_00110}
&\tabularnewline\hline
指令类型 & \texttt{SLTIU} & \texttt{9\textquotesingle{}b0010\_00111}
&\tabularnewline\hline
指令类型 & \texttt{LW} & \texttt{9\textquotesingle{}b0011\_00000}
&\tabularnewline\hline
指令类型 & \texttt{LH} & \texttt{9\textquotesingle{}b0011\_00001}
&\tabularnewline\hline
指令类型 & \texttt{LHU} & \texttt{9\textquotesingle{}b0011\_00010}
&\tabularnewline\hline
指令类型 & \texttt{LB} & \texttt{9\textquotesingle{}b0011\_00011}
&\tabularnewline\hline
指令类型 & \texttt{LBU} & \texttt{9\textquotesingle{}b0011\_00100}
&\tabularnewline\hline
指令类型 & \texttt{SW} & \texttt{9\textquotesingle{}b0100\_00000}
&\tabularnewline\hline
指令类型 & \texttt{SH} & \texttt{9\textquotesingle{}b0100\_00001}
&\tabularnewline\hline
指令类型 & \texttt{SB} & \texttt{9\textquotesingle{}b0100\_00010}
&\tabularnewline\hline
指令类型 & \texttt{BEQ} & \texttt{9\textquotesingle{}b0101\_00000}
&\tabularnewline\hline
指令类型 & \texttt{BNE} & \texttt{9\textquotesingle{}b0101\_00001}
&\tabularnewline\hline
指令类型 & \texttt{BLEZ} & \texttt{9\textquotesingle{}b0101\_00010}
&\tabularnewline\hline
指令类型 & \texttt{BGEZ} & \texttt{9\textquotesingle{}b0101\_00011}
&\tabularnewline\hline
指令类型 & \texttt{BLTZ} & \texttt{9\textquotesingle{}b0101\_00100}
&\tabularnewline\hline
指令类型 & \texttt{BGTZ} & \texttt{9\textquotesingle{}b0101\_00101}
&\tabularnewline\hline
指令类型 & \texttt{J} & \texttt{9\textquotesingle{}b0110\_00000}
&\tabularnewline\hline
指令类型 & \texttt{JAL} & \texttt{9\textquotesingle{}b0110\_00001}
&\tabularnewline\hline
指令类型 & \texttt{JR} & \texttt{9\textquotesingle{}b0111\_00000}
&\tabularnewline\hline
指令类型 & \texttt{JALR} & \texttt{9\textquotesingle{}b0111\_00001}
&\tabularnewline\hline
指令类型 & \texttt{MOVZ} & \texttt{9\textquotesingle{}b1000\_00000}
&\tabularnewline\hline
指令类型 & \texttt{MULT} & \texttt{9\textquotesingle{}b1001\_00000}
&\tabularnewline\hline
指令类型 & \texttt{MULTU} & \texttt{9\textquotesingle{}b1001\_00001}
&\tabularnewline\hline
指令类型 & \texttt{DIV} & \texttt{9\textquotesingle{}b1001\_00010}
&\tabularnewline\hline
指令类型 & \texttt{DIVU} & \texttt{9\textquotesingle{}b1001\_00011}
&\tabularnewline\hline
指令类型 & \texttt{MFHI} & \texttt{9\textquotesingle{}b1010\_00000}
&\tabularnewline\hline
指令类型 & \texttt{MFLO} & \texttt{9\textquotesingle{}b1010\_00001}
&\tabularnewline\hline
指令类型 & \texttt{MTHI} & \texttt{9\textquotesingle{}b1011\_00000}
&\tabularnewline\hline
指令类型 & \texttt{MTLO} & \texttt{9\textquotesingle{}b1011\_00001}
&\tabularnewline\hline

\end{longtable}

\hypertarget{ux6ce8ux610f}{%
\subsection{注意}\label{ux6ce8ux610f}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  临时的数据通路类型都是从上往下长的。
\end{enumerate}

\hypertarget{ux63a7ux5236}{%
\section{控制}\label{ux63a7ux5236}}

\hypertarget{ux539fux7406-11}{%
\subsection{原理}\label{ux539fux7406-11}}

控制是指通过识别指令，控制数据的流通，从而让 CPU
执行指定的计算的过程。数据通路只是得到了数据可能的流向，真正要控制还是控制完成。控制通过已有的控制信号和数据通路的分叉完成控制。

在流水线 CPU
中，由于存在结构冒险和数据冒险，所以需要通过暂停和转发解决。暂停控制和转发控制可以放在单独的控制模块中，从而不影响原来单周期时的控制模块。但是，也可以通过改造控制模块的方式集成暂停和转发功能。通过指令识别系列函数（实际上综合时也会被综合成电路），可以分析指令，做到有效的暂停和转发。

\hypertarget{ux7aefux53e3ux5b9aux4e49-9}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-9}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & 输入 & 1 & 时钟信号\tabularnewline\hline
\texttt{rst} & 输入 & 1 & 同步复位信号\\\hline
\texttt{d\_instr} & 输入 & 32 & 当前在 D 级（ID）的指令\tabularnewline\hline
\texttt{rf\_read\_result1} & 输入 & 32 & \texttt{rf} 的 1 号读取结果\\\hline
\texttt{rf\_read\_result2} & 输入 & 32 & \texttt{rf} 的 2 号读取结果\tabularnewline\hline
\texttt{cw\_f\_pc\_enable} & 输出 & 1 & 控制 \texttt{pc}
使能\tabularnewline\hline
\texttt{cw\_d\_pff\_enable} & 输出 & 1 & 控制 D
级流水线寄存器使能\tabularnewline\hline
\texttt{cw\_e\_pff\_rst} & 输出 & 1 & 控制 E
级流水线寄存器复位\tabularnewline\hline
\texttt{cw\_f\_npc\_jump\_mode} & 输出 & 4 & 控制 \texttt{npc}
的跳转模式\tabularnewline\hline
\texttt{cw\_d\_ext\_mode} & 输出 & 3 & 控制
\texttt{D:\ ext.mode}\tabularnewline\hline
\texttt{cw\_d\_rf\_read\_addr1} & 输出 & 5 & 控制
\texttt{D:\ rf.read\_addr1}\tabularnewline\hline
\texttt{cw\_d\_rf\_read\_addr2} & 输出 & 5 & 控制
\texttt{D:\ rf.read\_addr2}\tabularnewline\hline
\texttt{cw\_e\_m\_alusrc} & 输出 & 1 & 控制
\texttt{E:\ m\_alu\_num2}\tabularnewline\hline
\texttt{cw\_e\_alu\_op} & 输出 & 5 & 控制
\texttt{E:\ alu.op}\tabularnewline\hline
\texttt{cw\_e\_md\_op} & 输出 & 3 & 控制
\texttt{E:\ md.op}\tabularnewline\hline
\texttt{cw\_m\_dm\_write\_enable} & 输出 & 1 & 控制
\texttt{M:\ dm.write\_enable}\tabularnewline\hline
\texttt{cw\_m\_dm\_mode} & 输出 & 1 & 控制
\texttt{M:\ dm.mode}\tabularnewline\hline
\texttt{cw\_w\_rf\_write\_enable} & 输出 & 1 & 控制
\texttt{W:\ rf.write\_enable}\tabularnewline\hline
\texttt{cw\_w\_m\_regdata} & 输出 & 3 & 控制
\texttt{W:\ m\_rf\_write\_data}\tabularnewline\hline
\texttt{cw\_w\_rf\_write\_addr} & 输出 & 5 & 控制
\texttt{W:\ rf.write\_addr}\tabularnewline\hline
\texttt{cw\_fm\_d{[}12{]}} & 输出 & 3 & 控制
\texttt{fm\_d{[}12{]}}\tabularnewline\hline
\texttt{cw\_fm\_e{[}12{]}} & 输出 & 3 & 控制
\texttt{fm\_e{[}12{]}}\tabularnewline\hline
\texttt{cw\_fm\_m} & 输出 & 3 & 控制 \texttt{fm\_w}\tabularnewline\hline

\end{longtable}

\hypertarget{ux603bux4f53ux7ed3ux6784}{%
\subsection{总体结构}\label{ux603bux4f53ux7ed3ux6784}}

控制模块是时序部件。不设置成组合逻辑部件的原因如下。

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  哪怕控制本身不设置成时序部件，也需要流水控制信号，这是流水线 CPU
  结构上的需要。
\item
  控制本身是时序部件，就可以流水更多的信息。最明显的就是指令读写寄存器的信息。比如暴力转发也把指令读写寄存器的信息放在流水线中流水。
\item
  保留单周期处理器的控制机制实际上过渡不是那么平滑，因为还有多周期处理器，它的控制是类似状态机的结构。
\end{enumerate}

控制模块在内部流水指令，从而做到比较有效的控制信号发射和数据冒险分析。负责控制信号发射的部分是纯组合逻辑，用函数实现。

同时，控制模块也在内部流水指令需要读取和写入的三个寄存器。因为流水线 CPU
和单周期 CPU
逻辑上应该一样，所以一条指令需要读取和写入的三个寄存器可以直接判断出来，并且流水。这样也可以更方便地处理数据冒险。

\hypertarget{ux6570ux636eux901aux8defux548cux529fux80fdux63a7ux5236ux4fe1ux53f7}{%
\subsection{数据通路和功能控制信号}\label{ux6570ux636eux901aux8defux548cux529fux80fdux63a7ux5236ux4fe1ux53f7}}

由于指令的数据通路可以分成几个类型，每种类型中需要的数据通路是一样的，只是某些控制信号不同。而且，流水线是分级的，所以每级控制数据通路形状的信号可以单独列表。

但是，不同的具体指令对不同部件的某些具体操作不同。比如 \texttt{CAL\_R}
类指令对 ALU
的具体操作就不同。因此，对这些控制具体操作的信号，需要单独列表。

通过对数据通路形状的分析，可以得到每种数据通路类型需要的控制信号如下。其中表格某一单元格的值有两种情况：若该单元格所在的行最左边的单元格是
MUX，则说明对应的指令需要让该 MUX
的输入端口接入该单元格表示的端口；若该单元格所在的行最左边的单元格是端口，则说明对应的指令需要的控制信号为该单元格表示的控制信号。

若单元格以 \texttt{\#}
开头，则说明该控制信号或端口只是为了使控制单元功能明晰而加上的，实际上并不需要关心该控制信号或要接入的端口的值。如果想理解该单元格的值，去掉
\texttt{\#} 再按照上一段理解即可。

\hypertarget{f-ux7ea7}{%
\paragraph{F 级}\label{f-ux7ea7}}

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcelllast{\texttt{F:\ npc.jump\_mode}}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{BRANCH} & 视具体指令而定\tabularnewline\hline
\texttt{JUMP\_I} & \texttt{NPC\_J}\tabularnewline\hline
\texttt{JUMP\_R} & \texttt{NPC\_REG}\tabularnewline\hline
（其它） & \texttt{NPC\_JUMP\_DISABLED}\tabularnewline\hline

\end{longtable}

\texttt{BRANCH} 类指令类型与 \texttt{F:\ npc.jump\_mode} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{指令类型} & \headingcelllast{\texttt{F:\ npc.jump\_mode}}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{BEQ} & \texttt{NPC\_EQUAL}\tabularnewline\hline
\texttt{BNE} & \texttt{NPC\_NOT\_EQUAL}\tabularnewline\hline
\texttt{BLEZ} & \texttt{NPC\_SIG\_SMALLER\_OR\_EQUAL}\tabularnewline\hline
\texttt{BGEZ} & \texttt{NPC\_SIG\_LARGER\_OR\_EQUAL}\tabularnewline\hline
\texttt{BLTZ} & \texttt{NPC\_SIG\_SMALLER}\tabularnewline\hline
\texttt{BGTZ} & \texttt{NPC\_SIG\_LARGER}\tabularnewline\hline

\end{longtable}

注意：\textbf{F 级的控制信号是由 D 级指令控制的。}

注意：\textbf{BRANCH 类指令要跟 0 比较的那些指令，是通过读 \texttt{\$0}
比较的，所以能直接进行大小比较。}

\hypertarget{d-ux7ea7id-1}{%
\paragraph{D 级（ID）}\label{d-ux7ea7id-1}}

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcelllast{\texttt{D:\ ext.mode}}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{CAL\_I} & 视具体指令而定\tabularnewline\hline
\texttt{LOAD} & \texttt{EXT\_MODE\_SIGNED}\tabularnewline\hline
\texttt{STORE} & \texttt{EXT\_MODE\_SIGNED}\tabularnewline\hline
（其它） & \texttt{\#EXT\_MODE\_SIGNED}\tabularnewline\hline

\end{longtable}

\texttt{CAL\_I} 类指令类型与 \texttt{D:\ ext.mode} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{指令类型} & \headingcelllast{\texttt{D:\ ext.mode}}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{LUI} & \texttt{EXT\_PAD}\tabularnewline\hline
\texttt{ORI} & \texttt{EXT\_UNSIGNED}\tabularnewline\hline
\texttt{ADDI} & \texttt{EXT\_SIGNED}\tabularnewline\hline
\texttt{ADDIU} & \texttt{EXT\_SIGNED}\tabularnewline\hline
\texttt{ANDI} & \texttt{EXT\_UNSIGNED}\tabularnewline\hline
\texttt{XORI} & \texttt{EXT\_UNSIGNED}\tabularnewline\hline
\texttt{SLTI} & \texttt{EXT\_SIGNED}\tabularnewline\hline
\texttt{SLTIU} & \texttt{EXT\_SIGNED}\tabularnewline\hline

\end{longtable}

注意：\textbf{\texttt{SLTIU}
扩展立即数的时候确实是按照有符号扩展的，但比较是按照无符号数比较，可以查指令手册。}

\hypertarget{e-ux7ea7ex-1}{%
\paragraph{E 级（EX）}\label{e-ux7ea7ex-1}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcellmiddle{\texttt{E:\ m\_alusrc}} & \headingcellmiddle{\texttt{E:\ alu.op}} & \headingcelllast{\texttt{E:\ md.op}}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{CAL\_R} & \texttt{D:\ rf.read\_result2} & 视具体指令而定 &
\texttt{MD\_NONE}\tabularnewline\hline
\texttt{CAL\_I} & \texttt{D:\ ext.result} & 视具体指令而定 &
\texttt{MD\_NONE}\tabularnewline\hline
\texttt{LOAD} & \texttt{D:\ ext.result} & \texttt{ALU\_ADD} &
\texttt{MD\_NONE}\tabularnewline\hline
\texttt{STORE} & \texttt{D:\ ext.result} & \texttt{ALU\_ADD} &
\texttt{MD\_NONE}\tabularnewline\hline
\texttt{BRANCH} & \texttt{D:\ rf.read\_result2} & \texttt{\#ALU\_OR} &
\texttt{MD\_NONE}\tabularnewline\hline
\texttt{CMOV} & \texttt{D:\ rf.read\_result2} & 视具体指令而定 &
\texttt{MD\_NONE}\tabularnewline\hline
\texttt{CAL\_M} & \texttt{\#D:\ rf.read\_result2} & \texttt{\#ALU\_OR} &
视具体指令而定\tabularnewline\hline
\texttt{LOAD\_M} & \texttt{\#D:\ rf.read\_result2} & \texttt{\#ALU\_OR}
& 视具体指令而定\tabularnewline\hline
\texttt{STORE\_M} & \texttt{\#D:\ rf.read\_result2} & \texttt{\#ALU\_OR}
& 视具体指令而定\tabularnewline\hline
（其它） & \texttt{\#D:\ rf.read\_result2} & \texttt{\#ALU\_OR} &
\texttt{MD\_NONE}\tabularnewline\hline

\end{longtable}

\texttt{CAL\_R} 类指令类型与 \texttt{E:\ alu.op} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{指令类型} & \headingcelllast{\texttt{E:\ alu.op}}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{ADDU} & \texttt{ALU\_ADD}\tabularnewline\hline
\texttt{SUBU} & \texttt{ALU\_SUB}\tabularnewline\hline
\texttt{ADD} & \texttt{ALU\_ADD}\tabularnewline\hline
\texttt{SUB} & \texttt{ALU\_SUB}\tabularnewline\hline
\texttt{AND} & \texttt{ALU\_AND}\tabularnewline\hline
\texttt{OR} & \texttt{ALU\_OR}\tabularnewline\hline
\texttt{NOR} & \texttt{ALU\_NOR}\tabularnewline\hline
\texttt{XOR} & \texttt{ALU\_XOR}\tabularnewline\hline
\texttt{SLT} & \texttt{ALU\_SLT}\tabularnewline\hline
\texttt{SLTU} & \texttt{ALU\_SLTU}\tabularnewline\hline
\texttt{SLL} & \texttt{ALU\_SLL}\tabularnewline\hline
\texttt{SRL} & \texttt{ALU\_SRL}\tabularnewline\hline
\texttt{SRA} & \texttt{ALU\_SRA}\tabularnewline\hline
\texttt{SLLV} & \texttt{ALU\_SLLV}\tabularnewline\hline
\texttt{SRLV} & \texttt{ALU\_SRLV}\tabularnewline\hline
\texttt{SRAV} & \texttt{ALU\_SRAV}\tabularnewline\hline

\end{longtable}

\texttt{CAL\_I} 类指令类型与 \texttt{E:\ alu.op} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{指令类型} & \headingcelllast{\texttt{E:\ alu.op}}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{LUI} & \texttt{ALU\_OR}\tabularnewline\hline
\texttt{ORI} & \texttt{ALU\_OR}\tabularnewline\hline
\texttt{ADDI} & \texttt{ALU\_ADD}\tabularnewline\hline
\texttt{ADDIU} & \texttt{ALU\_ADD}\tabularnewline\hline
\texttt{ANDI} & \texttt{ALU\_AND}\tabularnewline\hline
\texttt{XORI} & \texttt{ALU\_XOR}\tabularnewline\hline
\texttt{SLTI} & \texttt{ALU\_SLT}\tabularnewline\hline
\texttt{SLTIU} & \texttt{ALU\_SLTU}\tabularnewline\hline

\end{longtable}

\texttt{CMOV} 类指令类型与 \texttt{E:\ alu.op} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{指令类型} & \headingcelllast{\texttt{E:\ alu.op}}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{MOVZ} & \texttt{ALU\_MOVZ}\tabularnewline\hline

\end{longtable}

\texttt{CAL\_M} 类指令类型与 \texttt{E:\ md.op} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{指令类型} & \headingcelllast{E: md.op}\tabularnewline\hline
\endhead\hiderowcolors
\texttt{MULT} & \texttt{MD\_MULT}\tabularnewline\hline
\texttt{MULTU} & \texttt{MD\_MULTU}\tabularnewline\hline
\texttt{DIV} & \texttt{MD\_DIV}\tabularnewline\hline
\texttt{DIVU} & \texttt{MD\_DIVU}\tabularnewline\hline

\end{longtable}

\texttt{LOAD\_M} 类指令类型与 \texttt{E:\ md.op} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{指令类型} & \headingcelllast{\texttt{E:\ md.op}}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{MFHI} & \texttt{MD\_MFHI}\tabularnewline\hline
\texttt{MFLO} & \texttt{MD\_MFLO}\tabularnewline\hline

\end{longtable}

\texttt{STORE\_M} 类指令类型与 \texttt{E:\ md.op} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{指令类型} & \headingcelllast{\texttt{E:\ md.op}}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{MTHI} & \texttt{MD\_MTHI}\tabularnewline\hline
\texttt{MTLO} & \texttt{MD\_MTLO}\tabularnewline\hline

\end{longtable}

\hypertarget{m-ux7ea7mem-1}{%
\paragraph{M 级（MEM）}\label{m-ux7ea7mem-1}}

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcellmiddle{\texttt{M:\ dm.write\_enable}} &
\headingcelllast{\texttt{M:\ dm.mode}}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{LOAD} & 1'b0 & 视具体指令而定\tabularnewline\hline
\texttt{STORE} & \texttt{1\textquotesingle{}b1} &
视具体指令而定\tabularnewline\hline
（其它） & \texttt{1\textquotesingle{}b0} &
\texttt{DM\_NONE}\tabularnewline\hline

\end{longtable}

\texttt{LOAD} 类指令类型与 \texttt{M:\ dm.mode} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{指令类型} & \headingcelllast{\texttt{M:\ dm.mode}}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{LW} & \texttt{DM\_W}\tabularnewline\hline
\texttt{LH} & \texttt{DM\_H}\tabularnewline\hline
\texttt{LHU} & \texttt{DM\_HU}\tabularnewline\hline
\texttt{LB} & \texttt{DM\_B}\tabularnewline\hline
\texttt{LBU} & \texttt{DM\_BU}\tabularnewline\hline

\end{longtable}

\texttt{STORE} 类指令类型与 \texttt{M:\ dm.mode} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{指令类型} & \headingcelllast{\texttt{M:\ dm.mode}}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{SW} & \texttt{DM\_W}\tabularnewline\hline
\texttt{SH} & \texttt{DM\_H}\tabularnewline\hline
\texttt{SB} & \texttt{DM\_B}\tabularnewline\hline

\end{longtable}

\hypertarget{w-ux7ea7wb-1}{%
\paragraph{W 级（WB）}\label{w-ux7ea7wb-1}}

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcellmiddle{\texttt{W:\ rf.write\_enable}} & \headingcelllast{\texttt{W:\ m\_regdata}}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{CAL\_R} & \texttt{1\textquotesingle{}b1} &
\texttt{E:\ alu.result}\tabularnewline\hline
\texttt{CAL\_I} & \texttt{1\textquotesingle{}b1} &
\texttt{E:\ alu.result}\tabularnewline\hline
\texttt{LOAD} & \texttt{1\textquotesingle{}b1} &
\texttt{E:\ dm.read\_result}\tabularnewline\hline
\texttt{JUMP\_I} & \texttt{1\textquotesingle{}b1} &
\texttt{D:\ npc.next\_pc}\tabularnewline\hline
\texttt{JUMP\_R} & \texttt{1\textquotesingle{}b1} &
\texttt{D:\ npc.next\_pc}\tabularnewline\hline
\texttt{CMOV} & \texttt{1\textquotesingle{}b1} &
\texttt{E:\ alu.result}\tabularnewline\hline
\texttt{LOAD\_M} & 1'b1 & \texttt{E:\ md.out}\tabularnewline\hline
（其它） & \texttt{1\textquotesingle{}b0} &
\texttt{\#E:\ alu.result}\tabularnewline\hline

\end{longtable}

\hypertarget{ux6d41ux6c34ux7684ux5185ux5bb9}{%
\paragraph{流水的内容}\label{ux6d41ux6c34ux7684ux5185ux5bb9}}

流水 E 级、M 级、W 级指令及其要读的两个寄存器和要写的一个寄存器。不流水
D 级指令是为了配合暂停机制，D 级一被暂停，D
级指令只在组合逻辑跟着变化，不需要再在控制模块里改变 D 级指令的值。

\hypertarget{ux6307ux4ee4ux8bfbux5199ux5bc4ux5b58ux5668ux8bc6ux522b}{%
\paragraph{指令读写寄存器识别}\label{ux6307ux4ee4ux8bfbux5199ux5bc4ux5b58ux5668ux8bc6ux522b}}

比较显然的一点是数据通路类型决定指令要读写的寄存器号。所以，可以直接用取指令字段的宏来完成。

数据通路类型和指令读写寄存器的关系如下。如果指令不读写哪个寄存器，就用
\texttt{ZERO} 替换，因为 \texttt{ZERO}
不参与转发。这样，对转发正确性也没有影响。其中使用的获取指令字段的宏隐含着用要分析的指令作为参数。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcellmiddle{\texttt{reg1}} & \headingcellmiddle{\texttt{reg2}} & \headingcelllast{\texttt{regw}}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{CAL\_R} & \texttt{RS} & \texttt{RT} & \texttt{RD}\tabularnewline\hline
\texttt{CAL\_I} & \texttt{RS} & \texttt{RT} & \texttt{RT}\tabularnewline\hline
\texttt{LOAD} & \texttt{RS} & \texttt{ZERO} & \texttt{RT}\tabularnewline\hline
\texttt{STORE} & \texttt{RS} & \texttt{RT} &
\texttt{ZERO}\tabularnewline\hline
\texttt{BRANCH} & \texttt{RS} & 视指令类型而定（{[}4{]}） &
\texttt{ZERO}\tabularnewline\hline
\texttt{JUMP\_I} & \texttt{ZERO} & \texttt{ZERO} &
视指令而定（{[}2{]}）\tabularnewline\hline
\texttt{JUMP\_R} & \texttt{RS} & \texttt{ZERO} &
视指令而定（{[}3{]}）\tabularnewline\hline
\texttt{CMOV} & \texttt{RS} & \texttt{RT} &
视寄存器值而定（{[}1{]}）\tabularnewline\hline
\texttt{CAL\_M} & \texttt{RS} & \texttt{RT} &
\texttt{ZERO}\tabularnewline\hline
\texttt{LOAD\_M} & \texttt{ZERO} & \texttt{ZERO} &
\texttt{RD}\tabularnewline\hline
\texttt{STORE\_M} & \texttt{RS} & \texttt{ZERO} &
\texttt{ZERO}\tabularnewline\hline
（其它） & \texttt{ZERO} & \texttt{ZERO} & \texttt{ZERO}\tabularnewline\hline

\end{longtable}

注：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  有一点就是 \texttt{CMOV}
  类指令。这类指令的一种实现是无条件把要写入的数据看成是 \texttt{\$rs}
  的值，但是\textbf{改变要写入的寄存器号}。如果
  \texttt{\$rt\ ==\ 32\textquotesingle{}b0}，就写入
  \texttt{\$rd}，否则写入
  \texttt{\$0\ /\ ZERO}。这样，加上把要读写的寄存器号流水的机制，能保证
  \texttt{CMOV} 类指令的数据冒险处理不出错。哪怕在 W 级打开了
  \texttt{rf} 的写使能，写入 \texttt{\$0} 也没有影响。
\item
  \texttt{JUMP} 类指令若为 \texttt{jal}，则 \texttt{regw\ ==\ RA}。若为
  \texttt{j}，则 \texttt{regw\ ==\ ZERO}。
\item
  \texttt{JUMP\_R} 类指令若为 \texttt{jr}，则
  \texttt{regw\ ==\ ZERO}。若为 \texttt{jalr}，则
  \texttt{regw\ ==\ RD}。由于 \texttt{jr} 指令 \texttt{RS} 字段永远为
  0，所以这样分析是正确的。
\item
  \texttt{BRANCH} 类指令若为 \texttt{beq} 或 \texttt{bne}，则
  \texttt{reg2\ ==\ RT}。若为 \texttt{blez,\ bgez,\ bltz,\ bgtz}，则
  \texttt{reg2\ ==\ ZERO}。由于这样会让 \texttt{cmp}
  的比较结果变成对应寄存器与 0
  的比较，符合指令功能描述，所以这样分析是正确的。
\end{enumerate}

\hypertarget{ux8f6cux53d1ux63a7ux5236ux4fe1ux53f7}{%
\subsection{转发控制信号}\label{ux8f6cux53d1ux63a7ux5236ux4fe1ux53f7}}

由于流水线 CPU
中存在数据冒险，所以需要转发。由于有了指令识别函数，所以转发是非常抽象的，只需要判断涉及的寄存器号。而且只有两个级是转发的接收端（数据的需求者），因此可以在某一级的角度，一级一级往后排查。

注意：\textbf{先检查较新级的数据冒险，再检查较老级的，因为 \texttt{rf}
中的内容最终还是较新级的。}

对 D 级，先检查 E 级，再检查 M 级，再检查 W 级。对 E 级的寄存器，先检查
M 级，再检查 W 级。这样就能保证转发的完整性。

转发控制信号最终需要控制的是转发 MUX，因此转发 MUX 也要进行定义。

下表是所有转发的情况和具体的描述。意义中说的数据通路类型，都是源指令的数据通路类型。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
所有转发 MUX & \texttt{orig} & \texttt{0} &
不转发，保持原样\tabularnewline\hline
\texttt{fm\_d{[}12{]}} & \texttt{E2D\_rf} & \texttt{1} & \makecell{E 级到 D 级，数据通路类型是 \texttt{CMOV}，\\要写入的数据在 D 级产生好了，\\到了 E
级才能转发}\tabularnewline\hline
\texttt{fm\_d{[}12{]}} & \texttt{E2D\_npc} & \texttt{2} & \makecell{E 级到 D 级，数据通路类型是 \texttt{JUMP\_I\ /\ JUMP\_R}，\\要写入的数据在 D
级产生好了，\\到了 E 级才能转发}\tabularnewline\hline
\texttt{fm\_d{[}12{]}} & \texttt{M2D\_npc} & \texttt{3} & \makecell{M 级到 D
级，之后同上}\tabularnewline\hline
\texttt{fm\_d{[}12{]}} & \texttt{M2D\_alu} & \texttt{4} & \makecell{M 级到 D 级，\\数据通路类型是 \texttt{CAL\_R\ /\ CAL\_I\ /\ CMOV}，\\数据在 D 级或 E
级产生好了，\\但对 \texttt{CAL\_R\ /\ CAL\_I} 来说，到了 M 级才能转发}\tabularnewline\hline
\texttt{fm\_d{[}12{]}} & \texttt{W2D\_rf} & \texttt{5} & \makecell{W 级到 D
级，数据通路类型是\\所有能够写入寄存器的类型，\\数据在 W
级都可以转发了}\tabularnewline\hline
\texttt{fm\_d{[}12{]}} & \texttt{M2D\_md} & \texttt{6} & \makecell{M 级到 D 级，数据通路类型是 \\\texttt{LOAD\_M}，\\数据在 E 级产生好了}\tabularnewline\hline
\texttt{fm\_d{[}12{]}} & \texttt{E2D\_md} & \texttt{7} & \makecell{E 级到 D 级，\\数据通路类型是 \texttt{LOAD\_M}，\\数据在 E 级产生好了}\tabularnewline\hline
\texttt{fm\_e{[}12{]}} & \texttt{M2E\_npc} & \texttt{1} & \makecell{M 级到 E
级，\\数据通路类型是 \texttt{JUMP\_I\ /\ JUMP\_R}，\\要写入的数据在 D
级产生好了，\\到了 E 级才能转发}\tabularnewline\hline
\texttt{fm\_e{[}12{]}} & \texttt{M2E\_alu} & \texttt{2} & \makecell{M 级到 E 级，\\数据通路类型是 \texttt{CAL\_R\ /\ CAL\_I\ /\ CMOV}，\\数据在 D 级或 E 级产生好了，\\但对 \texttt{CAL\_R\ /\ CAL\_I} 来说，\\到了 M 级才能转发}\tabularnewline\hline
\texttt{fm\_e{[}12{]}} & \texttt{W2E\_rf} & \texttt{3} & \makecell{W 级到 D 级，\\数据通路类型是所有能够写入寄存器的类型，\\数据在 W 级都可以转发了}\tabularnewline\hline
\texttt{fm\_e{[}12{]}} & \texttt{M2E\_md} & \texttt{4} & \makecell{M 级到 D 级，\\数据通路类型为 \texttt{LOAD\_M}，\\数据在 E 级产生好了}\tabularnewline\hline
\texttt{fm\_m} & \texttt{W2M\_rf} & \texttt{1} & \makecell{W 级到 M 级，\\数据通路类型是所有能够写入寄存器的类型，\\数据在 W 级都可以转发了\\（比如 \texttt{sw} 指令转发 \texttt{rf} 内容）}\tabularnewline\hline

\end{longtable}

注意：\textbf{\texttt{B2A\_.*} 表示 B 级从 A 级转发。}

注意：\textbf{宏的值要和对应转发 MUX 的接线顺序相符。}

注意：\textbf{\texttt{E2D\_rf} 表示把 E 级的第一个寄存器转发出去，因为用到这条指令的是 \texttt{CMOV} 类指令。}

注意：\textbf{\texttt{fm\_m}
检查的是要读取的第二个寄存器，因为现在用到的所有写入内存的指令，要写入内存的数据都与相应指令第二个寄存器的读取结果对应。以后甚至可能加上检查要读取的第一个寄存器，不过就要根据指令类型判断了。}

\hypertarget{ux6682ux505cux63a7ux5236ux4fe1ux53f7}{%
\subsection{暂停控制信号}\label{ux6682ux505cux63a7ux5236ux4fe1ux53f7}}

由于流水线中有些数据冒险通过转发解决不了，所以需要暂停机制。暂停机制的前提是产生数据冒险。暂停机制是通过
Tuse 和 Tnew 机制实现的。

Tuse 是指指令到 D 级以后还剩最晚多少时间就需要新值。Tnew
是指指令还需要多长时间才能开始转发。因此只要 Tuse \textless{}
Tnew，就需要暂停，因为在流水线中如果没有暂停，两条指令的相对位置是不变的，如果不暂停，就不能解决数据冒险。

数据冒险可以只在 D 级检测和在 E 级解决，因为在 E 级插入气泡，就可以保证
Tuse 和 Tnew 最终回回归正常。

插入气泡是通过锁定 \texttt{pc} 和清空 E
级各个流水线寄存器实现的。但是，控制内部的流水线也要插入气泡。

暂停要分两个寄存器，因为数据冒险也是要分成两个寄存器的情况的。

注意：\textbf{Tnew
的计算是要看能够开始转发的时间，而不是生成好要转发数据的时间，因为不是所有转发路径都是可能的。}

注意：\textbf{控制内部的流水线也要插入气泡。}

在 D 级各种数据通路类型的 Tuse 如下。

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcellmiddle{Tuse (read\_addr1)} & \headingcelllast{Tuse (read\_addr2)}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{UNKNOWN} & &\tabularnewline\hline
\texttt{CAL\_R} & 1 & 1\tabularnewline\hline
\texttt{CAL\_I} & 1 & 1\tabularnewline\hline
\texttt{LOAD} & 1 &\tabularnewline\hline
\texttt{STORE} & 1 & 2\tabularnewline\hline
\texttt{BRANCH} & 0 & 0\tabularnewline\hline
\texttt{JUMP\_I} & &\tabularnewline\hline
\texttt{JUMP\_R} & 0 &\tabularnewline\hline
\texttt{CMOV} & 0 & 0\tabularnewline\hline
\texttt{CAL\_M} & 1 & 1\tabularnewline\hline
\texttt{LOAD\_M} & &\tabularnewline\hline
\texttt{STORE\_M} & 1 & 1\tabularnewline\hline

\end{longtable}

在 E 级和 M 级各种数据通路类型的 Tnew 如下。忽略 W 级，因为所有指令到 W
级时都可以马上转发数据。

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcellmiddle{Tnew (E)} & \headingcelllast{Tnew (M)}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{UNKNOWN} & &\tabularnewline\hline
\texttt{CAL\_R} & 1 & 0\tabularnewline\hline
\texttt{CAL\_I} & 1 & 0\tabularnewline\hline
\texttt{LOAD} & 2 & 1\tabularnewline\hline
\texttt{STORE} & &\tabularnewline\hline
\texttt{BRANCH} & &\tabularnewline\hline
\texttt{JUMP\_I} & 0 & 0\tabularnewline\hline
\texttt{JUMP\_R} & 0 & 0\tabularnewline\hline
\texttt{CMOV} & 0 & 0\tabularnewline\hline
\texttt{NOP} & &\tabularnewline\hline
\texttt{CAL\_M} & &\tabularnewline\hline
\texttt{LOAD\_M} & 0 & 0\tabularnewline\hline
\texttt{STORE\_M} & &\tabularnewline\hline

\end{longtable}

以上列表中 Tuse 没有列出的，是因为它没有意义，认为 Tuse 足够大。Tnew
同理，认为 Tnew 为 0。

这样，只要算出每个阶段的 Tuse 和
Tnew，并且保证发生数据冒险时对两个寄存器，Tuse \textgreater{}=
Tnew，就能控制暂停和转发。当且仅当 \texttt{t\_use\_reg{[}12{]}} 小于
\texttt{t\_new\_{[}em{]}} 中的任何一个时，需要暂停。

\texttt{md.busy\ ==\ 1\textquotesingle{}b1} 时，会一直插入气泡，直到
\texttt{md.busy\ ==\ 1\textquotesingle{}b0}。而且，\texttt{CAL\_M}
类指令虽然进行计算，但不写普通寄存器，所以跟其它指令没有转发解决不了的数据冒险，所以不停地插入气泡这种方式是可以解决数据冒险的。而且，跟
\texttt{dm} 类似，\texttt{md} 的 \texttt{HI} 和 \texttt{LO}
寄存器也没有数据冒险。因此，乘除法相关指令和其它指令之间，可以看成解决了需要暂停的问题，虽然
\texttt{md} 需要多个周期运行。

注意：\textbf{比较 Tuse 和 Tnew 应该用无符号比较，避免数值最高位是 1
时被看成负数。}

\hypertarget{ux5bc4ux5b58ux5668ux5730ux5740ux63a7ux5236ux4fe1ux53f7}{%
\subsection{寄存器地址控制信号}\label{ux5bc4ux5b58ux5668ux5730ux5740ux63a7ux5236ux4fe1ux53f7}}

由于已经有指令识别机制了，所以寄存器的地址控制可以简化。只需要在 D 级和 M 级的三个地址端口输入指令识别机制相应的结果即可。

\section{转发控制模块}

\subsection{原理}

转发控制模块是流水线 CPU 控制机制的一部分，通过评估各指令读写寄存器的情况，实现有效的尽力转发。

\subsection{端口定义}

\begin{longtable}[]{@{}|l|l|l|l|}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能} \tabularnewline\hline
\endhead\hiderowcolors
\texttt{ddptype} & 输入 & 9 & D 级指令类型 \tabularnewline\hline
\texttt{dreg1} & 输入 & 5 & D 级指令与 \texttt{rf.read\_addr1} 对应的寄存器号 \tabularnewline\hline
\texttt{dreg2} & 输入 & 5 & D 级指令与 \texttt{rf.read\_addr2} 对应的寄存器号 \tabularnewline\hline
\texttt{dregw} & 输入 & 5 & D 级指令与 \texttt{rf.write\_addr} 对应的寄存器号 \tabularnewline\hline
\texttt{edptype} & 输入 & 9 & E 级指令类型 \tabularnewline\hline
\texttt{ereg1} & 输入 & 5 & E 级指令与 \texttt{rf.read\_addr1} 对应的寄存器号 \tabularnewline\hline
\texttt{ereg2} & 输入 & 5 & E 级指令与 \texttt{rf.read\_addr2} 对应的寄存器号 \tabularnewline\hline
\texttt{eregw} & 输入 & 5 & E 级指令与 \texttt{rf.write\_addr} 对应的寄存器号 \tabularnewline\hline
\texttt{mdptype} & 输入 & 9 & M 级指令类型 \tabularnewline\hline
\texttt{mreg1} & 输入 & 5 & M 级指令与 \texttt{rf.read\_addr1} 对应的寄存器号 \tabularnewline\hline
\texttt{mreg2} & 输入 & 5 & M 级指令与 \texttt{rf.read\_addr2} 对应的寄存器号 \tabularnewline\hline
\texttt{mregw} & 输入 & 5 & M 级指令与 \texttt{rf.write\_addr} 对应的寄存器号 \tabularnewline\hline
\texttt{wdptype} & 输入 & 9 & W 级指令类型 \tabularnewline\hline
\texttt{wreg1} & 输入 & 5 & W 级指令与 \texttt{rf.read\_addr1} 对应的寄存器号 \tabularnewline\hline
\texttt{wreg2} & 输入 & 5 & W 级指令与 \texttt{rf.read\_addr2} 对应的寄存器号 \tabularnewline\hline
\texttt{wregw} & 输入 & 5 & W 级指令与 \texttt{rf.write\_addr} 对应的寄存器号 \tabularnewline\hline
\texttt{cw\_fm\_[de][12]} & 输出 & 4 & D / E 级与 \texttt{rf.read\_addr[12]} 对应的转发 MUX \tabularnewline\hline
\texttt{cw\_fm\_m} & 输出 & 4 & M 级与 \texttt{rf.read\_addr2} 对应的转发 MUX \tabularnewline\hline
\end{longtable}

\subsection{宏定义}

暂无。

\subsection{功能}

见控制中的对应节。

\section{暂停控制模块}

\subsection{原理}

暂停控制模块是流水线 CPU 控制机制的一部分，通过评估 $ T_{use} $ 和 $ T_{new} $ 实现尽量少的暂停。它是控制模块内部的一部分。

\subsection{端口定义}

\begin{longtable}[]{@{}|l|l|l|l|}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能} \tabularnewline\hline
\endhead\hiderowcolors
\texttt{ddptype} & 输入 & 9 & D 级指令类型 \tabularnewline\hline
\texttt{dreg1} & 输入 & 5 & D 级指令与 \texttt{rf.read\_addr1} 对应的寄存器号 \tabularnewline\hline
\texttt{dreg2} & 输入 & 5 & D 级指令与 \texttt{rf.read\_addr2} 对应的寄存器号 \tabularnewline\hline
\texttt{dregw} & 输入 & 5 & D 级指令与 \texttt{rf.write\_addr} 对应的寄存器号 \tabularnewline\hline
\texttt{edptype} & 输入 & 9 & E 级指令类型 \tabularnewline\hline
\texttt{ereg1} & 输入 & 5 & E 级指令与 \texttt{rf.read\_addr1} 对应的寄存器号 \tabularnewline\hline
\texttt{ereg2} & 输入 & 5 & E 级指令与 \texttt{rf.read\_addr2} 对应的寄存器号 \tabularnewline\hline
\texttt{eregw} & 输入 & 5 & E 级指令与 \texttt{rf.write\_addr} 对应的寄存器号 \tabularnewline\hline
\texttt{mdptype} & 输入 & 9 & M 级指令类型 \tabularnewline\hline
\texttt{mreg1} & 输入 & 5 & M 级指令与 \texttt{rf.read\_addr1} 对应的寄存器号 \tabularnewline\hline
\texttt{mreg2} & 输入 & 5 & M 级指令与 \texttt{rf.read\_addr2} 对应的寄存器号 \tabularnewline\hline
\texttt{mregw} & 输入 & 5 & M 级指令与 \texttt{rf.write\_addr} 对应的寄存器号 \tabularnewline\hline
\texttt{wdptype} & 输入 & 9 & W 级指令类型 \tabularnewline\hline
\texttt{wreg1} & 输入 & 5 & W 级指令与 \texttt{rf.read\_addr1} 对应的寄存器号 \tabularnewline\hline
\texttt{wreg2} & 输入 & 5 & W 级指令与 \texttt{rf.read\_addr2} 对应的寄存器号 \tabularnewline\hline
\texttt{wregw} & 输入 & 5 & W 级指令与 \texttt{rf.write\_addr} 对应的寄存器号 \tabularnewline\hline
\texttt{stall} & 输出 & 1 & 是否需要暂停 \tabularnewline\hline
\end{longtable}

\subsection{宏定义}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义} \tabularnewline\hline
\endhead\hiderowcolors
$ T_{use} $ 或 $ T_{new} $ 的值 & \texttt{inf} & 3'd7 & 值为概念上的无穷大时，实际的值 \tabularnewline\hline
\end{longtable}

\subsection{功能}

见控制中的对应节。

\hypertarget{cpu}{%
\section{CPU}\label{cpu}}

\hypertarget{ux539fux7406-12}{%
\subsection{原理}\label{ux539fux7406-12}}

CPU 是宏观部件，主要连接起数据通路和控制。该部件主要起的是宏观功能，也就是读取指令并完成计算。

CPU 在模块结构中作为顶层模块而存在。

\hypertarget{ux7aefux53e3ux5b9aux4e49-10}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-10}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & 输入 & 1 & 时钟信号\tabularnewline\hline
\texttt{rst} & 输入 & 1 & 同步复位信号 \\\hline

\end{longtable}

\hypertarget{ux63a5ux7ebf}{%
\subsection{接线}\label{ux63a5ux7ebf}}

按照数据通路和控制部分的定义进行接线。数据通路中的接线方式在数据通路部分的文档中描述，控制部分按照控制部分的文档中描述。控制部分控制数据通路的哪部分，在控制部分的文档中。

\hypertarget{ux529fux80fd-14}{%
\subsection{功能}\label{ux529fux80fd-14}}

CPU 需要的外部数据输入是极少的，只有时钟信号、必要的其它信号和指令文件。

\section{思考题}

\subsection{乘除法部件}

\begin{enumerate}
\item 因为乘除法运算比较复杂，通常需要多个周期；而 ALU 对应的运算通常需要一个周期。让乘除法器成为独立模块，可以让非乘除法指令在乘除法器使用时，仍然进行运算，更好地利用硬件的并行性。有单独的 HI 和 LO 寄存器，是因为乘除法器模块相对独立，如果使用通用寄存器保留计算结果，保存的时间难以确定，容易跟不使用乘除法器的指令冲突。而且，有了这两个寄存器，也方便保存和恢复现场。
\item 延迟槽是分支指令起作用前，需要一个周期决定下一个 PC，因此在它后面紧接着插入一条无关的非分支指令，插入的地方叫做延迟槽。所以类似地，乘除槽是乘除指令算出结果前，需要一定的周期数，因此在它后面紧接着插入不对乘除法器进行操作的指令，插入的地方叫做乘除槽。乘除槽的长度跟乘除法指令算出结果以前需要的周期数有关。
\end{enumerate}

\subsection{扩展 DM}

\begin{enumerate}
\item 只需要读取或者写入一个字节的情况。比如读取 C 语言字符串中的一个字节，用字节操作指令可以直接读出这个字节，并且把这个字节放到对应寄存器的最低 8 位；但是用读出一个字的指令，还需要处理才能做到这个效果。
\end{enumerate}

\subsection{复杂性控制与设计风格}

\begin{enumerate}
\item 使用 A/T 编码器的侦测者风格。采用的抽象与规范手段如下。
\begin{itemize}
 \item 统一的命名规则
 \item 一致的代码风格
 \item 强制基于名称的端口连线
 \item 所有连线必须显式声明
 \item 代码中体现流水线分级
 \item 部分常见功能的抽象
 \item 暂停和转发分开处理
 \item A/T 编码器
 \item 指令按数据通路类型分类
 \item 数据通路和控制严格分开
\end{itemize}
\end{enumerate}

\subsection{在线测试相关说明}

\begin{enumerate}
\item 遇到了很多种不同指令类型产生的冲突。采用侦测者方法解决的。测试样例有很多种。

主要采用手动构造 + 完全随机生成的方法。

手动构造针对正确性构造，主要保证正确性；完全随机生成针对广泛性构造，保证覆盖性。考虑过采用特殊策略，采用模板结合随机性，从而达到强测的效果。
\end{enumerate}

\subsection{测试}

\begin{enumerate}
\item 
\end{enumerate}


\hypertarget{ux6280ux5de7}{%
\section{技巧}\label{ux6280ux5de7}}

\hypertarget{ux614cux4e86ux600eux4e48ux529e}{%
\subsection{慌了怎么办}\label{ux614cux4e86ux600eux4e48ux529e}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Don't panic! 做出来是最重要的
\item
  深呼吸，专心想实现和调试的事情，不要害怕干不出来
\item
  看看哪里的逻辑出错了，\textbf{不要逃避！}
\item
  用小数据、边界数据、特殊数据测试
\item
  踏踏实实想逻辑、定义、算法，必要的时候自己再描述一遍 /
  写一遍，不要根据原来做出来的
\end{enumerate}

\hypertarget{ux5982ux4f55ux52a0ux65b0ux6307ux4ee4}{%
\subsection{如何加新指令}\label{ux5982ux4f55ux52a0ux65b0ux6307ux4ee4}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  看好 RTL，把它转换成数据通路的连线
\end{enumerate}

\begin{itemize}
\tightlist
\item
  注意流水线分级
\item
  可能需要引入新的流水线寄存器
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  如果有多对一的情况，就应该用 MUX
\end{enumerate}

\begin{itemize}
\tightlist
\item
  MUX 是原来的值，改控制信号
\item
  MUX 是新的值，改控制信号，\textbf{可能要改 MUX 的位宽和对应接线的位宽}
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  改好控制信号
\end{enumerate}

\begin{itemize}
\tightlist
\item
  对指令域进行识别

  \begin{itemize}
  \tightlist
  \item
    尽量把新指令归约到原来的 \texttt{dptype} 上，\textbf{可以使用
    \texttt{\$0}，也可以利用其它特殊寄存器，毕竟控制模块里对读写寄存器的指定是
    arbitrary 的}
  \end{itemize}
\item
  如果需要一个新的 \texttt{dptype}

  \begin{itemize}
  \tightlist
  \item
    计算好控制信号
  \item
    计算好 Tuse 和 Tnew
  \item
    看好如何转发、是否需要改转发路径
  \end{itemize}
\item
  如果需要改转发路径

  \begin{itemize}
  \tightlist
  \item
    确定转发的源和目的
  \item
    \textbf{注意数据通路里的转发 MUX 和控制单元里的控制信号需要同时改}
  \end{itemize}
\item
  如果有新的跳转规则

  \begin{itemize}
  \tightlist
  \item
    尽量改 \texttt{npc}，让 \texttt{npc} 基于比较结果判断
  \item
    如果引入了新的比较方式，就需要改 \texttt{cmp}，\textbf{注意有符号 /
    无符号和运算溢出问题和改 \texttt{cmp} 的接口}，同时也要改数据通路和
    \texttt{npc} 的接口
  \item
    如果要跟立即数比较，\textbf{先看一下立即数的扩展模式}，能用
    \texttt{npc} 解决的尽量用 \texttt{npc} 解决，p5 有时不用改
    \texttt{cmp}
  \item
    如果根据一个寄存器跳转，那么按照引入了新的比较方式处理，改
    \texttt{cmp} 的比较方式
  \item
    如果跳转时涉及 \texttt{retaddr}，那么有时可以按照
    \texttt{JUMP\_{[}IR{]}} 处理
  \end{itemize}
\item
  如果有新的立即数扩展方式

  \begin{itemize}
  \tightlist
  \item
    如果还是 \texttt{im.result{[}15:0{]}} 改
    \texttt{ext}，\textbf{注意有符号 / 无符号的区别}
  \item
    如果是 \texttt{im.result} 的其它部分，记得加 MUX
    信号来源，\textbf{注意位宽和有符号 / 无符号的区别}
  \end{itemize}
\item
  如果有新的寄存器号表示方法

  \begin{itemize}
  \tightlist
  \item
    加 MUX 信号来源，\textbf{记得改位宽}，控制信号用 sane defaults
  \item
    可以根据指令类型特判
  \end{itemize}
\item
  如果 \texttt{alu} 有新的运算

  \begin{itemize}
  \tightlist
  \item
    \textbf{抓好定义}，例如补码的相反数，最小的负数没有相反数
  \item
    \textbf{注意地址计算是无符号计算、指令给定了是不是有符号运算要注意}
  \item
    如果是两个输入的运算，直接写新运算
  \item
    如果是三个输入的运算，看看能不能省下一个运算源，\textbf{有的时候要改控制的输入}，比如条件传送指令需要根据第二个寄存器的值判断
    \texttt{rf.we}

    \begin{itemize}
    \tightlist
    \item
      如果新值能够比较快地出来，\textbf{注意改转发路径，但是为了正确定不改也可以}，比如条件传送指令
    \end{itemize}
  \item
    如果是输入带附加参数的运算，可以开一个 \texttt{alu}
    端口，然后在控制器上接过去，也可以通过正常数据通路传过去（不推荐），比如移位运算可以直接在控制器和
    \texttt{alu} 上开端口

    \begin{itemize}
    \tightlist
    \item
      注意一般都有 Python，\textbf{可以自动代码生成}
    \end{itemize}
  \end{itemize}
\item
  如果 \texttt{md} 有新的运算

  \begin{itemize}
  \tightlist
  \item
    \textbf{抓好定义}，比如补码的乘除法运算
  \item
    \textbf{注意有 / 无符号计算}
  \item
    \textbf{注意掌握好 \texttt{md} 的内部状态机，\texttt{md}
    利用了时钟的下降沿}
  \item
    \textbf{如果需要检测特殊情况，最好在收到数据后马上检测}，比如检测除法是否除
    0
  \item
    \textbf{注意暂停机制，现在是把跟 \texttt{md}
    相关的指令串行化，但是可能有更复杂的暂停控制}
  \end{itemize}
\item
  如果有新的 \texttt{dm} 存取方式

  \begin{itemize}
  \tightlist
  \item
    如果是特殊的读写范围，那么因为是单周期，可以在 \texttt{dm} 上开端口
    \texttt{mode}，让控制单元控制 \texttt{mode}，注意 sane defaults
    和\textbf{小端序}
  \item
    如果是同时读写，那么也可以用上面的方法，注意 \texttt{dm}
    的读写地址端口是分开的，注意开 MUX 的端口和 sane defaults
  \item
    如果是根据其它来源读写，注意开 MUX 的端口和 sane defaults

    \begin{itemize}
    \tightlist
    \item
      \textbf{注意这样的话转发多了一个新的消费者}
    \end{itemize}
  \end{itemize}
\item
  如果有新的 \texttt{rf} 的值

  \begin{itemize}
  \tightlist
  \item
    注意要接线接过来，然后加 MUX

    \begin{itemize}
    \tightlist
    \item
      \textbf{注意补上每级的 \texttt{pff} 和对应的
      \texttt{wire}，一定要声明，否则默认是 1 位的}
    \end{itemize}
  \item
    如果是返回地址，\textbf{最好是先接当前 PC，然后无符号数 +8}

    \begin{itemize}
    \tightlist
    \item
      \textbf{一般这种指令可以归约到 \texttt{JUMP\_{[}IR{]}} 里}
    \end{itemize}
  \item
    注意 \texttt{rf} 的值是否写入可以跟 \texttt{rf.we}
    配合，\textbf{也可以妙用写入 \texttt{\$0}}
  \end{itemize}
\end{itemize}

\hypertarget{ux5982ux4f55ux6709ux6548ux8c03ux8bd5}{%
\subsection{如何有效调试}\label{ux5982ux4f55ux6709ux6548ux8c03ux8bd5}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  定位出错指令
\end{enumerate}

\begin{itemize}
\tightlist
\item
  平时可以用 \texttt{diff}
\item
  在考场上主要靠看数据和猜

  \begin{itemize}
  \tightlist
  \item
    看数据大法

    \begin{itemize}
    \tightlist
    \item
      前面一堆 0 位或者 1 位出错的，一般是移位指令
    \item
      前面数据乱了的，一般是乘除法指令
    \item
      数据差 1 的，一般是条件设置指令
    \end{itemize}
  \item
    瞎猜大法

    \begin{itemize}
    \tightlist
    \item
      最近加了什么指令
    \item
      哪条指令原理不确定
    \item
      哪条指令是说了的重点
    \item
      哪条指令比较复杂，不好实现
    \item
      课下测试一直没过哪条指令
    \end{itemize}
  \item
    实在不行就把感觉错了的指令都检查一遍
  \end{itemize}
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  分析每级的行为
\end{enumerate}

\begin{itemize}
\tightlist
\item
  先把 RTL 在心里分解成每级
\item
  然后比较出错指令或者觉得出错指令的差异
\item
  然后看转发和暂停是不是写对了

  \begin{itemize}
  \tightlist
  \item
    首先检查\textbf{每级得出的寄存器结果、Tuse 和 Tnew}
  \item
    然后检查控制器的转发是否写对
  \item
    然后检查数据通路的转发是否正确反映了逻辑
  \item
    最后检查一下转发相关的接线
  \end{itemize}
\item
  然后检查每级的行为

  \begin{itemize}
  \tightlist
  \item
    先检查控制信号对不对，\textbf{尤其是新加的控制信号和它们对应的
    defaults}

    \begin{itemize}
    \tightlist
    \item
      如果上面检查了的话，转发和暂停检查一下 defaults
    \end{itemize}
  \item
    \texttt{npc} 看与 \texttt{cmp} 的配合和 \texttt{npc}
    模式本身的实现，注意\textbf{大小比较、有无符号数和指令取立即数的扩展}
  \item
    \texttt{rf} 看取寄存器号对不对，不要乱改改折了，\textbf{注意
    MUX、数据位宽、有无符号数和扩展模式}

    \begin{itemize}
    \tightlist
    \item
      \textbf{检查一下对应的控制信号}
    \end{itemize}
  \item
    \texttt{ext} 看扩展模式对不对，\textbf{注意扩展的是哪些位和扩展模式}
  \item
    \texttt{alu} 看实现的运算对不对，\textbf{要踏实地看定义以及和
    \texttt{rf} 的配合，不要读哪个寄存器都读错了}

    \begin{itemize}
    \tightlist
    \item
      \textbf{如果有第三个参数，检查一下关于第三个参数的逻辑}
    \end{itemize}
  \item
    \texttt{md}
    看实现的运算对不对，\textbf{要踏实地看定义以及内部寄存器的值，注意好时钟周期}

    \begin{itemize}
    \tightlist
    \item
      注意 \texttt{md} 的内部状态机和错误检测机制
    \end{itemize}
  \item
    \texttt{dm}
    看实现的读写模式和读写地址对不对，\textbf{注意端序和读写地址的对应
    MUX，和它们与控制信号的对应关系}

    \begin{itemize}
    \tightlist
    \item
      注意可能读写地址要分开转发，\textbf{这里的接线需要仔细看然后调一下}
    \end{itemize}
  \item
    \texttt{rf}
    还要看实现的钩子对不对，\textbf{尤其是根据寄存器值判断的那部分，因为需要控制器配合}

    \begin{itemize}
    \tightlist
    \item
      \textbf{注意要先实现钩子再转发}
    \end{itemize}
  \end{itemize}
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  分析指令之间的关系
\end{enumerate}

\begin{itemize}
\tightlist
\item
  跟上一条指令之间的关系
\item
  如果是跳转指令，跟以前指令和对应寄存器的关系
\item
  如果是 L/S 指令，跟内存的关系
\item
  如果是乘除法指令，跟乘除法器及其串行化的关系
\item
  CPU 的初始状态
\end{itemize}

\hypertarget{ux5982ux4f55ux6539ux6570ux636eux901aux8def}{%
\subsection{如何改数据通路}\label{ux5982ux4f55ux6539ux6570ux636eux901aux8def}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  分析为什么要改数据通路
\end{enumerate}

\begin{itemize}
\tightlist
\item
  改数据通路代价比较大

  \begin{itemize}
  \tightlist
  \item
    加入流水线后更是如此，\textbf{转发、暂停、流水线寄存器都要重新
    evaluate 一遍}
  \end{itemize}
\item
  必须安装新部件吗？

  \begin{itemize}
  \tightlist
  \item
    可能有的部件可以通过 hook 来解决
  \item
    有的部件可以通过改部件本身的方式来解决
  \item
    可能可以重新把指令的 RTL fit 到现有的数据通路里
  \item
    可能可以直接 hook 控制机制
  \item
    如果要求加新部件，那必须加，没有办法
  \end{itemize}
\item
  新部件部署在哪一级？

  \begin{itemize}
  \tightlist
  \item
    \textbf{直接决定转发、暂停和流水线寄存器的 evaluation}
  \item
    对类比同级的 MUX 和部件有帮助
  \item
    对分清这个部件的功能有描述
  \end{itemize}
\item
  改了新部件，如何既服务好新指令，又能与原来的指令兼容？

  \begin{itemize}
  \tightlist
  \item
    sane defaults
  \item
    可能需要回退机制
  \item
    原来的指令可能需要在控制层面避开新部件带来的影响，不过这一点一般不大可能
  \item
    对 \texttt{md} 这种自带状态机的部件，弄好状态机
  \end{itemize}
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  分析怎么改数据通路
\end{enumerate}

\begin{itemize}
\tightlist
\item
  如果没安装新部件

  \begin{itemize}
  \tightlist
  \item
    如果在 \texttt{npc} 这里加上 hook 机制，记得跟 \texttt{cmp}
    和控制配合好，\textbf{扩展指令的立即数时，源、目的和扩展哪个部分一定要注意}
  \item
    如果在控制加上 hook 机制，\textbf{要注意 sane defaults 和 hook
    机制能不能方便之后修改代码}
  \item
    如果在 \texttt{alu\ /\ ext\ /\ md\ /\ dm}
    加了新功能，\textbf{注意实现是否正确，要紧扣定义}
  \end{itemize}
\item
  如果安装了新部件

  \begin{itemize}
  \tightlist
  \item
    重构一遍新指令的数据通路，\textbf{注意 sane defaults}
  \item
    \textbf{evaluate
    一遍转发、暂停和流水线寄存器，并且仔细地改转发和暂停规则}

    \begin{itemize}
    \tightlist
    \item
      \textbf{看一下有没有多重转发，有的话可以暂停也可以多重转发，不过一般这不大可能}
    \end{itemize}
  \item
    分析一下新部件的功能
  \item
    \textbf{看一下数据通路的更改，注意跟流水线寄存器之间的微妙的关系}
  \item
    如果比较有空，可以稍微测试一下
  \end{itemize}
\end{itemize}

\hypertarget{ux5982ux4f55ux6bd4ux8f83ux65b9ux4fbfux5730ux6539ux8bbeux8ba1}{%
\subsection{如何比较方便地改设计}\label{ux5982ux4f55ux6bd4ux8f83ux65b9ux4fbfux5730ux6539ux8bbeux8ba1}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  可以在加 hook 机制的时候认为这是必须的
\item
  可以在扩展时认为这样可以简化数据通路
\item
  可以在部署部件时部署到比较方便实现的级
\item
  可以在实现内部流水线时认为这样方便调试
\item
  可以在暂停时认为这样可以简化设计
\end{enumerate}
\end{document}

