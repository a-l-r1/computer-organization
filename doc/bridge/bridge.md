## 设备桥

### 原理

设备桥是通过把设备的寄存器地址映射成数据内存地址，从而做到读写设备的寄存器，进而做到对设备的控制的。设备桥通过地址，把多个设备抽象成一个设备，从而避免了 CPU 识别设备的进一步开销。

设备桥对每个设备都需要知道它的寄存器特征和地址范围，这样才能做到有效地对设备的寄存器进行操作。地址范围不能跟数据内存的地址范围重叠，否则会造成冲突，而且无法对地址进行有效的抽象。

### 端口定义

端口 | 类型 | 位宽 | 功能
--- | --- | --- | ---
`clk` | 输入 | 1 | 时钟信号
`rst` | 输入 | 1 | 复位信号
`addr` | 输入 | 32 | 地址信号
`write_enable` | 输入 | 1 | CPU 决定的设备写使能信号
`write_data` | 输入 | 32 | CPU 要写入的数据
`read_result` | 输出 | 32 | CPU 读取的数据
`hwirq` | 输出 | 6 | 硬件中断请求输出

### 宏定义

类别 | 定义 | 值 | 意义
--- | --- | --- | ---
设备地址 | `BRIDGE_TIMER0_LB` | `32'h00007f00` | 第一个 `timer` 的地址下界
设备地址 | `BRIDGE_TIMER0_UB` | `32'h00007f0b` | 第一个 `timer` 的地址上界
设备地址 | `BRIDGE_TIMER1_LB` | `32'h00007f10` | 第二个 `timer` 的地址下界
设备地址 | `BRIDGE_TIMER1_UB` | `32'h00007f1b` | 第二个 `timer` 的地址上界
设备地址 | `BRIDGE_TIMER0_BASE` | `32'h00007f00` | 第一个 `timer` 的基址
设备地址 | `BRIDGE_TIMER0_BASE` | `32'h00007f10` | 第二个 `timer` 的基址

### 功能

如果地址落在某个 `timer` 的地址范围内，就令这个 `timer` 的写使能与 `write_enable` 相同，这个 `timer` 的 `read_result` 为要输出的值。其余的 `timer` 屏蔽写使能。否则，`read_result` 为 `32'b0`。

无论什么时候，`clk` 和 `rst` 的值都接入每个 `timer`。这是为了方便整体时钟信号同步和复位。`hwirq` 的最低位为第一个 `timer` 的 `irq`，倒数第二低位为第二个 `timer` 的 `irq`。

### 注意事项

1. **15 号设备（`curr_dev` 表示的）代表没有设备，14 号设备代表 `dm`**
2. **地址比较用无符号数比较**
3. **地址上下界以字节为单位，而且是包括边界的**

