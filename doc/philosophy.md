# 计组编码哲学

## **手足无措时做什么**

1. Don't panic!
2. 测试的时候把调试打开，不测试的时候把调试观赏
3. 深呼吸，专心想调试的事情
4. 看看哪里的逻辑出错了，**不要逃避！**
5. 稳定心态，做出来是最重要的

## 工具选择

1. 尽量跨平台、用 Python 做跨平台的自动化脚本
2. 用比较熟悉的工具，比如 `git`，`make`
3. 在 Windows 下测试

## 编码风格

### 大小写

统一用 Linux 式风格，全小写，单词间用下划线隔开。也就是 `function_name` ，而不是 `functionName` 或者 `FunctionName`

### 对象命名

可以用常见的缩写，但是要保证一眼就能看明白

#### 部件

```
pc, npc, rf, alu, ext, im, dm, bridge, cp0
```

#### 宏命名格式

用 Linux 式风格，全大写，单词间用下划线隔开。

#### 宏定义规范

1. 能对 `enum` 分区就分区，甚至可以用多位做成树形结构
2. 最好按逻辑顺序排列各 `enum` 对应的值

#### 转发命名格式

`fm_level_part_port`

`fm` 就是 forward muxer 的意思

#### 数据通路 MUX 命名格式

`m_part_port`

`m` 就是 muxer 的意思，`part` 和 `port` 指输出到哪个部件的哪个端口

不能用 `dm`，`dm` 跟 data memory 重复了

#### 数据通路 `wire` 命名格式

`w_part_port / w_m_part_port_srcpart_srcport`

`w` 就是 wire 的意思，`srcpart` 和 `srcport` 指数据通路 MUX 中对应的源端口的部件名和端口名，`part` 和 `port` 也照着相应的输入端口命名

不能用 `dw`，容易和 `dm` 混淆

#### 控制 `wire` 命名格式

##### 控制相应端口的 `wire`

`cw_part_port`

##### 控制 MUX 的 `wire`

`cm_part_port`

##### 表明指令类型的 `wire`

`i_instrtype`

#### 端口命名格式

1. 没有 `input` / `output`
2. 能编号就编号

### 代码结构

1. 模块一定要在输入输出端口时明确指出 `input` 还是 `output`
2. 每个端口占一行，好改
3. 每个代码放在单独的代码文件中
4. 尽量复用代码，用现成的模块
5. 尽量避免魔数，能够用宏定义的地方就要用宏定义，尤其是用类似 enum 的东西的时候

### 代码内容

1. 能让模块暴露内部状态就尽量暴露状态，让上层模块忽略它
2. 接线的时候用位置无关的方法
3. 考虑可维护性
4. 对不同的数字格式，什么看起来最能看明白用什么
5. 能用别名就用，不过要用常见的、合理的
6. 组合逻辑尽量用 `assign` 加三元组，避免引入寄存器
7. 头文件用 `ifndef-define-endif` 格式，宏格式用 `FILENAME_H`
8. 能交代清楚的分支尽量交代，但是隐含值不变的分支不需要交代
9. 有寄存器的时候一定要在 `initial` 块里赋初值
10. `initial` 块里的初值赋值的时候用 `=`

### 调试

1. 调试信息一定要清楚明白
2. 不要打临时调试，要打最多打一次，第二次就要正式化
3. 用包装好的调试函数做调试
4. 多用宏和模版
5. 注意 Verilog 调试的时序
6. 要有宏开关调试，有更细力度的更好
7. 调试也别多打
8. 要有调试信息属于哪个模块
9. 流水线打出属于哪一级

### 设计文档

#### 格式

1. 表格先输入端口后输出端口
2. 端口中 `clk` 是第一位的
3. 功能中如果是时序部件就放在第一段
4. 注意事项没有可以不写
5. 对于不变化的分支也交代清楚，但是非常明显的情况下可以不交代
6. 用到寄存器的时候一定要在 `initial` 块里赋初值

### ALU

#### 命名格式

宏：`ALU_FUNC`

### EXT

#### 命名格式

宏：`EXT_MODE_MODE`

### 控制器

#### 宏命名格式

`X_TYPE, INSTR_XXX, INSTR_ID_XXX, INSTR_MAGIC_XXX_OP, INSTR_MAGIC_XXX_FUNC`

#### 输出端口命名格式

可以跟控制的 `wire` 命名格式一样，到时候传同名的 `wire`

