## 技巧

### 慌了怎么办

1. Don't panic! 做出来是最重要的
2. 深呼吸，专心想实现和调试的事情，不要害怕干不出来
3. 看看哪里的逻辑出错了，**不要逃避！**
4. 用小数据、边界数据、特殊数据测试
5. 踏踏实实想逻辑、定义、算法，必要的时候自己再描述一遍 / 写一遍，不要根据原来做出来的

### 如何加新指令

1. 看好 RTL，把它转换成数据通路的连线
2. 如果有多对一的情况，就应该用 MUX
  * MUX 是原来的值，改控制信号
  * MUX 是新的值，改控制信号，**可能要改 MUX 的位宽和对应接线的位宽**
3. 改好控制信号
  * 对指令域进行识别
  * 对新指令指定相应的控制信号
  * 对新指令指定相应的 MUX 控制信号
  * 如果有新的跳转规则
    * 尽量改 `npc`，让 `npc` 基于比较结果判断
    * 如果引入了新的比较方式，就需要改 `alu`，**注意有符号 / 无符号和运算溢出问题和改 `alu` 的接口**，同时也要改数据通路和 `npc` 的接口
    * 如果要跟立即数比较，**先看一下立即数的扩展模式**，能用 `npc` 解决的尽量用 `npc` 解决，p4 暂时还不用改 `cmp`
    * 如果根据一个寄存器跳转，那么按照引入了新的比较方式处理，改 `alu` 的比较方式
  * 如果有新的立即数扩展方式
    * 如果还是 `im.result[15:0]` 改 `ext`，**注意有符号 / 无符号的区别**
    * 如果是 `im.result` 的其它部分，记得加 MUX 信号来源，**注意位宽和有符号 / 无符号的区别**
  * 如果有新的寄存器号表示方法
    * 加 MUX 信号来源，**记得改位宽**，控制信号用 sane defaults    
    * 可以根据指令类型特判
  * 如果有新的运算
    * **抓好定义**，例如补码的相反数，最小的负数没有相反数
    * **注意地址计算是无符号计算、指令给定了是不是有符号运算要注意**
    * 如果是两个输入的运算，直接写新运算
    * 如果是三个输入的运算，看看能不能省下一个运算源，**有的时候要改控制的输入**，比如条件传送指令需要根据第二个寄存器的值判断 `rf.we`
    * 如果是输入带附加参数的运算，可以开一个 `alu` 端口，然后在控制器上接过去，也可以通过正常数据通路传过去（不推荐），比如移位运算可以直接在控制器和 `alu` 上开端口
  * 如果有新的 `dm` 存取方式
    * 如果是特殊的读写范围，那么因为是单周期，可以在 `dm` 上开端口 `mode`，让控制单元控制 `mode`，注意 sane defaults 和**端序**
    * 如果是同时读写，那么也可以用上面的方法，注意 `dm` 的读写地址端口是分开的，注意开 MUX 的端口和 sane defaults
    * 如果是根据其它来源读写，注意开 MUX 的端口和 sane defaults
  * 如果有新的 `rf` 的值
    * 注意要接线接过来，然后加 MUX
    * 如果是返回地址，**最好是先接过当前 PC，然后无符号数 +4**
    * 注意 `rf` 的值是否写入可以跟 `rf.we` 配合

### 如何有效调试

1. 定位出错指令
  * 平时可以用 `diff`
  * 在考场上主要靠看数据和猜
    * 看数据大法
      * 前面一堆 0 位或者 1 位出错的，一般是移位指令
      * 前面数据乱了的，一般是乘除法指令
      * 数据差 1 的，一般是条件设置指令
    * 瞎猜大法
      * 最近加了什么指令
      * 哪条指令原理不确定
      * 哪条指令是说了的重点
      * 哪条指令比较复杂，不好实现
      * 课下测试一直没过哪条指令
    * 实在不行就把感觉错了的指令都检查一遍
2. 分析每级的行为
  * 先把 RTL 在心里分解成每级
  * 然后比较出错指令或者觉得出错指令的差异
  * 然后检查每级的行为
    * 先检查控制信号对不对，**尤其是新加的控制信号和它们对应的 defaults**
    * `npc` 看与 `alu` 的配合和 `npc` 模式本身的实现，注意**大小比较、有无符号数和指令取立即数的扩展**
    * `rf` 看取寄存器号对不对，不要乱改改折了，**注意 MUX、数据位宽、有无符号数和扩展模式**
    * `ext` 看扩展模式对不对，**注意扩展的是哪些数字和扩展模式**
    * `alu` 看实现的运算对不对，**要踏实地看定义以及和 `rf` 的配合，不要读哪个寄存器都读错了**
    * `dm` 看实现的读写模式和读写地址对不对，**注意端序和读写地址的对应 MUX，和它们与控制信号的对应关系**
    * `rf` 还要看实现的钩子对不对，**尤其是根据寄存器值判断的那部分，因为需要控制器配合**
3. 分析指令之间的关系
  * 跟上一条指令之间的关系
  * 如果是跳转指令，跟以前指令的关系
  * 如果是 L/S 指令，跟内存的关系
  * CPU 的初始状态

### 如何改数据通路

1. 分析为什么要改数据通路
  * 改数据通路代价比较大
  * 必须安装新部件吗？
    * 可能有的部件可以通过 hook 来解决
    * 有的部件可以通过改部件本身的方式来解决
    * 可能可以重新把指令的 RTL fit 到现有的数据通路里
    * 可能可以直接 hook 控制机制
    * 如果要求加新部件，那也没办法
  * 新部件部署在哪一级？
    * 单周期处理器这样不重要，但是还是要做一遍
    * 对类比同级的 MUX 和部件有帮助
    * 对分清这个部件的功能有描述
  * 改了新部件，如何既服务好新指令，又能与原来的指令兼容？
    * sane defaults
    * 可能需要回退机制
    * 原来的指令可能需要在控制层面避开新部件带来的影响，不过这一点一般不大可能
2. 分析怎么改数据通路
  * 如果没安装新部件
    * 如果在 `npc` 这里加上 hook 机制，记得跟 `alu` 和控制配合好，**扩展指令的立即数时源、目的和扩展哪个部分一定要注意**
    * 如果在控制加上 hook 机制，**要注意 sane defaults 和 hook 机制能不能方便之后修改代码**
    * 如果在 `alu / ext / dm` 加了新功能，**注意实现是否正确，要紧扣定义**
  * 如果安装了新部件
    * 重构一遍新指令的数据通路，**注意 sane defaults**
    * 分析一下新部件的功能
    * 如果比较有空，可以稍微测试一下

### 如何比较方便地改设计

1. 可以在加 hook 机制的时候认为这是必须的
2. 可以在扩展时认为这样可以简化数据通路
3. 可以在部署部件时部署到比较方便实现的级

