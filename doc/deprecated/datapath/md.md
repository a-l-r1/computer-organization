## 乘除法器

### 原理

乘除法器是 MIPS 体系结构中运算代价比较高的部件，需要多个时钟周期进行运算。因此，它必须要有 `busy` 信号指定它是不是忙，通过是不是忙来让控制模块决定暂停和转发。

两个 32 位数的乘法结果是 64 位，所以需要两个 32 位寄存器。同样地，除法有商和余数，所以也需要两个 32 位寄存器。总结起来，乘除法器需要两个 32 位寄存器。乘法有高低位的区别，把它们叫做 `HI` 和 `LO` 寄存器能区分过来。

乘除法需要多个周期，但是模拟时乘除法只要一个周期。因此，需要在乘除法器内部设定一个计时器，模拟需要多个周期乘除法的行为。还没有准备好时，就在 `HI` 和 `LO` 寄存器输出代替的值。

### 端口定义

端口 | 类型 | 位宽 | 功能
--- | --- | --- | ---
clk | 输入 | 1 | 时钟信号
dh | 输入 | 32 | 第一个输入的数据
dl | 输入 | 32 | 第二个输入的数据
op | 输入 | 4 | 需要的操作
undo | 输出 | 1 | 根据当前操作恢复 `HI` 和 `LO` 寄存器的值或者停止运算
busy | 输出 | 1 | 乘除法器是否繁忙
invalid | 输出 | 1 | 乘除法操作是否非法
hi | 输出 | 32 | `HI` 寄存器的值
lo | 输出 | 32 | `LO` 寄存器的值

### 宏定义

各宏的意义如果是对应的操作，就省略。

类别 | 定义 | 值 | 意义
--- | --- | --- | ---
`op` | `MD_NONE` | `4'd0000` |
`op` | `MD_MFHI` | `4'd0001` | 
`op` | `MD_MFLO` | `4'd0010` | 
`op` | `MD_MTHI` | `4'd0011` | 
`op` | `MD_MTLO` | `4'd0100` | 
`op` | `MD_MULT` | `4'd0101` | 
`op` | `MD_MULTU` | `4'd0110` | 
`op` | `MD_DIV` | `4'd0111` | 
`op` | `MD_DIVU` | `4'd1000` | 

### 功能

该部件为时序部件，所有寄存器初值为 0.

有一个 4 位宽的计时器 ctr。

无论什么时候，`hi` 和 `lo` 都分别是 `hi_reg` 和 `lo_reg` 的内容。无论什么时候，`busy` 都是 `ctr` 作为无符号数大于 0 时为 `1'b1`，否则为 `1'b0`。`invalid` 都是 `(op_i == MD_DIV || op_i == MD_DIVU) && dl_i == 32'b0` 时为 1'b1，否则为 1'b0。检查内部寄存器是因为内部寄存器才是 `md` 内保存的真正状态，而且在一个时钟周期内检查来得及。

每个时钟上升沿，若计时器 `ctr` 的值作为无符号数大于 1，则把 `ctr` 减 1。否则，若 `ctr` 的值作为无符号数等于 1，则令 `hi_reg` 和 `lo_reg` 分别为 `dh_i` 和 `dl_i` 寄存器在相应运算下的结果，`hi_reg <= old_hi, lo_reg <= old_lo`。否则，什么也不做。

每个时钟下降沿，若 `op == MD_NONE || stop == 1'b1 || restore == 1'b1`，则什么也不做。

否则，若 `op == MD_MTHI || op == MD_MTLO`，则把 `dh` 的值写入相应的寄存器，`op_i <= op`，`old_hi <= hi_reg; old_lo <= lo_reg`。若 `op == MD_MFHI || op == MD_MFLO`，也是什么也不做，因为控制模块会自动选择相应的寄存器作为要读取的值。若 `op == MD_MULT || op == MD_MULTU || op == MD_DIV || op == MD_DIVU`，则把 `ctr` 设置成对应的数值，而且把内部 `dh_i`、`dl_i` 和 `op_i` 寄存器的值分别设置成 `dh`、`dl`和 `op`。乘法操作 `ctr` 初值是 5，除法操作 `ctr` 初值是 10。若 `op` 为其它值，也是什么也不做。

### 注意事项

1. **除法是把 `dh` 当被除数，`dl` 当除数。但结果表示的时候，`hi` 当余数，`lo` 当商。若 `dl == 32'b0`，则不生成新的结果，`hi` 和 `lo` 保持原来的结果，这是为了跟 MARS 保持兼容，但是要覆盖保存的旧的 `hi` 和 `lo` 寄存器的值为原来的结果，因为这样跟进入 ISR 有关的复位操作在机制不变的情况下逻辑上才能说得过去**
2. **没有考虑第一条指令是 `CAL_M` 类指令，但是时钟没有下降沿的情况。**
3. **`restore / stop` 信号只是名字上有指示，实际上如果出现了这种信号，下一个时钟下降沿就不会更新了，也不需要在下一个时钟上升沿复位**
4. **若 E 级指令为对应的指令，下降沿不会执行 `mthi / mtlo / mfhi / mflo`，不过进 ISR 时会在下个上升沿恢复；但是若 E 级指令为其它指令，不会做任何撤销操作。这是因为乘除法会在后台进行，若 ISR 中需要乘除法指令则符合逻辑，否则也不影响正常计算，同样符合逻辑。即使 ISR 中做了乘除法计算出 ISR 后再用，需要计算结果的时候暂停机制也能保证暂停，也是符合逻辑的。即使 ISR 中需要乘除法指令，也不会轻易覆盖原来正在执行的乘除法指令的内容，因为还有暂停机制**
5. **不用担心取消了对 `ctr` 的判断以后会出现操作做到一半被覆盖的问题，因为有 `busy` 信号撑着，因为暂停机制，下一个能操作 `md` 的指令进不到 E 级来**

