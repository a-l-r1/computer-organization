## 计时器

### 原理

计时器是产生硬件中断的一种示例部件。它由状态机组成，可以进行定时，并在规定的时间到时产生中断。它内部维护一个计数器和保存控制信号的两个寄存器，从而可以对计数进行控制。CPU 可以通过 `bridge` 模块更改各寄存器的值。

### 端口定义

端口 | 类型 | 位宽 | 功能
--- | --- | --- | ---
`clk` | 输入 | 1 | 时钟信号
`rst` | 输入 | 1 | 同步复位信号
`addr` | 输入 | 32 | 地址信号
`write_enable` | 输入 | 1 | 写使能信号
`write_data` | 输入 | 32 | 要写入内部寄存器的数据
`read_result` | 输出 | 32 | 从内部寄存器读出的数据
`irq` | 输出 | 1 | 中断请求输出

### 宏定义

类别 | 定义 | 值 | 意义
--- | --- | --- | ---
状态 | `TIMER_IDLE` | `3'b000` | 空闲状态
状态 | `TIMER_LOAD` | `3'b001` | 装载状态
状态 | `TIMER_CNT` | `3'b010` | 计数状态
状态 | `TIMER_INT` | `3'b011` | 处理中断状态

### 参数定义

参数 | 默认值 | 功能
--- | --- | ---
`BASE` | `32'h00007f00` | 在 `bridge` 模块中该模块实例的基址

### 功能

该部件为时序部件。

内部维护 3 个 32 位寄存器，名字按地址从小到大分别为 `ctrl, preset, count`。`ctrl` 的结构为 `{28'b0, allow_irq, 1'b0, mode, enable}`，`preset` 和 `count` 分别作为 32 位计数的预设值和当前值。`allow_irq`，`mode` 和 `enable` 分别表示是否允许中断、计数模式和计数器使能。它们的初值都为全 0。
每个时钟上升沿，首先检查 `rst` 是否为 `1'b1`，若是，则把所有寄存器都恢复初值。

之后，检查写入是否有效。若 `write_enable` 为 `1'b1` 且要写入的地址为 `preset` 或 `ctrl` 的起始地址，则写入有效，把对应的寄存器写入 `write_data` 对应的内容。注意 `count` 寄存器禁止写入。注意写入 `CTRL` 寄存器时，原来为全 0 的位仍然保持全 0。若地址超出范围或写入无效，则什么也不做。

注意：**地址越界检查由 `ac` 完成，写入设备的字不对齐时直接被设备忽略，但是会触发异常。**

注意：**`count` 寄存器禁止写入，若试图写入 `count` 寄存器，也会被设备忽略，而且会触发异常。**

最后，进行状态转移。一共有四种状态，在宏定义中描述。每种状态中没有描述的情况，默认为什么也不做。

1. 若为 `TIMER_IDLE`，则当 `enable == 1'b1` 时，令 `irq_reg <= 1'b0`，并转移到 `TIMER_LOAD`。否则，若 `allow_irq == 1'b0` 时，也令 `irq_reg <= 1'b0`。
2. 若为 `TIMER_LOAD`，则令 `count <= preset`，并转移到 `TIMER_CNT`。
3. 若为 `TIMER_CNT`，则 `enable == 1'b0` 时，转移到 `TIMER_IDLE`。否则，`$unsigned(count) > $unsigned(1)` 时，`count <= $unsigned(count) - $unsigned(1)`；`$unsigned(count) == $unsigned(1)` 时， `count` 同样按照上一种情况自减 1，并转移到 `TIMER_INT`，但是同时在 `allow_irq == 1'b1`时，令 `irq_reg <= 1'b1`。
4. 若为 `TIMER_INT`，则 `mode == 1'b0` 时， `enable <= 1'b0`，这样可以保持中断信号，但`allow_irq == 1'b0` 时，也得令 `irq_reg <= 1'b0`；`mode == 1'b1` 时，`irq_reg <= 1'b0`。`mode` 的两种值都要转移到 `TIMER_IDLE`。

无论什么时候，`read_result` 都是 `addr` 对应的内部寄存器的值。若 `addr` 超出范围，则为 `32'b0`。无论什么时候，`irq = irq_reg`。

### 注意事项

1. 改寄存器个数的时候记得同时改 `read_result` 的判断
2. **地址运算都是无符号的**
3. **`allow_irq` 因为默认不会用，所以初始化为 0**
4. **写不该写的寄存器和写的模式错误，写使能信号会被 `cpu` 禁用掉，所以不用担心误写**

