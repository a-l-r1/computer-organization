\PassOptionsToPackage{unicode=true}{hyperref} % options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
%

\documentclass[12pt,AutoFakeBold,AutoFakeSlant]{article}
% 12pt == 小四

\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{unicode-math}

% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available

\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}

\usepackage{hyperref}
\hypersetup{
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls

\usepackage{longtable,booktabs}

% Fix footnotes in tables (requires footnote package)
\IfFileExists{footnote.sty}{\usepackage{footnote}\makesavenoteenv{longtable}}{}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}

\usepackage{fontspec}
\usepackage{ctex}

\usepackage{indentfirst}
\usepackage{fullpage}

\setmainfont{Times New Roman}
\setmonofont{Courier New}
\setCJKmainfont{SimSun}
\setCJKmonofont{SimSun}

\usepackage{listings}
\lstset{basicstyle=\ttfamily,breaklines=true}

\usepackage[table,svgnames]{xcolor}
\usepackage{cellspace}
\usepackage{etoolbox}
\definecolor{headercolor}{RGB}{198,217,241} % #c6d9f1

\linespread{1.5} % https://tex.stackexchange.com/questions/30073/why-is-the-linespread-factor-as-it-is
\usepackage[tmargin=1in,bmargin=1in,lmargin=1.25in,rmargin=1.25in]{geometry} % word-like, see https://tex.stackexchange.com/questions/35892/latex-optimal-settings-for-ms-word-like-document
\setlength{\arrayrulewidth}{0.5pt}

\AtBeginEnvironment{longtable}{\rowcolors{0}{\ifnumless{\rownum}{3}{white}{headercolor}}{}}
\AtBeginEnvironment{longtable}{\zihao{5}}

\usepackage{nameref}
\makeatletter
\newcommand*{\currentname}{\@currentlabelname}
\makeatother
\newcounter{tablecaption}
\AtBeginEnvironment{longtable}{\stepcounter{tablecaption}\flushright{{\setlength\parskip{0pt}\heiti{表 \arabic{tablecaption} \currentname{}}}}\vspace*{-7pt}} % NOTE: hack since \caption in longtable breaks the current way of setting colors for table header

\newcommand{\headingcellfirst}[1]{\multicolumn{1}{|c|}{\heiti{#1}}} % NOTE: \DeclareRobustCommand has issues
\newcommand{\headingcellmiddle}[1]{\multicolumn{1}{c|}{\heiti{#1}}}
\newcommand{\headingcelllast}[1]{\multicolumn{1}{c|}{\heiti{#1}}}

\usepackage{makecell}
\usepackage{multirow}

\usepackage{mips}

\begin{document}

{
\setlength{\parskip}{\baselineskip}%

\begin{center}
\zihao{3}
\heiti{计算机组成原理实验报告}
\end{center}
}

\tableofcontents
\newpage

\hypertarget{npc}{%
\section{NPC}\label{npc}}

\hypertarget{ux539fux7406}{%
\subsection{原理}\label{ux539fux7406}}

NPC 是下个 PC 值的意思。它能做到根据当前的 PC 值，计算出下一个 32 位的
PC 值。

一般来说，PC 值的转换是顺序转换。但是，NPC
必须要听控制模块的指令，做到在某些条件下进行符号转换。

\hypertarget{ux63a5ux53e3ux5b9aux4e49}{%
\subsection{接口定义}\label{ux63a5ux53e3ux5b9aux4e49}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{curr\_pc} & 输入 & 32 & 当前 PC\tabularnewline\hline
\texttt{jump\_mode} & 输入 & 3 & 是否可以跳转\tabularnewline\hline
\texttt{alu\_comp\_result} & 输入 & 2 & ALU 的比较结果\tabularnewline\hline
\texttt{num} & 输入 & 16 & 输入的立即数\tabularnewline\hline
\texttt{jnum} & 输入 & 26 & 输入的 J 型指令的立即数\tabularnewline\hline
\texttt{reg\_} & 输入 & 32 & 输入的寄存器值\tabularnewline\hline
\texttt{next\_pc} & 输出 & 32 & 下一个 PC\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49}}

用把宏定义成宏的方法，定义表中值为宏的宏。把一个宏定义成另一个宏，那该宏的意义与定义它的宏一样，表中省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{jump\_mode} & \texttt{NPC\_JUMP\_DISABLE} & 3'b000 &
不要跳转\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_JUMP\_WHEN\_EQUAL} & 3'b001 & 当输入的比较结果相等时跳转\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_JUMP\_WHEN\_NOT\_EQUAL} & 3'b010 & 当输入的比较结果不等时跳转\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_REG} & 3'b111 &
按照寄存器内地址跳转\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_J} & 3'b110 & 按照 J
型指令的立即数跳转\tabularnewline\hline

\end{longtable}

\texttt{alu\_comp\_result}
的相应数值代表的意义，与相应的宏有关，这些宏在 \texttt{alu.h} 中。

\hypertarget{ux529fux80fd}{%
\subsection{功能}\label{ux529fux80fd}}

令跳转基准地址 \texttt{base\ =\ \$unsigned(curr\_pc)}。

若 \texttt{jump\_mode\ ==\ NPC\_JUMP\_DISABLE}，则令
\texttt{next\_pc\ =\ \$unsigned(base)\ +\ \$unsigned(4)}。

若 \texttt{jump\_mode\ ==\ NPC\_JUMP\_WHEN\_EQUAL}，则
\texttt{alu\_comp\_result\ ==\ ALU\_EQUAL} 时，首先把 \texttt{num}
扩展成 32 位有符号立即数，扩展方式是首先把 \texttt{num} 后面加上
\texttt{2\textquotesingle{}b0}，然后把这 18 位二进制数扩展成 32
位有符号二进制数。然后令
\texttt{next\_pc\ =\ \$signed(base)\ +\ \$signed(num)}。否则做跟
\texttt{jump\_mode\ ==\ NPC\_JUMP\_DISABLE} 时相同的步骤。

若 \texttt{jump\_mode\ ==\ NPC\_JUMP\_WHEN\_NOT\_EQUAL}，则
\texttt{alu\_comp\_result\ !=\ ALU\_EQUAL}
时，做跟上面相同的步骤。否则做跟
\texttt{jump\_mode\ ==\ NPC\_JUMP\_DISABLE} 时相同的步骤。

若 \texttt{jump\_mode\ ==\ NPC\_REG}，则令 \texttt{next\_pc\ =\ reg\_}。

若 \texttt{jump\_mode\ ==\ NPC\_J}，则令
\texttt{next\_pc\ =\ \{base{[}31:28{]},\ jnum,\ 2\textquotesingle{}b0\}}。

若 \texttt{jump\_mode} 为其它值，则做跟
\texttt{jump\_mode\ ==\ NPC\_JUMP\_DISABLE} 时相同的步骤。

\hypertarget{ux6ce8ux610fux4e8bux9879}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  NPC 是在内部进行符号扩展，不用 ext。
\item
  \texttt{reg\_} 是为了避免和 \texttt{reg} 冲突。
\item
  \texttt{base} 抽象出来是为了方便调试和维护，它是跟 MIPS
  指令集手册相符的。
\end{enumerate}

\hypertarget{pc}{%
\section{PC}\label{pc}}

\hypertarget{ux539fux7406-1}{%
\subsection{原理}\label{ux539fux7406-1}}

PC
是程序计数器的意思，负责对当前的指令进行计数。它是标记程序执行到哪里的一种方法，同时输出的信息也被送入指令内存
IM，用来取指。

PC 只负责表示程序执行到哪里，而 PC 的更新由 NPC
模块负责。这样可以做到更简便地处理跳转指令、也对流水线 CPU
插入气泡有帮助。

\hypertarget{ux7aefux53e3ux5b9aux4e49}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & 输入 & 1 & 时钟信号\tabularnewline\hline
\texttt{rst} & 输入 & 1 & 同步复位信号\tabularnewline\hline
\texttt{next\_pc} & 输入 & 32 & NPC 计算得来的下一个 PC
地址\tabularnewline\hline
\texttt{enable} & 输入 & 1 & PC 使能\tabularnewline\hline
\texttt{curr\_pc} & 输出 & 32 & PC 地址\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-1}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-1}}

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{enable} & \texttt{PC\_ENABLED} & 1'b1 & PC 使能\tabularnewline\hline
\texttt{enable} & \texttt{PC\_DISABLED} & 1'b0 & PC
非使能\tabularnewline\hline
\texttt{curr\_pc} & \texttt{PC\_START\_ADDRESS} & 32'h00003000 & PC
的起始地址\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-1}{%
\subsection{功能}\label{ux529fux80fd-1}}

该部件是时序部件。

有一个 32 位的寄存器保存当前 PC 的值，初值为
\texttt{PC\_START\_ADDRESS}。

在每个时钟上升沿，若复位信号为 \texttt{1'b1}，则进行同步复位，把 \texttt{pc} 寄存器恢复到初值。否则，若 \texttt{enable\ ==\ PC\_ENABLED}，则把 PC 部件中保存的当前 PC 的值更新成 \texttt{next\_pc} 的值。否则，保存的当前
PC 的值不变。

无论什么时候，输出端口 \texttt{curr\_pc} 的值都是 PC 部件中保存的当前 PC
的值。

\hypertarget{ux6ce8ux610fux4e8bux9879-1}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-1}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  PC 和 IM 的起始地址是分开定义的，改的时候要注意。
\end{enumerate}

\hypertarget{ux7a0bux5e8fux5b58ux50a8ux5668}{%
\section{程序存储器}\label{ux7a0bux5e8fux5b58ux50a8ux5668}}

\hypertarget{ux539fux7406-2}{%
\subsection{原理}\label{ux539fux7406-2}}

程序存储器是存储程序指令的地方。为了加载程序指令，它可以通过系统任务读取编译后的指令内容。

为了简便，程序存储器由许多寄存器实现。

\hypertarget{ux7aefux53e3ux5b9aux4e49-1}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-1}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{addr} & 输入 & \texttt{IM\_ADDR\_WIDTH} & 读地址\tabularnewline\hline
\texttt{enable} & 输入 & 1 & 使能信号\tabularnewline\hline
\texttt{result} & 输出 & 32 & 读到的结果\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-2}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-2}}

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{enable} & \texttt{IM\_ENABLE} & \texttt{1\textquotesingle{}b1} &
IM 使能\tabularnewline\hline
\texttt{enable} & \texttt{IM\_DISABLE} & \texttt{1\textquotesingle{}b0}
& IM 非使能\tabularnewline\hline
\texttt{addr} & \texttt{IM\_ADDR\_WIDTH} & 12 & \texttt{addr}
的位宽\tabularnewline\hline
\texttt{addr} & \texttt{IM\_START\_ADDRESS} & \texttt{32'h00003000} & IM
对外表现的起始地址\tabularnewline\hline
指令存储器 & \texttt{IM\_SIZE} & 1024 & 能存储指令的个数\tabularnewline\hline
指令存储器 & \texttt{IM\_CODE\_FILENAME} & \texttt{"code.txt"} &
要加载的机器码\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-2}{%
\subsection{功能}\label{ux529fux80fd-2}}

有 \texttt{IM\_SIZE} 个 32
位存储器，代表其中存储的指令。它们初值应该使用加载文件的系统任务加载。加载文件名由
\texttt{IM\_CODE\_FILENAME} 指定。

若 \texttt{addr} 作为无符号数小于 \texttt{IM\_START\_ADDRESS}，则也返回
\texttt{32\textquotesingle{}b0}。否则，\texttt{result} 为
\texttt{addr\ -\ IM\_START\_ADDRESS} 这个地址再取
\texttt{{[}IM\_ADDR\_WIDTH\ -\ 1:2{]}}
对应的指令（从存储器中取得，是两个无符号数相减）。若相减后的结果超出了已经加载的指令所占的地址空间，则
\texttt{result} 为 \texttt{32\textquotesingle{}b0}。

\hypertarget{ux6ce8ux610fux4e8bux9879-2}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-2}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{IM\_ADDR\_WIDTH} 和 \texttt{IM\_SIZE}
  需要一块改，因为它们的大小有关系
\item
  有 offset 了，注意跟 offset 相减是无符号数相减
\item
  offset 主要是为了和 MARS 兼容
\end{enumerate}

\hypertarget{ux5bc4ux5b58ux5668ux5806}{%
\section{寄存器堆}\label{ux5bc4ux5b58ux5668ux5806}}

\hypertarget{ux539fux7406-3}{%
\subsection{原理}\label{ux539fux7406-3}}

寄存器堆保存着 32 位 32 个通用寄存器，负责存储 CPU
立刻想要的数据，它是存储器层次结构中的最高一级，负责暂存数据。第 0
号寄存器 \texttt{\$0} 的值永远是
\texttt{32\textquotesingle{}b0}，写入不会改变它的值。

由于 MIPS
体系结构中的指令最多读两个寄存器，写一个寄存器，所以寄存器输入两个要读的地址，输出两个要读的数据；输入一个要写的地址和一个要写的数据；同时还有写使能端口。

寄存器的使用没有规定，这一般是软件关心的问题。

\hypertarget{ux7aefux53e3ux5b9aux4e49-2}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-2}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & 输入 & 1 & 时钟信号\tabularnewline\hline
\texttt{rst} & 输入 & 1 & 同步复位信号\tabularnewline\hline
\texttt{curr\_pc} & 输入 & 32 & 当前 PC 的值\tabularnewline\hline
\texttt{read\_addr1} & 输入 & 5 & 第一个读地址\tabularnewline\hline
\texttt{read\_addr2} & 输入 & 5 & 第二个读地址\tabularnewline\hline
\texttt{write\_addr} & 输入 & 5 & 写地址\tabularnewline\hline
\texttt{write\_data} & 输入 & 32 & 要写入的数据\tabularnewline\hline
\texttt{write\_enable} & 输入 & 1 & 写使能\tabularnewline\hline
\texttt{read\_result1} & 输出 & 32 &
第一个读地址读出的数据\tabularnewline\hline
\texttt{read\_result2} & 输出 & 32 &
第二个读地址读出的数据\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-3}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-3}}

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{.*\_addr.*} & \texttt{RF\_ADDR\_ZERO} & 5'b0 &
零寄存器的地址\tabularnewline\hline
\texttt{write\_enable} & \texttt{RF\_WRITE\_ENABLED} & 1'b1 &
寄存器堆使能\tabularnewline\hline
\texttt{write\_enable} & \texttt{RF\_WRITE\_DISABLED} & 1'b0 &
寄存器堆非使能\tabularnewline\hline
输出 & \texttt{RF\_OUTPUT\_FORMAT} &
\texttt{"\%d@\%h: \$\%d <= \%h"} &
输出模板\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-3}{%
\subsection{功能}\label{ux529fux80fd-3}}

该部件为时序部件。

有 31 个 32 位寄存器，代表
\texttt{\$1}\textasciitilde{}\texttt{\$31}，它们初值都为
\texttt{32\textquotesingle{}b0}。\texttt{\$0} 实际上不需要寄存器。

在每个时钟上升沿，若同步复位信号为 \texttt{1'b1}，则进行同步复位。否则，若 \texttt{write\_enable\ ==\ RF\_WRITE\_ENABLED} 且
\texttt{write\_addr\ !=\ RF\_ADDR\_ZERO}，则说明可以执行写操作，且写到的寄存器是可以保存数值的寄存器。此时把
\texttt{write\_addr} 指代的寄存器的值更新为
\texttt{write\_data}。更新时，以模版中的格式打印出数据变化，第一个参数是当前的模拟时钟的时间，第二个参数是当前
PC 的值，第三个参数是寄存器号，第四个参数是更新后的值。

无论什么时候，若 \texttt{read\_addr1\ !=\ RF\_ADDR\_ZERO}，则把
\texttt{read\_addr1} 指代的寄存器的值输出到 \texttt{read\_result1}
中，否则把 \texttt{32\textquotesingle{}b0} 输出到 \texttt{read\_result1}
中。对 \texttt{read\_addr2} 和 \texttt{read\_result2} 的相应操作相同。

\hypertarget{ux6ce8ux610fux4e8bux9879-3}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-3}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  暂时还没有内部转发。
\item
  寄存器可以定义为 \texttt{reg\ {[}31:1{]}\ registers\ {[}31:0{]}}，把
  \texttt{\$0} 空出来。
\end{enumerate}

\hypertarget{ux6bd4ux8f83ux6a21ux5757}{%
\section{比较模块}\label{ux6bd4ux8f83ux6a21ux5757}}

\hypertarget{ux539fux7406-4}{%
\subsection{原理}\label{ux539fux7406-4}}

比较模块通过比较两个寄存器的数据，实现分支指令和条件传送指令的提前跳转，提高跳转的效率。

\hypertarget{ux63a5ux53e3ux5b9aux4e49-1}{%
\subsection{接口定义}\label{ux63a5ux53e3ux5b9aux4e49-1}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{reg1} & 输入 & 32 & 第一个寄存器的输入\tabularnewline\hline
\texttt{reg2} & 输入 & 32 & 第二个寄存器的输入\tabularnewline\hline
\texttt{cmp} & 输出 & 2 & 无符号比较结果输出\tabularnewline\hline
\texttt{sig\_cmp} & 输出 & 2 & 有符号比较结果输出\tabularnewline\hline
\texttt{reg2\_sig\_cmp} & 输出 & 2 & \texttt{reg2} 与 0
的有符号比较结果输出\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-4}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-4}}

把 \texttt{CMP\_LARGER,\ CMP\_SMALLER,\ CMP\_EQUAL} 分别定义成
\texttt{ALU\_LARGER,\ ALU\_SMALLER,\ ALU\_EQUAL}。

\hypertarget{ux529fux80fd-4}{%
\subsection{功能}\label{ux529fux80fd-4}}

在 \texttt{comp,\ sig\_comp,\ reg2\_sig\_comp}
三个输出端口分别输出第一个寄存器与第二个寄存器作为无符号数的比较结果、它们作为有符号数的比较结果和第二个寄存器与
0 作为有符号数的比较结果。

\hypertarget{ux6269ux5c55ux5668}{%
\section{扩展器}\label{ux6269ux5c55ux5668}}

\hypertarget{ux529fux80fd-5}{%
\subsection{功能}\label{ux529fux80fd-5}}

扩展器是专门执行扩展整数功能的运算。它能做到小于 32 位的整数向 32
位整数的转换，其中有符号转换，也有无符号转换。

转换器的模式由宏定义的方式指定，有符号扩展，也有无符号扩展，也有其它模式。由于没有明显的层次和类别关系，采用顺序编号和按常见顺序编号的方法。

\hypertarget{ux63a5ux53e3ux5b9aux4e49-2}{%
\subsection{接口定义}\label{ux63a5ux53e3ux5b9aux4e49-2}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{num} & 输入 & 16 & 输入的数字\tabularnewline\hline
\texttt{mode} & 输入 & 3 & 模式\tabularnewline\hline
\texttt{result} & 输出 & 32 & 扩展的结果\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-5}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-5}}

用把宏定义成宏的方法，定义表中值为宏的宏。把一个宏定义成另一个宏，那该宏的意义与定义它的宏一样，表中省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{mode} & \texttt{EXT\_MODE\_SIGNED} & 3'b000 &
符号扩展\tabularnewline\hline
\texttt{mode} & \texttt{EXT\_MODE\_UNSIGNED} & 3'b001 &
无符号扩展\tabularnewline\hline
\texttt{mode} & \texttt{EXT\_MODE\_PAD} & 3'b010 & \texttt{lui} 式扩展\tabularnewline\hline
\texttt{mode} & \texttt{EXT\_MODE\_ONE} & 3'b011 & 在数字前面填充二进制
1 的扩展\tabularnewline\hline
\texttt{mode} & \texttt{EXT\_ONE} & \texttt{EXT\_MODE\_ONE}
&\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-6}{%
\subsection{功能}\label{ux529fux80fd-6}}

若 \texttt{mode}
的值为合法操作（即上面``宏定义''一节中列出的操作），按照 \texttt{mode}
中给出的操作计算出结果，并把结果放入 \texttt{result} 中。

若 \texttt{mode} 的值为非法操作，就令
\texttt{result\ =\ 32\textquotesingle{}b0}。

\hypertarget{alu}{%
\section{ALU}\label{alu}}

\hypertarget{ux539fux7406-5}{%
\subsection{原理}\label{ux539fux7406-5}}

ALU 是运算控制单元的意思，负责两个 32
位整数的运算。它可以负责各种运算，包括数学运算和逻辑运算。易知它是纯组合逻辑。

\hypertarget{ux7aefux53e3ux5b9aux4e49-3}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-3}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{num1} & 输入 & 32 & 第一个操作数\tabularnewline\hline
\texttt{num2} & 输入 & 32 & 第二个操作数\tabularnewline\hline
\texttt{op} & 输入 & 5 & 操作符\tabularnewline\hline
\texttt{result} & 输出 & 32 & 结果\tabularnewline\hline
\texttt{comp\_result} & 输出 & 2 & 作为无符号数的比较结果\tabularnewline\hline
\texttt{sig\_comp\_result} & 输出 & 2 &
作为有符号数的比较结果\tabularnewline\hline
\texttt{overflow} & 输出 & 1 & 计算过程中是否发生溢出\tabularnewline\hline
\texttt{op\_invalid} & 输出 & 1 & 操作符是否无效\tabularnewline\hline

\end{longtable}

由于在硬件层级对数的加减都是无符号数加减法，所以这里的溢出，是指操作过程中出现了做无符号数加减法时结果超出无符号数范围的现象。

\hypertarget{ux5b8fux5b9aux4e49-6}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-6}}

采用操作符最高两位区分类别的方法定义宏。用把宏定义成宏的方法，定义表中值为宏的宏。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{op} & \texttt{ALU\_ADD} & 5b'00000 & 加法运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_UNSIGNED\_ADD} & \texttt{ALU\_ADD} &
同上\tabularnewline\hline
\texttt{op} & \texttt{ALU\_SUB} & 5b'00001 & 减法运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_UNSIGNED\_SUB} & \texttt{ALU\_SUB} &
同上\tabularnewline\hline
\texttt{op} & \texttt{ALU\_AND} & 5b'10000 & 按位与运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_BITWISE\_AND} & \texttt{ALU\_AND} &
同上\tabularnewline\hline
\texttt{op} & \texttt{ALU\_OR} & 5b'10001 & 按位或运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_BITWISE\_OR} & \texttt{ALU\_OR} &
同上\tabularnewline\hline
\texttt{op} & \texttt{ALU\_NOT} & 5b'10010 & 按位非运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_BITWISE\_NOT} & \texttt{ALU\_NOT} &
同上\tabularnewline\hline
\texttt{op} & \texttt{ALU\_XOR} & 5b'10011 & 按位异或运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_MOVZ} & 5b'00010 &
数据转移运算\textsuperscript{{[}1{]}}\tabularnewline\hline
\texttt{.*comp\_result} & \texttt{ALU\_EQUAL} & 2b'00 &
等于\tabularnewline\hline
\texttt{.*comp\_result} & \texttt{ALU\_EQUAL\_TO} & \texttt{ALU\_EQUAL}
& 同上\tabularnewline\hline
\texttt{.*comp\_result} & \texttt{ALU\_LARGER} & 2b'01 &
大于\tabularnewline\hline
\texttt{.*comp\_result} & \texttt{ALU\_LARGER\_THAN} &
\texttt{ALU\_LARGER} & 同上\tabularnewline\hline
\texttt{.*comp\_result} & \texttt{ALU\_SMALLER} & 2b'10 &
小于\tabularnewline\hline
\texttt{.*comp\_result} & \texttt{ALU\_SMALLER\_THAN} &
\texttt{ALU\_SMALLER} & 同上\tabularnewline\hline
\texttt{overflow} & \texttt{ALU\_OVERFLOW} & 1'b1 & 溢出\tabularnewline\hline
\texttt{overflow} & \texttt{ALU\_NOT\_OVERFLOW} & 1'b0 &
未溢出\tabularnewline\hline
\texttt{op\_invalid} & \texttt{ALU\_INVALID\_OP} & 1'b1 &
操作符无效\tabularnewline\hline
\texttt{op\_invalid} & \texttt{ALU\_INVALID} & \texttt{ALU\_INVALID\_OP}
& 同上\tabularnewline\hline
\texttt{op\_invalid} & \texttt{ALU\_VALID\_OP} & 1'b0 &
操作符有效\tabularnewline\hline
\texttt{op\_invalid} & \texttt{ALU\_VALID} & \texttt{ALU\_VALID\_OP} &
同上\tabularnewline\hline

\end{longtable}

注：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  数据转移运算只是简单地让结果等于第一个操作数，因为真正转不转移是控制模块判断写入哪个寄存器决定的。
\end{enumerate}

\hypertarget{ux529fux80fd-7}{%
\subsection{功能}\label{ux529fux80fd-7}}

若 \texttt{op} 的值为合法操作（即上面``宏定义''一节中列出的操作），按照
\texttt{op} 中给出的操作计算出结果，并把结果放入 \texttt{result}
中。然后把输入的数看成无符号数并比较，若发生上面提到的溢出现象，就令
\texttt{overflow} 为 \texttt{1\textquotesingle{}b1}，否则为
\texttt{1\textquotesingle{}b0}。注意不管 \texttt{num{[}12{]}}
输入的原来意义是什么，都把它看成无符号数进行计算。

检查溢出的方式是用一个 33
位的中间变量，在加减法时用同样的方法算出该中间变量的值。如果有溢出，那它的最高位应该为
1，否则为 0。在做其它运算时，把这个中间变量变为恒 0。

如果 \texttt{op} 的值为非法操作，就令 \texttt{op\_invalid} 为
\texttt{1\textquotesingle{}b1}，否则为
\texttt{1\textquotesingle{}b0}。此时令 \texttt{result} 为
\texttt{32\textquotesingle{}b0}。

\texttt{.*comp\_result} 的值仅由 \texttt{num{[}12{]}}
确定，与其它输入无关。\texttt{.*comp\_result}
的比较方式，在端口定义中。比较的输出结果，在宏定义中。不会输出宏定义中没有定义的结果。

\hypertarget{ux6ce8ux610fux4e8bux9879-4}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-4}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  添加新运算时注意同时改 \texttt{op\_invalid} 的输出和 \texttt{result}
  的输出
\item
  如果不确定符号，就加上 \texttt{{[}un\textbar{}{]}signed}
\end{enumerate}

\hypertarget{ux6570ux636eux5b58ux50a8ux5668}{%
\section{数据存储器}\label{ux6570ux636eux5b58ux50a8ux5668}}

\hypertarget{ux539fux7406-6}{%
\subsection{原理}\label{ux539fux7406-6}}

数据存储器是存储数据的地方。

为了简便，数据存储器由许多寄存器实现。

\hypertarget{ux7aefux53e3ux5b9aux4e49-4}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-4}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & 输入 & 1 & 时钟信号\tabularnewline\hline
\texttt{rst} & 输入 & 1 & 同步复位信号\tabularnewline\hline
\texttt{curr\_pc} & 输入 & 32 & 当前 PC 值\tabularnewline\hline
\texttt{read\_addr} & 输入 & 32 & 读地址\tabularnewline\hline
\texttt{write\_addr} & 输入 & 32 & 写地址\tabularnewline\hline
\texttt{write\_data} & 输入 & 32 & 写数据\tabularnewline\hline
\texttt{write\_enable} & 输入 & 1 & 写使能信号\tabularnewline\hline
\texttt{read\_result} & 输出 & 32 & 读到的结果\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-7}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-7}}

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{write\_enable} & \texttt{DM\_WRITE\_ENABLE} &
\texttt{1\textquotesingle{}b1} & DM 使能\tabularnewline\hline
\texttt{write\_enable} & \texttt{DM\_WRITE\_ENABLED} &
\texttt{DM\_WRITE\_ENABLE} &\tabularnewline\hline
\texttt{write\_enable} & \texttt{DM\_WRITE\_DISABLE} &
\texttt{1\textquotesingle{}b0} & DM 非使能\tabularnewline\hline
\texttt{write\_enable} & \texttt{DM\_WRITE\_DISABLED} &
\texttt{DM\_WRITE\_DISABLE} &\tabularnewline\hline
\texttt{.*\_addr} & \texttt{DM\_ADDR\_WIDTH} & 8 & \texttt{.*\_addr}
的位宽\tabularnewline\hline
指令存储器 & \texttt{DM\_SIZE} & 64 & 能存储字的个数\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-8}{%
\subsection{功能}\label{ux529fux80fd-8}}

该部件为时序部件。

有 \texttt{DM\_SIZE} 个 32 位存储器，代表其中存储的指令。它们初值都为
\texttt{32\textquotesingle{}b0}。

在每个时钟上升沿，若 \texttt{rst == 1'b1}，则进行同步复位。否则，若  \texttt{write\_enable\ ==\ DM\_ENABLED}，则
\texttt{write\_addr{[}\ DM\_ADDR\_WIDTH\ -\ 1:1{]}} 这个地址对应的 32
位字写入 \texttt{write\_data} 对应的值。同时，打印当前的模拟时间、当前 PC
的值、\texttt{write\_addr}、\texttt{write\_addr} 这个地址对应的 32
位字原来的值、它的新值。

任何时候，\texttt{read\_result} 的值为
\texttt{read\_addr{[}DM\_ADDR\_WIDTH\ -\ 1:1{]}} 对应的地址的值。

注意 \texttt{dm} 内部对 \texttt{write\_addr} 和 \texttt{read\_addr}
都截取了一部分。这样可以把 \texttt{dm}
直接接入数据通路，在数据通路中假定地址是 32 位的；同时 \texttt{dm}
的实现不需要那么多寄存器，更现实。但是实际上这样对地址空间进行了限制。

\hypertarget{ux6ce8ux610fux4e8bux9879-5}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-5}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  现在还没有按照半个字或者字节寻址，所以暂时不加入 \texttt{mode} 端口
\item
  直接忽略地址后两位
\item
  \texttt{DM\_ADDR\_WIDTH} 和 \texttt{DM\_ADDR\_SIZE} 要一块改
\item
  地址空间是被截断的，看起来是 32 位，实际上不是
\end{enumerate}

\hypertarget{ux6d41ux6c34ux7ebfux5bc4ux5b58ux5668}{%
\section{流水线寄存器}\label{ux6d41ux6c34ux7ebfux5bc4ux5b58ux5668}}

\hypertarget{ux539fux7406-7}{%
\subsection{原理}\label{ux539fux7406-7}}

流水线中需要很多寄存器来保存中间状态，而直接使用 \texttt{always}
块写，有难以维护的缺点。所以更好的方法是设置流水线寄存器。

\hypertarget{ux7aefux53e3ux5b9aux4e49-5}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-5}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & 输入 & 1 & 时钟信号\tabularnewline\hline
\texttt{enable} & 输入 & 1 & 使能\tabularnewline\hline
\texttt{rst} & 输入 & 1 & 同步复位信号\tabularnewline\hline
\texttt{i} & 输入 & \texttt{BIT\_WIDTH} & 输入的数据\tabularnewline\hline
\texttt{o} & 输出 & \texttt{BIT\_WIDTH} & 输出的数据\tabularnewline\hline

\end{longtable}

\hypertarget{ux53c2ux6570ux5b9aux4e49}{%
\subsection{参数定义}\label{ux53c2ux6570ux5b9aux4e49}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
类别 & 定义 & 默认值 & 意义\tabularnewline\hline

\endhead\hiderowcolors
寄存器位宽 & \texttt{BIT\_WIDTH} & 32 & 寄存器的位宽\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-8}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-8}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{enable} & \texttt{PFF\_ENABLED} & \texttt{1\textquotesingle{}b1}
& 使能\tabularnewline\hline
\texttt{enable} & \texttt{PFF\_DISABLED} &
\texttt{1\textquotesingle{}b0} & 使能\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-9}{%
\subsection{功能}\label{ux529fux80fd-9}}

该部件为时序部件。

该部件内部的寄存器初值为全 0。

每个时钟上升沿，如果
\texttt{rst\ ==\ 1\textquotesingle{}b0}，就令寄存器的值为全
\texttt{0}。否则，如果
\texttt{enable\ ==\ PFF\_ENABLED}，则令寄存器的值为 \texttt{i}
的值。否则寄存器的值不变。

输出端口 \texttt{o} 的值总是寄存器的值。

\hypertarget{ux6ce8ux610fux4e8bux9879-6}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-6}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  复位设成了同步复位，这是为了兼容。
\end{enumerate}

\hypertarget{mux}{%
\section{MUX}\label{mux}}

\hypertarget{ux529fux80fd-10}{%
\subsection{功能}\label{ux529fux80fd-10}}

MUX 是多路选择器的意思，是从多个数据源中选择数据的部件。其实它也是数据通路和控制之间的接口，控制部件通过 MUX 来控制数据的流向，实现指令的功能。

\hypertarget{ux7c7bux522b}{%
\subsection{类别}\label{ux7c7bux522b}}

MUX 有多个类别。有 2 路 MUX、3 路 MUX 以至于多路 MUX。实际上，在单周期
CPU 中只能用到路数比较少的 MUX，多路的 MUX 要等到流水线 CPU
的时候才能用。

\hypertarget{ux547dux540d}{%
\subsection{命名}\label{ux547dux540d}}

由于 MUX 有多个类别，所以它也有多个
\texttt{module}，也有多个命名。\emph{n} 路 MUX 命名为
\texttt{mux}\emph{n}。

\hypertarget{ux5b8fux5b9aux4e49-9}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-9}}

暂无

但是仍然保留 \texttt{mux.h} 宏文件并填入模版，以备以后使用。

\hypertarget{ux53c2ux6570ux5b9aux4e49-1}{%
\subsection{参数定义}\label{ux53c2ux6570ux5b9aux4e49-1}}

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
参数 & 默认值 & 功能\tabularnewline\hline

\endhead\hiderowcolors
\texttt{BIT\_WIDTH} & 32 & 输入和输出数据的位宽\tabularnewline\hline

\end{longtable}

\hypertarget{ux7aefux53e3ux5b9aux4e49-6}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-6}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{control} & 输入 & \emph{见注 1} & 输入控制信号\tabularnewline\hline
\texttt{result} & 输出 & \texttt{BIT\_WIDTH} & 输出数据\tabularnewline\hline
\texttt{input}\emph{n} & 输入 & \texttt{BIT\_WIDTH} & \emph{见注
2}\tabularnewline\hline

\end{longtable}

注：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  输入控制信号的位宽如下计算：有 \emph{n} 个输入信号，就取最小的使
  \emph{2\^{}width} 能够超过 \emph{n} 的 \emph{width}，这就是
  \texttt{control} 的位宽。
\item
  功能是输入端口，但是个数有 \emph{n} 个。输入端口\textbf{从 0
  开始计数}。
\end{enumerate}

\hypertarget{ux529fux80fd-11}{%
\subsection{功能}\label{ux529fux80fd-11}}

若 \texttt{control} 的值为
\emph{width}\texttt{\textquotesingle{}d}\emph{n}，则令 \texttt{result}
的值为 \texttt{input}\emph{n} 的值。但是若 \emph{n} 超出了 MUX
的输入端口个数（即路数）或 \emph{n} 为其它值，则令 \texttt{result}
的值为 \texttt{input0} 的值。

\hypertarget{ux6ce8ux610fux4e8bux9879-7}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-7}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{BIT\_WIDTH} 默认为 32，是因为一般传送的数据都是 32 位的。
\item
  接线时端口顺序\textbf{按照数据通路部分最终总结出来的接线表格中指定的顺序来！}
\item
  \textbf{\emph{n} 为其他值可能是 \texttt{x} 或 \texttt{z}！}
\end{enumerate}

\hypertarget{ux6d41ux6c34ux7ebf-cpu-ux6570ux636eux901aux8def}{%
\section{流水线 CPU
数据通路}\label{ux6d41ux6c34ux7ebf-cpu-ux6570ux636eux901aux8def}}

\hypertarget{ux539fux7406-8}{%
\subsection{原理}\label{ux539fux7406-8}}

流水线技术是通过指令级并行，缩短每级的执行时间从而提高频率的技术。这样可以让关键路径缩短，从而提升频率，因此提高了执行效率。

流水线要注意会出现冒险问题，因此会有暂停和转发机制。暂停和转发实际上是控制的内容，数据通路只需要留出需要的部件即可。

\hypertarget{ux5206ux6790}{%
\subsection{分析}\label{ux5206ux6790}}

p5 需要实现的指令为：

\texttt{addu,\ subu,\ lui,\ ori,\ lw,\ sw,\ beq,\ nop,\ j,\ jal,\ jr}

新加的指令为：

\texttt{movz}

由于不同指令的数据通路可以归类，因此首先需要对数据通路进行分类，之后再对每类数据通路总结连接。数据通路分类表如下。

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{数据通路类型 } & \headingcelllast{指令}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{UNKNOWN} & （未知指令）\tabularnewline\hline
\texttt{CAL\_R} & \texttt{addu,\ subu}\tabularnewline\hline
\texttt{CAL\_I} & \texttt{lui,\ ori}\tabularnewline\hline
\texttt{LOAD} & \texttt{lw}\tabularnewline\hline
\texttt{STORE} & \texttt{sw}\tabularnewline\hline
\texttt{BRANCH} & \texttt{beq}\tabularnewline\hline
\texttt{NOP} & \texttt{nop}\tabularnewline\hline
\texttt{JUMP\_I} & \texttt{j,\ jal}\tabularnewline\hline
\texttt{JUMP\_R} & \texttt{jr}\tabularnewline\hline
\texttt{CMOV} & \texttt{movz}\tabularnewline\hline

\end{longtable}

通过分析它们的
RTL，可以得到每条指令对应的数据通路连接如下。其中表格某一列的值表示这个输入端口是哪个输出端口的输出。端口用
\texttt{流水线级: 部件.端口名字}
格式表示。空白的单元格表示不用关心相对应的端口的值，因为它们会被忽略，不影响指令的正常执行。未知指令只需要屏蔽各个写入的使能，这样就可以避免未知指令的影响，因此不用分析未知指令。

有时部件名称可能和级不对应。这表示相应端口的值是经过流水后的结果。

由于指令分析函数可以分析到指令读写的寄存器，因此把 D 级和 E
级的三个寄存器地址端口交给控制模块控制。这样也能避免在不该写寄存器的指令写寄存器，因为哪怕寄存器写入使能打开，要写入的寄存器也是
\texttt{ZERO}。

\textbf{注意：使用延迟槽来简化暂停和转发的分析。}

\begin{longtable}[]{@{}|l|l|l|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcellmiddle{\texttt{F: npc.curr\_pc}} & \headingcellmiddle{\texttt{F: npc.comp\_result}} & \headingcellmiddle{\texttt{F: npc.num}} \tabularnewline\hline
\endhead\hiderowcolors
\texttt{BRANCH} & \texttt{F: pc.curr\_pc} & \texttt{D: cmp.cmp} & \texttt{D: im.result[15:0]}\tabularnewline\hline
其它 & \texttt{F: pc.curr\_pc} & \texttt{D: cmp.cmp} & --- \tabularnewline\hline
综合 & \texttt{F: pc.curr\_pc} & \texttt{D: cmp.cmp} & \texttt{D: im.result[15:0]} \tabularnewline\hline
\end{longtable}

\begin{longtable}[]{@{}|l|l|l|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcellmiddle{\texttt{F: npc.jnum}} & \headingcellmiddle{\texttt{F: npc.reg\_}} & \headingcellmiddle{\texttt{F: pc.next\_pc}} \tabularnewline\hline
\endhead\hiderowcolors
\texttt{JUMP\_I} & \texttt{D: im.result[25:0]} & --- & \texttt{D: npc.next\_pc} \tabularnewline\hline
\texttt{JUMP\_R} & --- & \texttt{D: rf.read\_result1} & \texttt{D: npc.next\_pc} \tabularnewline\hline
其它 & --- & --- & \texttt{D: npc.next\_pc} \tabularnewline\hline
综合 & \texttt{D: im.result[25:0]} & \texttt{D: rf.read\_result1} & \texttt{D: npc.next\_pc} \tabularnewline\hline
\end{longtable}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcellmiddle{\texttt{D: ext.num}} & \headingcellmiddle{\texttt{D: cmp.reg1}} & \headingcelllast{\texttt{D: cmp.reg2}} \tabularnewline\hline
\endhead\hiderowcolors
\texttt{CAL\_I} & \texttt{D: im.result[15:0]} & --- & --- \tabularnewline\hline
\texttt{LOAD} & \texttt{D: im.result[15:0]} & --- & --- \tabularnewline\hline
\texttt{STORE} & \texttt{D: im.result[15:0]} & --- & --- \tabularnewline\hline
\texttt{BRANCH} & --- & \makecell{\texttt{D: rf.}\\\texttt{read\_result1}} & \makecell{\texttt{D: rf.}\\\texttt{read\_result2}} \tabularnewline\hline
其它 & --- & --- & --- \tabularnewline\hline
综合 & \texttt{D: im.result[15:0]} & \makecell{\texttt{D: rf.}\\\texttt{read\_result1}} & \makecell{\texttt{D: rf.}\\\texttt{read\_result2}} \tabularnewline\hline
\end{longtable}

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcellmiddle{\texttt{E: alu.num1}} & \headingcelllast{\texttt{E: alu.num2}} \tabularnewline\hline
\endhead\hiderowcolors
\texttt{CAL\_R} & \texttt{D: rf.read\_result1} & \texttt{D: rf.read\_result2} \tabularnewline\hline
\texttt{CAL\_I} & \texttt{D: rf.read\_result1} & \texttt{D: ext.result} \tabularnewline\hline
\texttt{LOAD} & \texttt{D: rf.read\_result1} & \texttt{D: ext.result} \tabularnewline\hline
\texttt{STORE} & \texttt{D: rf.read\_result1} & \texttt{D: ext.result} \tabularnewline\hline
\texttt{CMOV} & \texttt{D: rf.read\_result1} & \texttt{D: rf.read\_result2} \tabularnewline\hline
其它 & --- & --- \tabularnewline\hline
综合 & \texttt{D: rf.read\_result1} & \makecell{\texttt{D: rf.read\_result2}\\\texttt{D: ext.result}} \tabularnewline\hline
\end{longtable}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcellmiddle{\texttt{M: dm.read\_addr}} & \headingcellmiddle{\texttt{M: dm.write\_addr}} & \headingcelllast{\texttt{M: dm.write\_data}} \tabularnewline\hline 
\endhead\hiderowcolors
\texttt{LOAD} & \texttt{E: alu.result} & --- & --- \tabularnewline\hline
\texttt{STORE} & --- & \texttt{E: alu.result} & \texttt{E: rf.read\_result2} \tabularnewline\hline
其它 & --- & --- & --- \tabularnewline\hline
综合 & \texttt{E: alu.result} & \texttt{E: alu.result} & \texttt{E: rf.read\_result2} \tabularnewline\hline
\end{longtable}

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcelllast{W: rf.write\_data} \tabularnewline\hline
\endhead\hiderowcolors
\texttt{CAL\_R} & \texttt{E: alu.result} \tabularnewline\hline
\texttt{CAL\_I} & \texttt{E: alu.result} \tabularnewline\hline
\texttt{LOAD} & \texttt{M: dm.read\_result} \tabularnewline\hline
\texttt{JUMP\_I} & \texttt{\$unsigned(pc.curr\_pc) + \$unsigned(8)} \tabularnewline\hline
\texttt{CMOV} & \texttt{E: alu.result} \tabularnewline\hline
其它 & --- \tabularnewline\hline
综合 & \makecell{\texttt{E: alu.result}\\\texttt{M: dm.read\_result}\\\texttt{\$unsigned(pc.curr\_pc) + \$unsigned(8)}} \tabularnewline\hline
\end{longtable}
\hypertarget{ux6d41ux6c34ux7ebfux5bc4ux5b58ux5668-1}{%
\paragraph{流水线寄存器}\label{ux6d41ux6c34ux7ebfux5bc4ux5b58ux5668-1}}

由于流水线需要保存每一级流水线的执行结果，所以需要流水线寄存器。需要保存的执行结果，可以从上面数据通路表格中综合出来。为了方便和上面的表格对应，每一级流水线的流水线寄存器都保存上一级流水线的数据。

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
流水线级 & 信号 & 流水线寄存器名称\tabularnewline\hline

\endhead\hiderowcolors
D & \texttt{im.result} & \texttt{d\_im}\tabularnewline\hline
E & \texttt{rf.read\_result1} & \texttt{e\_reg1}\tabularnewline\hline
E & \texttt{rf.read\_result2} & \texttt{e\_reg2}\tabularnewline\hline
E & \texttt{ext.result} & \texttt{e\_ext}\tabularnewline\hline
M & \texttt{alu.result} & \texttt{m\_alu}\tabularnewline\hline
M & \texttt{rf.read\_result2} & \texttt{m\_reg2}\tabularnewline\hline
W & \texttt{alu.result} & \texttt{w\_alu}\tabularnewline\hline
W & \texttt{dm.read\_result} & \texttt{w\_dm}\tabularnewline\hline
W & \texttt{pc.curr\_pc} & \texttt{w\_pc}\tabularnewline\hline

\end{longtable}

由于需要的流水线寄存器有跨级的（比如只有 D 级和 W
级），所以需要把漏掉的级补充上。

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
流水线级 & 信号 & 流水线寄存器名称\tabularnewline\hline

\endhead\hiderowcolors
D & \texttt{pc.curr\_pc} & \texttt{d\_pc}\tabularnewline\hline
E & \texttt{pc.curr\_pc} & \texttt{e\_pc}\tabularnewline\hline
M & \texttt{pc.curr\_pc} & \texttt{m\_pc}\tabularnewline\hline

\end{longtable}

这里没有补充 D 级 \texttt{BRANCH} 类指令需要的 \texttt{alu.comp\_result}
到 F 级的连接以及 \texttt{JUMP\_R} 和 \texttt{JUMP\_I} 类指令相应数据到 F
级的连接，因为为了正确控制 PC
的转换，它们必须是直接连接的，不需要流水线寄存器。

注意：\textbf{返回 \texttt{PC\ +\ 8} 实际上是通过流水 \texttt{PC} 再加 8
实现的。}

注意：\textbf{D 级流水线寄存器都要接使能信号，E
级流水线寄存器都要接复位信号，因为要插入气泡。}

\hypertarget{ux6570ux636eux901aux8def-mux}{%
\paragraph{数据通路 MUX}\label{ux6570ux636eux901aux8def-mux}}

最后是把所有可能的连接综合起来以后，得到的结果。如果有多个可能的连接，就需要一个
MUX。把 MUX 的输出端口连接在相应的输入端口上，MUX
的输入端口要保证所有可能的输入端口都能连接上。

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
端口 & 所有的信号来源 & MUX 名称\tabularnewline\hline

\endhead\hiderowcolors
\texttt{E:\ alu.num2} & \makecell{\texttt{D:\ rf.read\_result2}\\\texttt{D:\ ext.result}} &
\texttt{m\_alusrc}\tabularnewline\hline
\texttt{W:\ rf.write\_data} &
\makecell{（无）\\\texttt{E:\ alu.result}\\\texttt{M:\ dm.read\_result}\\\texttt{D:\ npc.next\_pc}}
& \texttt{m\_regdata}\tabularnewline\hline

\end{longtable}

注意：\textbf{都是把信号来源从 0 开始编号，对应 MUX 的
\texttt{input}\emph{n} 接第 \emph{n} 个信号源。}

注意：\textbf{如果写了（无），那么相应端口的数据为全
0，不过这时相应端口实际上也没有作用。}

\hypertarget{ux8f6cux53d1}{%
\paragraph{转发}\label{ux8f6cux53d1}}

需要转发是因为可能出现后面的指令需要使用前面的指令的结果，而前面的指令结果来不及写回（数据冒险）的情况。由于同一个时钟周期只有一条指令读写 \texttt{dm}，所以 \texttt{dm} 不需要转发。但是 \texttt{rf} 在同一个时钟周期内一般会有多条指令读写，所以 \texttt{rf} 需要转发。

转发的原则就是比较新的指令需要读的寄存器和比较老的指令需要写的寄存器一样。对这个条件的判断，在指令识别函数中已经有了。注意一条指令最多读
2 个寄存器，所以要判断 2 次。

转发是通过转发 MUX
来更改数据通路上寄存器的值，从而达到提前更新的目的。首先，数据通路上有寄存器值的地方，一共有五处：\texttt{D:\ rf.read\_result1,\ D:\ rf.read\_result2,\ E:\ rf.read\_result1,\ E:\ rf.read\_result2,\ M:\ dm.write\_data}。其中
E
级的两处是通过流水线寄存器暂存的。这五处可以分三类。对每类需要构造的转发
MUX 总结如下。

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
端口 & 所有的信号来源 & MUX 名称\tabularnewline\hline

\endhead\hiderowcolors
\texttt{D:\ rf.read\_result{[}12{]}} &
\makecell{\texttt{E:\ rf.read\_result1}\\\texttt{E:\ npc.next\_pc}\\\texttt{M:\ npc.next\_pc}\\\texttt{M:\ alu.result}\\\texttt{W:\ rf.write\_data}}
& \texttt{fm\_d1}\tabularnewline\hline
\texttt{E:\ rf.read\_result{[}12{]}} &
\makecell{\texttt{M:\ npc.next\_pc}\\\texttt{M:\ alu.result}\\\texttt{W:\ rf.write\_data}} &
\texttt{fm\_e1}\tabularnewline\hline
\texttt{M:\ dm.write\_data} & \texttt{W:\ rf.write\_data} &
\texttt{fm\_m}\tabularnewline\hline

\end{longtable}

注意：\textbf{不能在 M 级设置 MUX 转发 \texttt{dm} 的数据，因为这样 D
级或 E 级会等待 M 级 \texttt{dm}
的数据，关键路径会变得非常长，极大地降低流水线性能。同样地，也不能在 E
级设置 MUX 转发 \texttt{alu} 的数据。总之，某个功能部件出来的数据不能直接转发。}

转发 MUX
最终是由控制模块控制的。但是控制模块也没法克服有些数据通路不能转发的现实（比如
\texttt{M:\ dm.read\_result}）。这就需要------

\hypertarget{ux6682ux505c}{%
\paragraph{暂停}\label{ux6682ux505c}}

需要暂停是因为有些数据冒险靠转发解决不了，必须要让后面的指令暂停一个时钟周期。暂停的方式是在流水线中插入一个
NOP（这时候也叫气泡），从而让发生数据冒险的指令能够转发。

流水线 CPU 数据通路中能提供的暂停机制有锁定 \texttt{pc} 和清空 E
级各个流水线寄存器。这样就可以在流水线 E 级插入气泡。清空 E
级各个寄存器是通过流水线寄存器的同步复位功能实现的。

\hypertarget{ux6307ux4ee4ux8bc6ux522bux673aux5236}{%
\section{指令识别机制}\label{ux6307ux4ee4ux8bc6ux522bux673aux5236}}

\hypertarget{ux539fux7406-9}{%
\subsection{原理}\label{ux539fux7406-9}}

指令识别机制是为了判断指令的功能而设计的。它可以实现判断指令的具体类型、数据通路类型、需要的控制信号等功能。用这些函数识别出来的数据，就可以判断指令的数据流、转发和暂停相关信息和异常相关信息等。

\hypertarget{ux5b8fux5b9aux4e49-10}{%
\paragraph{宏定义}\label{ux5b8fux5b9aux4e49-10}}

由于有特殊的指令读写固定的寄存器，所以寄存器号也要宏定义。

由于函数的声明需要一定的范式保证健壮性，所以函数的声明本身也要定义。

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
寄存器号 & \texttt{ZERO} & \texttt{5\textquotesingle{}d0} & 0
号寄存器（或者表示某指令在某函数下对应的寄存器不存在）\tabularnewline\hline
寄存器号 & \texttt{NULL} & \texttt{ZERO} &\tabularnewline\hline
寄存器号 & \texttt{RA} & \texttt{5\textquotesingle{}d31} & 31
号寄存器（\texttt{\$ra}，\texttt{jal} 指令要写入）\tabularnewline\hline
\end{longtable}

\hypertarget{ux7aefux53e3ux5b9aux4e49-7}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-7}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能} \tabularnewline\hline
\endhead\hiderowcolors
\texttt{instr} & 输入 & 32 & 要分析的指令 \tabularnewline\hline
\texttt{kind} & 输出 & 9 & 当前指令的具体类型 \tabularnewline\hline
\end{longtable}

\hypertarget{ux529fux80fd-12}{%
\subsection{功能}\label{ux529fux80fd-12}}

获取当前指令的具体类型。返回的结果一共 9 位，前 4 位是数据通路类型，后 5 位是具体类型。

若指令的格式符合 MIPS
指令集中的相应格式，则返回对应指令的代码（在宏定义一节中描述）。否则，返回
0。

\hypertarget{ux5b8fux5b9aux4e49-11}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-11}}

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

编码方式为前 4 位为数据通路类型，后 5 位为其下的具体类型。

指令的意义在表示相应指令的情况下省略不写。但如果有相应备注，也会在这栏注明。

\hypertarget{ux6307ux4ee4ux5b57ux6bb5}{%
\subparagraph{指令字段}\label{ux6307ux4ee4ux5b57ux6bb5}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
指令字段 & \texttt{OP(x)} & \texttt{(x{[}31:26{]})} & 指令的 \texttt{op}
字段\tabularnewline\hline
指令字段 & \texttt{RS(x)} & \texttt{(x{[}25:21{]})} & 指令的 \texttt{rs}
字段\tabularnewline\hline
指令字段 & \texttt{RT(x)} & \texttt{(x{[}20:16{]})} & 指令的 \texttt{rt}
字段\tabularnewline\hline
指令字段 & \texttt{RD(x)} & \texttt{(x{[}15:11{]})} & 指令的 \texttt{rd}
字段\tabularnewline\hline
指令字段 & \texttt{SHAMT(x)} & \texttt{(x{[}10:6{]})} & 指令的
\texttt{shamt} 字段\tabularnewline\hline
指令字段 & \texttt{FUNCT(x)} & \texttt{(x{[}5:0{]})} & 指令的
\texttt{funct} 字段\tabularnewline\hline
指令字段 & \texttt{IMM(x)} & \texttt{(x{[}15:0{]})} & 指令的
\texttt{imm} 字段\tabularnewline\hline
指令字段 & \texttt{IMM\_J(x)} & \texttt{(x{[}25:0{]})} & \texttt{j}
指令的 \texttt{imm} 字段\tabularnewline\hline

\end{longtable}

\hypertarget{ux6307ux4ee4ux7c7bux578b}{%
\subparagraph{指令类型}\label{ux6307ux4ee4ux7c7bux578b}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
指令类型 & \texttt{UNKNOWN} & \texttt{9\textquotesingle{}b0000\_00000} &
未知指令\tabularnewline\hline
指令类型 & \texttt{UNK} & \texttt{UNKNOWN} &\tabularnewline\hline
指令类型 & \texttt{ADDU} & \texttt{9\textquotesingle{}b0001\_00000}
&\tabularnewline\hline
指令类型 & \texttt{SUBU} & \texttt{9\textquotesingle{}b0001\_00001}
&\tabularnewline\hline
指令类型 & \texttt{LUI} & \texttt{9\textquotesingle{}b0010\_00000}
&\tabularnewline\hline
指令类型 & \texttt{ORI} & \texttt{9\textquotesingle{}b0010\_00001}
&\tabularnewline\hline
指令类型 & \texttt{LW} & \texttt{9\textquotesingle{}b0011\_00000}
&\tabularnewline\hline
指令类型 & \texttt{SW} & \texttt{9\textquotesingle{}b0100\_00000}
&\tabularnewline\hline
指令类型 & \texttt{BEQ} & \texttt{9\textquotesingle{}b0101\_00000}
&\tabularnewline\hline
指令类型 & \texttt{J} & \texttt{9\textquotesingle{}b0110\_00000}
&\tabularnewline\hline
指令类型 & \texttt{JAL} & \texttt{9\textquotesingle{}b0110\_00001}
&\tabularnewline\hline
指令类型 & \texttt{JR} & \texttt{9\textquotesingle{}b0111\_00000}
&\tabularnewline\hline
指令类型 & \texttt{MOVZ} & \texttt{9\textquotesingle{}b1000\_00000}
&\tabularnewline\hline
指令类型 & \texttt{NOP} & \texttt{9\textquotesingle{}b1111\_00000} &
\makecell{\texttt{nop} 指令是 \texttt{sll} 指令的\\一个特例，所以临时开一栏，\\在扩充指令时会去掉这一类}\tabularnewline\hline

\end{longtable}

\hypertarget{ux6ce8ux610f}{%
\subsection{注意}\label{ux6ce8ux610f}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  临时的数据通路类型都是从上往下编号的。
\end{enumerate}

\hypertarget{ux63a7ux5236}{%
\section{控制}\label{ux63a7ux5236}}

\hypertarget{ux539fux7406-10}{%
\subsection{原理}\label{ux539fux7406-10}}

控制是指通过识别指令，控制数据的流通，从而让 CPU
执行指定的计算的过程。数据通路只是得到了数据可能的流向，真正要控制还是控制完成。控制通过已有的控制信号和数据通路的分叉完成控制。

在流水线 CPU
中，由于存在结构冒险和数据冒险，所以需要通过暂停和转发解决。暂停控制和转发控制可以放在单独的控制模块中，从而不影响原来单周期时的控制模块。通过指令识别，可以分析指令，做到有效的暂停和转发。

\hypertarget{ux7aefux53e3ux5b9aux4e49-8}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-8}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & 输入 & 1 & 时钟信号\tabularnewline\hline
\texttt{d\_instr} & 输入 & 32 & 当前在 D 级（ID）的指令\tabularnewline\hline
\texttt{rf\_read\_result2} & 输入 & 32 & \texttt{rf} 的 2
号读取结果\tabularnewline\hline
\texttt{cw\_f\_pc\_enable} & 输出 & 1 & 控制 \texttt{pc}
使能\tabularnewline\hline
\texttt{cw\_d\_pff\_enable} & 输出 & 1 & 控制 D
级流水线寄存器使能\tabularnewline\hline
\texttt{cw\_e\_pff\_rst} & 输出 & 1 & 控制 E
级流水线寄存器复位\tabularnewline\hline
\texttt{cw\_f\_npc\_jump\_mode} & 输出 & 3 & 控制 \texttt{npc}
的跳转模式\tabularnewline\hline
\texttt{cw\_d\_ext\_mode} & 输出 & 3 & 控制
\texttt{D:\ ext.mode}\tabularnewline\hline
\texttt{cw\_d\_rf\_read\_addr1} & 输出 & 5 & 控制
\texttt{D:\ rf.read\_addr1}\tabularnewline\hline
\texttt{cw\_d\_rf\_read\_addr2} & 输出 & 5 & 控制
\texttt{D:\ rf.read\_addr2}\tabularnewline\hline
\texttt{cw\_e\_m\_alusrc} & 输出 & 1 & 控制
\texttt{E:\ m\_alu\_num2}\tabularnewline\hline
\texttt{cw\_e\_alu\_op} & 输出 & 5 & 控制
\texttt{E:\ alu.op}\tabularnewline\hline
\texttt{cw\_m\_dm\_write\_enable} & 输出 & 1 & 控制
\texttt{M:\ dm.write\_enable}\tabularnewline\hline
\texttt{cw\_w\_rf\_write\_enable} & 输出 & 1 & 控制
\texttt{W:\ rf.write\_enable}\tabularnewline\hline
\texttt{cw\_w\_m\_regdata} & 输出 & 3 & 控制
\texttt{W:\ m\_rf\_write\_data}\tabularnewline\hline
\texttt{cw\_w\_rf\_write\_addr} & 输出 & 5 & 控制
\texttt{W:\ rf.write\_addr}\tabularnewline\hline
\texttt{cw\_fm\_d{[}12{]}} & 输出 & 3 & 控制
\texttt{fm\_d{[}12{]}}\tabularnewline\hline
\texttt{cw\_fm\_e{[}12{]}} & 输出 & 3 & 控制
\texttt{fm\_e{[}12{]}}\tabularnewline\hline
\texttt{cw\_fm\_m} & 输出 & 3 & 控制 \texttt{fm\_w}\tabularnewline\hline

\end{longtable}

\hypertarget{ux603bux4f53ux7ed3ux6784}{%
\subsection{总体结构}\label{ux603bux4f53ux7ed3ux6784}}

控制模块是时序部件。不设置成组合逻辑部件的原因如下。

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  哪怕控制本身不设置成时序部件，也需要流水控制信号，这是流水线 CPU
  结构上的需要。
\item
  控制本身是时序部件，就可以流水更多的信息。最明显的就是指令读写寄存器的信息。比如暴力转发也把指令读写寄存器的信息放在流水线中流水。
\item
  保留单周期处理器的控制机制实际上过渡不是那么平滑，因为还有多周期处理器，它的控制是类似状态机的结构。
\end{enumerate}

控制模块在内部流水指令，从而做到比较有效的控制信号发射和数据冒险分析。负责控制信号发射的部分是纯组合逻辑，用函数实现。

同时，控制模块也在内部流水指令需要读取和写入的三个寄存器。因为流水线 CPU
和单周期 CPU
逻辑上应该一样，所以一条指令需要读取和写入的三个寄存器可以直接判断出来，并且流水。这样也可以更方便地处理数据冒险。

\hypertarget{ux6570ux636eux901aux8defux548cux529fux80fdux63a7ux5236ux4fe1ux53f7}{%
\subsection{数据通路和功能控制信号}\label{ux6570ux636eux901aux8defux548cux529fux80fdux63a7ux5236ux4fe1ux53f7}}

由于指令的数据通路可以分成几个类型，每种类型中需要的数据通路是一样的，只是某些控制信号不同。而且，流水线是分级的，所以每级控制数据通路形状的信号可以单独列表。

但是，不同的具体指令对不同部件的某些具体操作不同。比如 \texttt{CAL\_R}
类指令对 ALU
的具体操作就不同。因此，对这些控制具体操作的信号，需要单独列表。

通过对数据通路形状的分析，可以得到每种数据通路类型需要的控制信号如下。其中表格某一单元格的值有两种情况：若该单元格所在的行最左边的单元格是
MUX，则说明对应的指令需要让该 MUX
的输入端口接入该单元格表示的端口；若该单元格所在的行最左边的单元格是端口，则说明对应的指令需要的控制信号为该单元格表示的控制信号。

若单元格以 \texttt{\#}
开头，则说明该控制信号或端口只是为了使控制单元功能明晰而加上的，实际上并不需要关心该控制信号或要接入的端口的值。如果想理解该单元格的值，去掉
\texttt{\#} 再按照上一段理解即可。

\hypertarget{f-ux7ea7if-1}{%
\paragraph{F 级（IF）}\label{f-ux7ea7id-1}}

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcelllast{\texttt{F:\ npc.jump\_mode}}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{BRANCH} & 视具体指令而定\tabularnewline\hline
\texttt{JUMP\_I} & \texttt{NPC\_J}\tabularnewline\hline
\texttt{JUMP\_R} & \texttt{NPC\_REG}\tabularnewline\hline
（其它） & \texttt{NPC\_JUMP\_DISABLED}\tabularnewline\hline

\end{longtable}

\texttt{BRANCH} 类指令类型与 \texttt{F:\ npc.jump\_mode} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{指令类型} & \headingcelllast{\texttt{F:\ npc.jump\_mode}}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{BEQ} & \texttt{NPC\_JUMP\_WHEN\_EQUAL}\tabularnewline\hline

\end{longtable}

注意：\textbf{F 级的控制信号是由 D 级指令控制的。}

\hypertarget{d-ux7ea7id-1}{%
\paragraph{D 级（ID）}\label{d-ux7ea7id-1}}

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcelllast{\texttt{D:\ ext.mode}}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{CAL\_I} & 视具体指令而定\tabularnewline\hline
\texttt{LOAD} & \texttt{EXT\_MODE\_SIGNED}\tabularnewline\hline
\texttt{STORE} & \texttt{EXT\_MODE\_SIGNED}\tabularnewline\hline
（其它） & \texttt{\#EXT\_MODE\_SIGNED}\tabularnewline\hline

\end{longtable}

\texttt{CAL\_I} 类指令类型与 \texttt{D:\ ext.mode} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{指令类型} & \headingcelllast{\texttt{D:\ ext.mode}}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{LUI} & \texttt{EXT\_MODE\_PAD}\tabularnewline\hline
\texttt{ORI} & \texttt{EXT\_MODE\_UNSIGNED}\tabularnewline\hline

\end{longtable}

\hypertarget{e-ux7ea7ex-1}{%
\paragraph{E 级（EX）}\label{e-ux7ea7ex-1}}

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcellmiddle{\texttt{E:\ m\_alusrc}} &
\headingcelllast{\texttt{E:\ alu.op}} \tabularnewline\hline

\endhead\hiderowcolors
\texttt{CAL\_R} & \texttt{D:\ rf.read\_result2} &
视具体指令而定\tabularnewline\hline
\texttt{CAL\_I} & \texttt{D:\ ext.result} &
视具体指令而定\tabularnewline\hline
\texttt{LOAD} & \texttt{D:\ ext.result} &
\texttt{ALU\_ADD}\tabularnewline\hline
\texttt{STORE} & \texttt{D:\ ext.result} &
\texttt{ALU\_ADD}\tabularnewline\hline
\texttt{BRANCH} & \texttt{D:\ rf.read\_result2} &
\texttt{\#ALU\_OR}\tabularnewline\hline
\texttt{CMOV} & \texttt{D:\ rf.read\_result2} &
视具体指令而定\tabularnewline\hline
（其它） & \texttt{\#D:\ rf.read\_result2} &
\texttt{\#ALU\_OR}\tabularnewline\hline

\end{longtable}

\texttt{CAL\_R} 类指令类型与 \texttt{E:\ alu.op} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{指令类型} & \headingcelllast{\texttt{E:\ alu.op}} \tabularnewline\hline

\endhead\hiderowcolors
\texttt{ADDU} & \texttt{ALU\_ADD}\tabularnewline\hline
\texttt{SUBU} & \texttt{ALU\_SUB}\tabularnewline\hline

\end{longtable}

\texttt{CAL\_I} 类指令类型与 \texttt{E:\ alu.op} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{指令类型} & \headingcelllast{\texttt{E:\ alu.op}} \tabularnewline\hline

\endhead\hiderowcolors
\texttt{LUI} & \texttt{ALU\_OR}\tabularnewline\hline
\texttt{ORI} & \texttt{ALU\_OR}\tabularnewline\hline

\end{longtable}

\texttt{CMOV} 类指令类型与 \texttt{E:\ alu.op} 的关系

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{指令类型} & \headingcelllast{\texttt{E:\ alu.op}} \tabularnewline\hline

\endhead\hiderowcolors
\texttt{MOVZ} & \texttt{ALU\_CMOV}\tabularnewline\hline

\end{longtable}

\hypertarget{m-ux7ea7mem-1}{%
\paragraph{M 级（MEM）}\label{m-ux7ea7mem-1}}

\begin{longtable}[]{@{}|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcelllast{\texttt{M:\ dm.write\_enable}}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{STORE} & \texttt{1\textquotesingle{}b1}\tabularnewline\hline
（其它） & \texttt{1\textquotesingle{}b0}\tabularnewline\hline

\end{longtable}

\hypertarget{w-ux7ea7wb-1}{%
\paragraph{W 级（WB）}\label{w-ux7ea7wb-1}}

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcellmiddle{\texttt{W:\ rf.write\_enable}} &
\headingcelllast{\texttt{W:\ m\_regdata}} \tabularnewline\hline

\endhead\hiderowcolors
\texttt{CAL\_R} & \texttt{1\textquotesingle{}b1} &
\texttt{E:\ alu.result}\tabularnewline\hline
\texttt{CAL\_I} & \texttt{1\textquotesingle{}b1} &
\texttt{E:\ alu.result}\tabularnewline\hline
\texttt{LOAD} & \texttt{1\textquotesingle{}b1} &
\texttt{E:\ dm.read\_result}\tabularnewline\hline
\texttt{JUMP} & \texttt{1\textquotesingle{}b1} &
\texttt{D:\ npc.next\_pc}\tabularnewline\hline
\texttt{CMOV} & \texttt{1\textquotesingle{}b1} &
\texttt{E:\ alu.result}\tabularnewline\hline
（其它） & \texttt{1\textquotesingle{}b0} &
\texttt{\#E:\ alu.result}\tabularnewline\hline

\end{longtable}

\hypertarget{ux6d41ux6c34ux7684ux5185ux5bb9}{%
\paragraph{流水的内容}\label{ux6d41ux6c34ux7684ux5185ux5bb9}}

流水 E 级、M 级、W 级指令及其要读的两个寄存器和要写的一个寄存器。不流水
D 级指令是为了配合暂停机制，D 级一被暂停，D
级指令只在组合逻辑跟着变化，不需要再在控制模块里改变 D 级指令的值。

\hypertarget{ux6307ux4ee4ux8bfbux5199ux5bc4ux5b58ux5668ux8bc6ux522b}{%
\paragraph{指令读写寄存器识别}\label{ux6307ux4ee4ux8bfbux5199ux5bc4ux5b58ux5668ux8bc6ux522b}}

比较显然的一点是数据通路类型决定指令要读写的寄存器号。所以，可以直接用取指令字段的宏来完成。

数据通路类型和指令读写寄存器的关系如下。如果指令不读写哪个寄存器，就用
\texttt{ZERO} 替换，因为 \texttt{ZERO}
不参与转发。这样，对转发正确性也没有影响。其中使用的获取指令字段的宏隐含着用要分析的指令作为参数。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
数据通路类型 & \texttt{reg1} & \texttt{reg2} &
\texttt{regw}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{CAL\_R} & \texttt{RS} & \texttt{RT} & \texttt{RD}\tabularnewline\hline
\texttt{CAL\_I} & \texttt{RS} & \texttt{RT} & \texttt{RT}\tabularnewline\hline
\texttt{LOAD} & \texttt{RS} & \texttt{ZERO} & \texttt{RT}\tabularnewline\hline
\texttt{STORE} & \texttt{RS} & \texttt{RT} &
\texttt{ZERO}\tabularnewline\hline
\texttt{BRANCH} & \texttt{RS} & \texttt{RT} &
\texttt{ZERO}\tabularnewline\hline
\texttt{JUMP} & \texttt{ZERO} & \texttt{ZERO} &
视指令而定\textsuperscript{[2]}\tabularnewline\hline
\texttt{JUMPR} & \texttt{RS} & \texttt{ZERO} &
\texttt{ZERO}\tabularnewline\hline
\texttt{CMOV} & \texttt{RS} & \texttt{RT} &
视寄存器值而定\textsuperscript{[1]}\tabularnewline\hline
\texttt{NOP} & \texttt{ZERO} & \texttt{ZERO} &
\texttt{ZERO}\tabularnewline\hline
（其它） & \texttt{ZERO} & \texttt{ZERO} & \texttt{ZERO}\tabularnewline\hline

\end{longtable}

注：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  有一点就是 \texttt{CMOV}
  类指令。这类指令的一种实现是无条件把要写入的数据看成是 \texttt{\$rs}
  的值，但是\textbf{改变要写入的寄存器号}。如果
  \texttt{\$rt\ ==\ 32\textquotesingle{}b0}，就写入
  \texttt{\$rd}，否则写入
  \texttt{\$0\ /\ ZERO}。这样，加上把要读写的寄存器号流水的机制，能保证
  \texttt{CMOV} 类指令的数据冒险处理不出错。哪怕在 W 级打开了
  \texttt{rf} 的写使能，写入 \texttt{\$0} 也没有影响。
\item
  \texttt{JUMP\_I} 类指令若为 \texttt{jal}，则 \texttt{regw\ ==\ RA}。若为
  \texttt{j}，则 \texttt{regw\ ==\ ZERO}。
\end{enumerate}

\hypertarget{ux8f6cux53d1ux63a7ux5236ux4fe1ux53f7}{%
\subsection{转发控制信号}\label{ux8f6cux53d1ux63a7ux5236ux4fe1ux53f7}}

由于流水线 CPU
中存在数据冒险，所以需要转发。由于有了指令识别函数，所以转发是非常抽象的，只需要判断涉及的寄存器号。而且只有两个级是转发的接收端（数据的需求者），因此可以在某一级的角度，一级一级往后排查。

注意：\textbf{先检查较新级的数据冒险，再检查较老级的，因为 \texttt{rf} 中的内容最终还是较新级的。}

对 D 级，先检查 E 级，再检查 M 级，再检查 W 级。对 E 级的寄存器，先检查
M 级，再检查 W 级。这样就能保证转发的完整性。

转发控制信号最终需要控制的是转发 MUX，因此转发 MUX 也要进行定义。

下表是所有转发的情况和具体的描述。意义中说的数据通路类型，都是源指令的数据通路类型。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
所有转发 MUX & \texttt{orig} & \texttt{0} &
不转发，保持原样\tabularnewline\hline
\texttt{fm\_d{[}12{]}} & \texttt{E2D\_rf} & \texttt{1} & \makecell{E 级到 D 级，数据通路类型是 \texttt{CMOV}，\\要写入的数据在 D 级产生好了，到了 E 级才能转发}\tabularnewline\hline
\texttt{fm\_d{[}12{]}} & \texttt{E2D\_npc} & \texttt{2} & \makecell{E 级到 D 级，数据通路类型是 \texttt{JUMP\_I}，\\要写入的数据在 D 级产生好了，到了 E 级才能转发}\tabularnewline\hline
\texttt{fm\_d{[}12{]}} & \texttt{M2D\_npc} & \texttt{3} & M 级到 D
级，之后同上\tabularnewline\hline
\texttt{fm\_d{[}12{]}} & \texttt{M2D\_alu} & \texttt{4} & \makecell{M 级到 D 级，数据通路类型是 \texttt{CAL\_R\ /\ CAL\_I\ /\ CMOV}，\\数据在 D 级或 E 级产生好了，\\但对 \texttt{CAL\_R\ /\ CAL\_I} 来说，到了 M 级才能转发}\tabularnewline\hline
\texttt{fm\_d{[}12{]}} & \texttt{W2D\_rf} & \texttt{5} & \makecell{W 级到 D 级，数据通路类型是所有能够写入寄存器的类型，\\数据在 W 级都可以转发了}\tabularnewline\hline
\texttt{fm\_e{[}12{]}} & \texttt{M2E\_npc} & \texttt{1} & \makecell{M 级到 E 级，数据通路类型是 \texttt{JUMP\_I}，\\要写入的数据在 D 级产生好了，到了 E 级才能转发}\tabularnewline\hline
\texttt{fm\_e{[}12{]}} & \texttt{M2E\_alu} & \texttt{2} & \makecell{M 级到 E 级，数据通路类型是 \texttt{CAL\_R\ /\ CAL\_I\ /\ CMOV}，\\数据在 D 级或 E 级产生好了，但对 \texttt{CAL\_R\ /\ CAL\_I} 来说，\\到了 M 级才能转发}\tabularnewline\hline
\texttt{fm\_e{[}12{]}} & \texttt{W2E\_rf} & \texttt{3} & \makecell{W 级到 D 级，数据通路类型是所有能够写入寄存器的类型，\\数据在 W 级都可以转发了}\tabularnewline\hline
\texttt{fm\_m} & \texttt{W2M\_rf} & \texttt{1} & \makecell{W 级到 M 级，数据通路类型是所有能够写入寄存器的类型，\\数据在 W 级都可以转发了（比如 \texttt{sw} 指令转发 \texttt{rf} 内容）}\tabularnewline\hline

\end{longtable}

注意：\textbf{\texttt{B2A\_.*} 表示 B 级从 A 级转发。}

注意：\textbf{宏的值要和对应转发 MUX 的接线顺序相符。}

注意：\textbf{\texttt{E2D\_rf} 表示把 E 级的第一个寄存器转发出去。}

注意：\textbf{\texttt{fm\_m}
检查的是要读取的第二个寄存器，因为现在用到的所有写入内存的指令，要写入内存的数据都与相应指令第二个寄存器的读取结果对应。以后甚至可能加上检查要读取的第一个寄存器，不过就要根据指令类型判断了。}

\hypertarget{ux6682ux505cux63a7ux5236ux4fe1ux53f7}{%
\subsection{暂停控制信号}\label{ux6682ux505cux63a7ux5236ux4fe1ux53f7}}

由于流水线中有些数据冒险通过转发解决不了，所以需要暂停机制。暂停机制的前提是产生数据冒险。暂停机制是通过
$ T_{use} $ 和 $ T_{new} $ 机制实现的。

$ T_{use} $ 是指指令到 D 级以后还剩最晚多少时间就需要新值。$ T_{new} $
是指指令还需要多长时间才能开始转发。因此只要 $ T_{use} < T_{new} $，就需要暂停，因为在流水线中如果没有暂停，两条指令的相对位置是不变的，如果不暂停，就不能解决数据冒险。

数据冒险可以只在 D 级检测和在 E 级解决，因为在 E 级插入气泡，就可以保证
$ T_{use} $ 和 $ T_{new} $ 最终回回归正常。

插入气泡是通过锁定 \texttt{pc} 和清空 E
级各个流水线寄存器实现的。但是，控制内部的流水线也要插入气泡。

暂停要分两个寄存器，因为数据冒险也是要分成两个寄存器的情况的。

注意：\textbf{$ T_{new} $
的计算是要看能够开始转发的时间，而不是生成好要转发数据的时间，因为不是所有转发路径都是可能的。}

注意：\textbf{控制内部的流水线也要插入气泡。}

在 D 级各种数据通路类型的 $ T_{use} $ 如下。

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
\headingcellfirst{数据通路类型} & \headingcellmiddle{$ T_{use1} $} & \headingcelllast{$ T_{use2} $} \tabularnewline\hline

\endhead\hiderowcolors
\texttt{UNKNOWN} & &\tabularnewline\hline
\texttt{CAL\_R} & 1 & 1\tabularnewline\hline
\texttt{CAL\_I} & 1 & 1\tabularnewline\hline
\texttt{LOAD} & 1 &\tabularnewline\hline
\texttt{STORE} & 1 & 2\tabularnewline\hline
\texttt{BRANCH} & 0 & 0\tabularnewline\hline
\texttt{JUMP\_I} & &\tabularnewline\hline
\texttt{JUMP\_R} & 0 &\tabularnewline\hline
\texttt{CMOV} & 0 & 0\tabularnewline\hline
\texttt{NOP} & &\tabularnewline\hline

\end{longtable}

在 E 级和 M 级各种数据通路类型的 $ T_{new} $ 如下。忽略 W 级，因为所有指令到 W 级时都可以马上转发数据。

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
数据通路类型 & $ T_{newE} $ & $ T_{newM} $\tabularnewline\hline

\endhead\hiderowcolors
\texttt{UNKNOWN} & &\tabularnewline\hline
\texttt{CAL\_R} & 1 & 0\tabularnewline\hline
\texttt{CAL\_I} & 1 & 0\tabularnewline\hline
\texttt{LOAD} & 2 & 1\tabularnewline\hline
\texttt{STORE} & &\tabularnewline\hline
\texttt{BRANCH} & &\tabularnewline\hline
\texttt{JAL} & 0 & 0\tabularnewline\hline
\texttt{JR} & 0 &\tabularnewline\hline
\texttt{CMOV} & 0 & 0\tabularnewline\hline
\texttt{NOP} & &\tabularnewline\hline

\end{longtable}

以上列表中 $ T_{use} $ 没有列出的，是因为它没有意义，认为 $ T_{use} $ 足够大。$ T_{new} $
同理，认为 $ T_{new} $ 为 0。

这样，只要算出每个阶段的 $ T_{use} $ 和
$ T_{new} $，并且保证发生数据冒险时对两个寄存器，$ T_{use} \ge T_{new} $，就能控制暂停和转发。当且仅当 $ \{T_{use1}, T_{use2}\} $ 小于 $ \{T_{newE}, T_{newM}\} $ 中的任何一个时，需要暂停。

注意：\textbf{表示 $ T_{use} $ 和 $ T_{new} $ 时，是用 3 位无符号数表示。$ T_{use} = 7 $ 表示不需要获取 \texttt{rf} 的值。$ T_{new} = 0 $ 表示马上就能生成 \texttt{rf} 的对应新值。比较 $ T_{use} $ 和 $ T_{new} $ 应该用无符号比较，避免数值最高位是 1 时被看成负数。}

\hypertarget{ux5bc4ux5b58ux5668ux5730ux5740ux63a7ux5236ux4fe1ux53f7}{%
\subsection{寄存器地址控制信号}\label{ux5bc4ux5b58ux5668ux5730ux5740ux63a7ux5236ux4fe1ux53f7}}

由于已经有指令识别机制了，所以寄存器的地址控制可以简化。只需要在 D 级和
M 级的三个地址端口输入指令识别机制相应的结果即可。

\section{转发控制模块}

\subsection{原理}

转发控制模块是流水线 CPU 控制机制的一部分，通过评估各指令读写寄存器的情况，实现有效的尽力转发。

\subsection{端口定义}

\begin{longtable}[]{@{}|l|l|l|l|}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能} \tabularnewline\hline
\endhead\hiderowcolors
\texttt{ddptype} & 输入 & 9 & D 级指令类型 \tabularnewline\hline
\texttt{dreg1} & 输入 & 5 & D 级指令与 \texttt{rf.read\_addr1} 对应的寄存器号 \tabularnewline\hline
\texttt{dreg2} & 输入 & 5 & D 级指令与 \texttt{rf.read\_addr2} 对应的寄存器号 \tabularnewline\hline
\texttt{dregw} & 输入 & 5 & D 级指令与 \texttt{rf.write\_addr} 对应的寄存器号 \tabularnewline\hline
\texttt{edptype} & 输入 & 9 & E 级指令类型 \tabularnewline\hline
\texttt{ereg1} & 输入 & 5 & E 级指令与 \texttt{rf.read\_addr1} 对应的寄存器号 \tabularnewline\hline
\texttt{ereg2} & 输入 & 5 & E 级指令与 \texttt{rf.read\_addr2} 对应的寄存器号 \tabularnewline\hline
\texttt{eregw} & 输入 & 5 & E 级指令与 \texttt{rf.write\_addr} 对应的寄存器号 \tabularnewline\hline
\texttt{mdptype} & 输入 & 9 & M 级指令类型 \tabularnewline\hline
\texttt{mreg1} & 输入 & 5 & M 级指令与 \texttt{rf.read\_addr1} 对应的寄存器号 \tabularnewline\hline
\texttt{mreg2} & 输入 & 5 & M 级指令与 \texttt{rf.read\_addr2} 对应的寄存器号 \tabularnewline\hline
\texttt{mregw} & 输入 & 5 & M 级指令与 \texttt{rf.write\_addr} 对应的寄存器号 \tabularnewline\hline
\texttt{wdptype} & 输入 & 9 & W 级指令类型 \tabularnewline\hline
\texttt{wreg1} & 输入 & 5 & W 级指令与 \texttt{rf.read\_addr1} 对应的寄存器号 \tabularnewline\hline
\texttt{wreg2} & 输入 & 5 & W 级指令与 \texttt{rf.read\_addr2} 对应的寄存器号 \tabularnewline\hline
\texttt{wregw} & 输入 & 5 & W 级指令与 \texttt{rf.write\_addr} 对应的寄存器号 \tabularnewline\hline
\texttt{cw\_fm\_[de][12]} & 输出 & 3 & D / E 级与 \texttt{rf.read\_addr[12]} 对应的转发 MUX \tabularnewline\hline
\texttt{cw\_fm\_m} & 输出 & 3 & M 级与 \texttt{rf.read\_addr2} 对应的转发 MUX \tabularnewline\hline
\end{longtable}

\subsection{宏定义}

暂无。

\subsection{功能}

见控制中的对应节。

\section{暂停控制模块}

\subsection{原理}

暂停控制模块是流水线 CPU 控制机制的一部分，通过评估 $ T_{use} $ 和 $ T_{new} $ 实现尽量少的暂停。它是控制模块内部的一部分。

\subsection{端口定义}

\begin{longtable}[]{@{}|l|l|l|l|}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能} \tabularnewline\hline
\endhead\hiderowcolors
\texttt{ddptype} & 输入 & 9 & D 级指令类型 \tabularnewline\hline
\texttt{dreg1} & 输入 & 5 & D 级指令与 \texttt{rf.read\_addr1} 对应的寄存器号 \tabularnewline\hline
\texttt{dreg2} & 输入 & 5 & D 级指令与 \texttt{rf.read\_addr2} 对应的寄存器号 \tabularnewline\hline
\texttt{dregw} & 输入 & 5 & D 级指令与 \texttt{rf.write\_addr} 对应的寄存器号 \tabularnewline\hline
\texttt{edptype} & 输入 & 9 & E 级指令类型 \tabularnewline\hline
\texttt{ereg1} & 输入 & 5 & E 级指令与 \texttt{rf.read\_addr1} 对应的寄存器号 \tabularnewline\hline
\texttt{ereg2} & 输入 & 5 & E 级指令与 \texttt{rf.read\_addr2} 对应的寄存器号 \tabularnewline\hline
\texttt{eregw} & 输入 & 5 & E 级指令与 \texttt{rf.write\_addr} 对应的寄存器号 \tabularnewline\hline
\texttt{mdptype} & 输入 & 9 & M 级指令类型 \tabularnewline\hline
\texttt{mreg1} & 输入 & 5 & M 级指令与 \texttt{rf.read\_addr1} 对应的寄存器号 \tabularnewline\hline
\texttt{mreg2} & 输入 & 5 & M 级指令与 \texttt{rf.read\_addr2} 对应的寄存器号 \tabularnewline\hline
\texttt{mregw} & 输入 & 5 & M 级指令与 \texttt{rf.write\_addr} 对应的寄存器号 \tabularnewline\hline
\texttt{wdptype} & 输入 & 9 & W 级指令类型 \tabularnewline\hline
\texttt{wreg1} & 输入 & 5 & W 级指令与 \texttt{rf.read\_addr1} 对应的寄存器号 \tabularnewline\hline
\texttt{wreg2} & 输入 & 5 & W 级指令与 \texttt{rf.read\_addr2} 对应的寄存器号 \tabularnewline\hline
\texttt{wregw} & 输入 & 5 & W 级指令与 \texttt{rf.write\_addr} 对应的寄存器号 \tabularnewline\hline
\texttt{stall} & 输出 & 1 & 是否需要暂停 \tabularnewline\hline
\end{longtable}

\subsection{宏定义}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义} \tabularnewline\hline
\endhead\hiderowcolors
$ T_{use} $ 或 $ T_{new} $ 的值 & \texttt{inf} & 3'd7 & 值为概念上的无穷大时，实际的值 \tabularnewline\hline
\end{longtable}

\subsection{功能}

见控制中的对应节。

\hypertarget{cpu}{%
\section{CPU}\label{cpu}}

\hypertarget{ux539fux7406-11}{%
\subsection{原理}\label{ux539fux7406-11}}

CPU 是宏观部件，主要连接起数据通路和控制。该部件主要起的是宏观功能，也就是读取指令并完成计算。

CPU 在模块结构中作为顶层模块而存在。

\hypertarget{ux7aefux53e3ux5b9aux4e49-9}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-9}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & 输入 & 1 & 时钟信号\tabularnewline\hline
\texttt{reset} & 输入 & 1 & 同步复位信号 \tabularnewline\hline

\end{longtable}

\hypertarget{ux63a5ux7ebf}{%
\subsection{接线}\label{ux63a5ux7ebf}}

按照数据通路和控制部分的定义进行接线。数据通路中的接线方式在数据通路部分的文档中描述，控制部分按照控制部分的文档中描述。控制部分控制数据通路的哪部分，在控制部分的文档中。

\texttt{reset} 信号接到所有时序部件对应的同步复位接口中。

\hypertarget{ux529fux80fd-13}{%
\subsection{功能}\label{ux529fux80fd-13}}

CPU 需要的外部数据输入是极少的，只有时钟信号、必要的其它信号和指令文件。

\section{思考题}

在 p5 中遇到了很多种不同指令类型组合产生的冲突。

解决方式：通过暂停和转发解决。大体上方案类似于 A/T 编码器方案。

\begin{description}
\item[转发条件判断] 控制模块内部流水指令，同时在 D 级判断出 A1-A3 三个寄存器。然后把这三个寄存器流水，这样转发条件就容易判断了。
\item[暂停机制] 获取到 D 级指令的 $ T_{use1} $ 和 $ T_{use2} $，以及 E 级和 M 级指令的 $ T_{new} $。然后直接通过比较 $ T_{use} $ 和 $ T_{new} $ 的方式确定是否暂停。
\item[转发机制] 通过指令类型确定对应指令在哪一级的哪里生成转发数据。然后根据转发条件，在每个需求位点部署转发 MUX，连入原来的值和后面所有供给者的值。若转发条件满足，则选择时间上最后生成的值，进行转发。
\end{description}

考虑过使用标记转发法，但是因为个人感觉暂停机制更好理解、不需要在每一级的控制单元对标记进行处理和特判、转发机制通常不需要大修改，所以还是使用了比较老的类似 A/T 编码器的方案。

测试样例是完全随机生成为主，手动构造小样例为辅。

\begin{description}
\item[手动构造小样例] 可以明白流水线处理器的工作原理，检查是否有比较基本的错误。但是工作强度大、覆盖性不强。
\item[完全随机生成] 可以利用自动化工具，进行覆盖性更强、更省力的测试，但是覆盖不一定全面、调试略微麻烦。
\end{description}

没有使用采用特殊策略的方式，但是可以通过固定产生冲突的寄存器和指令类型，在其它寄存器的读写上增加随机性，来增加测试的强度。
\section{测试}

\begin{enumerate}
\item 
\begin{lstlisting}[language={[mips]Assembler}]
# fm_e: M2E_alu
lui $1, 0x002a
ori $1, 0x002a
nop
nop
nop

# fm_d: E2D_npc, fm_m: M2E_npc, fm_m: W2M_rf
jal good
addu $2, $31, $31
evil:
lui $2, 0xdead
lui $2, 0xbeef
good:
nop
nop
nop
nop

# fm_d: E2D_rf
movz $3, $1, $0
addu $0, $3, $3
nop
nop
nop

# fm_d: M2D_npc
jal good2
nop
good2:
addu $0, $31, $31
nop
nop
nop
nop

# fm_d: M2D_alu, fw_e: W2E_rf
lui $4, 0x4242
nop
ori $4, 0x4242
nop
nop

# fm_d: W2D_rf
lui $5, 0x4242
nop
nop
ori $5, 0x4242
nop
nop
nop
nop
\end{lstlisting}
\begin{verbatim}
@00003000: $ 1 <= 002a0000
@00003004: $ 1 <= 002a002a
@00003014: $31 <= 0000301c
@00003018: $ 2 <= 00006038
@00003034: $ 3 <= 002a002a
@00003048: $31 <= 00003050
@00003064: $ 4 <= 42420000
@0000306c: $ 4 <= 42424242
@00003078: $ 5 <= 42420000
@00003084: $ 5 <= 42424242
\end{verbatim}
\item 
\begin{lstlisting}[language={[mips]Assembler}]
lui $1, 0x4242
ori $1, 0x4242
sw $1, 0($0)
nop
nop

# T_use (reg2) < T_new (E) and T_use (reg2) < T_new (M)
lw $2, 0($0)
movz $3, $1, $0
nop
nop
nop

# T_use (reg1) < T_new (W) and T_use (reg1) < T_new (M)
lw $4, 0($0)
movz $5, $4, $0
nop
nop
nop
\end{lstlisting}
\begin{verbatim}
@00003000: $ 1 <= 42420000
@00003004: $ 1 <= 42424242
@00003008: *00000000 <= 42424242
@00003014: $ 2 <= 42424242
@00003018: $ 3 <= 42424242
@00003028: $ 4 <= 42424242
@0000302c: $ 5 <= 42424242
\end{verbatim}
\item 
\begin{lstlisting}[language={[mips]Assembler}]
# Test 1: lui
# 42
lui $1, 0x002a
nop
nop
nop
nop
lui $2, 0xffff
nop
nop
nop
nop

# Test 2: ori
ori $1, 0x002a
nop
nop
nop
nop
ori $2, 0xffff
nop
nop
nop
nop

# Test 3: addu
addu $3, $1, $2
nop
nop
nop
nop
addu $0, $1, $2
nop
nop
nop
nop

# Test 4: subu
subu $4, $1, $2
nop
nop
nop
nop
subu $5, $0, $0
nop
nop
nop
nop

# Test 5: sw
sw $3, 0($0)
nop
nop
nop
nop
sw $3, 8($0)
nop
nop
nop
nop

# Test 6: lw
lw $6, 0($0)
nop
nop
nop
nop
lw $7, 0($0)
nop
nop
nop
nop
lw $8, 0($0)
nop
nop
nop
nop

# Test 7: beq
beq $0, $0, good
nop
nop
nop
nop
evil:
lui $9, 0xdead
nop
nop
nop
nop
ori $9, 0xbeef
nop
nop
nop
nop
good:
lui $9, 0x0123
nop
nop
nop
nop
ori $9, 0x4567
nop
nop
nop
nop

# Test 8: nop
nop

\end{lstlisting}
\begin{verbatim}
@00003000: $ 1 <= 002a0000
@00003014: $ 2 <= ffff0000
@00003028: $ 1 <= 002a002a
@0000303c: $ 2 <= ffffffff
@00003050: $ 3 <= 002a0029
@00003078: $ 4 <= 002a002b
@0000308c: $ 5 <= 00000000
@000030a0: *00000000 <= 002a0029
@000030b4: *00000008 <= 002a0029
@000030c8: $ 6 <= 002a0029
@000030dc: $ 7 <= 002a0029
@000030f0: $ 8 <= 002a0029
@00003140: $ 9 <= 01230000
@00003154: $ 9 <= 01234567

\end{verbatim}
\item 
\begin{lstlisting}[language={[mips]Assembler}]
luI $9, 0x002a
nop
nop
nop
nop
ori $9, 0x002a
nop
nop
nop
nop

# Test 9: movz
movz $10, $9, $0
nop
nop
nop
nop
movz $11, $9, $9
nop
nop
nop
nop

# Test 10: j
j good1
nop
nop
nop
nop
evil1:
lui $12, 0xdead
nop
nop
nop
nop
ori $12, 0xbeef
nop
nop
nop
nop
good1:
lui $12, 0x0123
nop
nop
nop
nop
ori $12, 0x4567
nop
nop
nop
nop

# Test 11: jal
jal good2
nop
nop
nop
nop
evil2:
lui $13, 0xdead
nop
nop
nop
nop
ori $13, 0xbeef
nop
nop
nop
nop
good2:
lui $13, 0x0123
nop
nop
nop
nop
ori $13, 0x4567
nop
nop
nop
nop

# Test 12: jr
lui $14, 0x0000
nop
nop
nop
nop
ori $14, 0x3168
nop
nop
nop
nop
jr $14
nop
nop
nop
nop
lui $15, 0xdeed
nop
nop
nop
nop
lui $15, 0x002a
nop
nop
nop
nop
\end{lstlisting}
\begin{verbatim}
@00003000: $ 9 <= 002a0000
@00003014: $ 9 <= 002a002a
@00003028: $10 <= 002a002a
@0000308c: $12 <= 01230000
@000030a0: $12 <= 01234567
@000030b4: $31 <= 000030bc
@000030f0: $13 <= 01230000
@00003104: $13 <= 01234567
@00003118: $14 <= 00000000
@0000312c: $14 <= 00003168
@00003168: $15 <= 002a0000

\end{verbatim}
\item 
\begin{lstlisting}[language={[mips]Assembler}]
ori $t0, $t0, 10
lui $t1, 6
addu $t2, $t0, $t1
nop
subu $t3, $t1, $t2
subu $t3, $t1, $t0


\end{lstlisting}
\begin{verbatim}
@00003000: $ 8 <= 0000000a
@00003004: $ 9 <= 00060000
@00003008: $10 <= 0006000a
@00003010: $11 <= fffffff6
@00003014: $11 <= 0005fff6

\end{verbatim}
\end{enumerate}

\hypertarget{ux6280ux5de7}{%
\section{技巧}\label{ux6280ux5de7}}

\hypertarget{ux614cux4e86ux600eux4e48ux529e}{%
\subsection{慌了怎么办}\label{ux614cux4e86ux600eux4e48ux529e}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Don't panic! 做出来是最重要的
\item
  深呼吸，专心想实现和调试的事情，不要害怕干不出来
\item
  看看哪里的逻辑出错了，\textbf{不要逃避！}
\item
  用小数据、边界数据、特殊数据测试
\item
  踏踏实实想逻辑、定义、算法，必要的时候自己再描述一遍 /
  写一遍，不要根据原来做出来的
\end{enumerate}

\hypertarget{ux5982ux4f55ux52a0ux65b0ux6307ux4ee4}{%
\subsection{如何加新指令}\label{ux5982ux4f55ux52a0ux65b0ux6307ux4ee4}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  看好 RTL，把它转换成数据通路的连线
\end{enumerate}

\begin{itemize}
\tightlist
\item
  注意流水线分级
\item
  可能需要引入新的流水线寄存器
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  如果有多对一的情况，就应该用 MUX
\end{enumerate}

\begin{itemize}
\tightlist
\item
  MUX 是原来的值，改控制信号
\item
  MUX 是新的值，改控制信号，\textbf{可能要改 MUX 的位宽和对应接线的位宽}
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  改好控制信号
\end{enumerate}

\begin{itemize}
\tightlist
\item
  对指令域进行识别

  \begin{itemize}
  \tightlist
  \item
    尽量把新指令归约到原来的 \texttt{dptype} 上，\textbf{可以使用
    \texttt{\$0}，也可以利用其它特殊寄存器，毕竟控制模块里对读写寄存器的指定是
    arbitrary 的}
  \end{itemize}
\item
  如果需要一个新的 \texttt{dptype}

  \begin{itemize}
  \tightlist
  \item
    计算好控制信号
  \item
    计算好 $ T_{use} $ 和 $ T_{new} $
  \item
    看好如何转发、是否需要改转发路径
  \end{itemize}
\item
  如果需要改转发路径

  \begin{itemize}
  \tightlist
  \item
    确定转发的源和目的
  \item
    \textbf{注意数据通路里的转发 MUX 和控制单元里的控制信号需要同时改}
  \end{itemize}
\item
  如果有新的跳转规则

  \begin{itemize}
  \tightlist
  \item
    尽量改 \texttt{npc}，让 \texttt{npc} 基于比较结果判断
  \item
    如果引入了新的比较方式，就需要改 \texttt{cmp}，\textbf{注意有符号 /
    无符号和运算溢出问题和改 \texttt{cmp} 的接口}，同时也要改数据通路和
    \texttt{npc} 的接口
  \item
    如果要跟立即数比较，\textbf{先看一下立即数的扩展模式}，能用
    \texttt{npc} 解决的尽量用 \texttt{npc} 解决，p5 有时不用改
    \texttt{cmp}
  \item
    如果根据一个寄存器跳转，那么按照引入了新的比较方式处理，改
    \texttt{cmp} 的比较方式
  \item
    如果跳转时涉及 \texttt{retaddr}，那么有时可以按照
    \texttt{JUMP\_{[}IR{]}} 处理
  \end{itemize}
\item
  如果有新的立即数扩展方式

  \begin{itemize}
  \tightlist
  \item
    如果还是 \texttt{im.result{[}15:0{]}} 改
    \texttt{ext}，\textbf{注意有符号 / 无符号的区别}
  \item
    如果是 \texttt{im.result} 的其它部分，记得加 MUX
    信号来源，\textbf{注意位宽和有符号 / 无符号的区别}
  \end{itemize}
\item
  如果有新的寄存器号表示方法

  \begin{itemize}
  \tightlist
  \item
    加 MUX 信号来源，\textbf{记得改位宽}，控制信号用 sane defaults
  \item
    可以根据指令类型特判
  \end{itemize}
\item
  如果 \texttt{alu} 有新的运算

  \begin{itemize}
  \tightlist
  \item
    \textbf{抓好定义}，例如补码的相反数，最小的负数没有相反数
  \item
    \textbf{注意地址计算是无符号计算、指令给定了是不是有符号运算要注意}
  \item
    如果是两个输入的运算，直接写新运算
  \item
    如果是三个输入的运算，看看能不能省下一个运算源，\textbf{有的时候要改控制的输入}，比如条件传送指令需要根据第二个寄存器的值判断
    \texttt{rf.we}

    \begin{itemize}
    \tightlist
    \item
      如果新值能够比较快地出来，\textbf{注意改转发路径，但是为了正确定不改也可以}，比如条件传送指令
    \end{itemize}
  \item
    如果是输入带附加参数的运算，可以开一个 \texttt{alu}
    端口，然后在控制器上接过去，也可以通过正常数据通路传过去（不推荐），比如移位运算可以直接在控制器和
    \texttt{alu} 上开端口

    \begin{itemize}
    \tightlist
    \item
      注意一般都有 Python，\textbf{可以自动代码生成}
    \end{itemize}
  \end{itemize}
\item
  如果有新的 \texttt{dm} 存取方式

  \begin{itemize}
  \tightlist
  \item
    如果是特殊的读写范围，那么因为是单周期，可以在 \texttt{dm} 上开端口
    \texttt{mode}，让控制单元控制 \texttt{mode}，注意 sane defaults
    和\textbf{小端序}
  \item
    如果是同时读写，那么也可以用上面的方法，注意 \texttt{dm}
    的读写地址端口是分开的，注意开 MUX 的端口和 sane defaults
  \item
    如果是根据其它来源读写，注意开 MUX 的端口和 sane defaults

    \begin{itemize}
    \tightlist
    \item
      \textbf{注意这样的话转发多了一个新的消费者}
    \end{itemize}
  \end{itemize}
\item
  如果有新的 \texttt{rf} 的值

  \begin{itemize}
  \tightlist
  \item
    注意要接线接过来，然后加 MUX

    \begin{itemize}
    \tightlist
    \item
      \textbf{注意补上每级的 \texttt{pff} 和对应的
      \texttt{wire}，一定要声明，否则默认是 1 位的}
    \end{itemize}
  \item
    如果是返回地址，\textbf{最好是先接当前 PC，然后无符号数 +8}

    \begin{itemize}
    \tightlist
    \item
      \textbf{一般这种指令可以归约到 \texttt{JUMP\_{[}IR{]}} 里}
    \end{itemize}
  \item
    注意 \texttt{rf} 的值是否写入可以跟 \texttt{rf.we}
    配合，\textbf{也可以妙用写入 \texttt{\$0}}
  \end{itemize}
\end{itemize}

\hypertarget{ux5982ux4f55ux6709ux6548ux8c03ux8bd5}{%
\subsection{如何有效调试}\label{ux5982ux4f55ux6709ux6548ux8c03ux8bd5}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  定位出错指令
\end{enumerate}

\begin{itemize}
\tightlist
\item
  平时可以用 \texttt{diff}
\item
  在考场上主要靠看数据和猜

  \begin{itemize}
  \tightlist
  \item
    看数据大法

    \begin{itemize}
    \tightlist
    \item
      前面一堆 0 位或者 1 位出错的，一般是移位指令
    \item
      前面数据乱了的，一般是乘除法指令
    \item
      数据差 1 的，一般是条件设置指令
    \end{itemize}
  \item
    瞎猜大法

    \begin{itemize}
    \tightlist
    \item
      最近加了什么指令
    \item
      哪条指令原理不确定
    \item
      哪条指令是说了的重点
    \item
      哪条指令比较复杂，不好实现
    \item
      课下测试一直没过哪条指令
    \end{itemize}
  \item
    实在不行就把感觉错了的指令都检查一遍
  \end{itemize}
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  分析每级的行为
\end{enumerate}

\begin{itemize}
\tightlist
\item
  先把 RTL 在心里分解成每级
\item
  然后比较出错指令或者觉得出错指令的差异
\item
  然后看转发和暂停是不是写对了

  \begin{itemize}
  \tightlist
  \item
    首先检查\textbf{每级得出的寄存器结果、$ T_{use} $ 和 $ T_{new} $}
  \item
    然后检查控制器的转发是否写对
  \item
    然后检查数据通路的转发是否正确反映了逻辑
  \item
    最后检查一下转发相关的接线
  \end{itemize}
\item
  然后检查每级的行为

  \begin{itemize}
  \tightlist
  \item
    先检查控制信号对不对，\textbf{尤其是新加的控制信号和它们对应的
    defaults}

    \begin{itemize}
    \tightlist
    \item
      如果上面检查了的话，转发和暂停检查一下 defaults
    \end{itemize}
  \item
    \texttt{npc} 看与 \texttt{cmp} 的配合和 \texttt{npc}
    模式本身的实现，注意\textbf{大小比较、有无符号数和指令取立即数的扩展}
  \item
    \texttt{rf} 看取寄存器号对不对，不要乱改改折了，\textbf{注意
    MUX、数据位宽、有无符号数和扩展模式}

    \begin{itemize}
    \tightlist
    \item
      \textbf{检查一下对应的控制信号}
    \end{itemize}
  \item
    \texttt{ext} 看扩展模式对不对，\textbf{注意扩展的是哪些位和扩展模式}
  \item
    \texttt{alu} 看实现的运算对不对，\textbf{要踏实地看定义以及和
    \texttt{rf} 的配合，不要读哪个寄存器都读错了}

    \begin{itemize}
    \tightlist
    \item
      \textbf{如果有第三个参数，检查一下关于第三个参数的逻辑}
    \end{itemize}
  \item
    \texttt{dm}
    看实现的读写模式和读写地址对不对，\textbf{注意端序和读写地址的对应
    MUX，和它们与控制信号的对应关系}

    \begin{itemize}
    \tightlist
    \item
      注意可能读写地址要分开转发，\textbf{这里的接线需要仔细看然后调一下}
    \end{itemize}
  \item
    \texttt{rf}
    还要看实现的钩子对不对，\textbf{尤其是根据寄存器值判断的那部分，因为需要控制器配合}

    \begin{itemize}
    \tightlist
    \item
      \textbf{注意要先实现钩子再转发}
    \end{itemize}
  \end{itemize}
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  分析指令之间的关系
\end{enumerate}

\begin{itemize}
\tightlist
\item
  跟上一条指令之间的关系
\item
  如果是跳转指令，跟以前指令和对应寄存器的关系
\item
  如果是 L/S 指令，跟内存的关系
\item
  如果是乘除法指令，跟乘除法器及其串行化的关系
\item
  CPU 的初始状态
\end{itemize}

\hypertarget{ux5982ux4f55ux6539ux6570ux636eux901aux8def}{%
\subsection{如何改数据通路}\label{ux5982ux4f55ux6539ux6570ux636eux901aux8def}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  分析为什么要改数据通路
\end{enumerate}

\begin{itemize}
\tightlist
\item
  改数据通路代价比较大

  \begin{itemize}
  \tightlist
  \item
    加入流水线后更是如此，\textbf{转发、暂停、流水线寄存器都要重新
    evaluate 一遍}
  \end{itemize}
\item
  必须安装新部件吗？

  \begin{itemize}
  \tightlist
  \item
    可能有的部件可以通过 hook 来解决
  \item
    有的部件可以通过改部件本身的方式来解决
  \item
    可能可以重新把指令的 RTL fit 到现有的数据通路里
  \item
    可能可以直接 hook 控制机制
  \item
    如果要求加新部件，那必须加，没有办法
  \end{itemize}
\item
  新部件部署在哪一级？

  \begin{itemize}
  \tightlist
  \item
    \textbf{直接决定转发、暂停和流水线寄存器的 evaluation}
  \item
    对类比同级的 MUX 和部件有帮助
  \item
    对分清这个部件的功能有描述
  \end{itemize}
\item
  改了新部件，如何既服务好新指令，又能与原来的指令兼容？

  \begin{itemize}
  \tightlist
  \item
    sane defaults
  \item
    可能需要回退机制
  \item
    原来的指令可能需要在控制层面避开新部件带来的影响，不过这一点一般不大可能
  \end{itemize}
\end{itemize}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  分析怎么改数据通路
\end{enumerate}

\begin{itemize}
\tightlist
\item
  如果没安装新部件

  \begin{itemize}
  \tightlist
  \item
    如果在 \texttt{npc} 这里加上 hook 机制，记得跟 \texttt{cmp}
    和控制配合好，\textbf{扩展指令的立即数时，源、目的和扩展哪个部分一定要注意}
  \item
    如果在控制加上 hook 机制，\textbf{要注意 sane defaults 和 hook
    机制能不能方便之后修改代码}
  \item
    如果在 \texttt{alu\ /\ ext\ /\ dm}
    加了新功能，\textbf{注意实现是否正确，要紧扣定义}
  \end{itemize}
\item
  如果安装了新部件

  \begin{itemize}
  \tightlist
  \item
    重构一遍新指令的数据通路，\textbf{注意 sane defaults}
  \item
    \textbf{evaluate
    一遍转发、暂停和流水线寄存器，并且仔细地改转发和暂停规则}

    \begin{itemize}
    \tightlist
    \item
      \textbf{看一下有没有多重转发，有的话可以暂停也可以多重转发，不过一般这不大可能}
    \end{itemize}
  \item
    分析一下新部件的功能
  \item
    \textbf{看一下数据通路的更改，注意跟流水线寄存器之间的微妙的关系}
  \item
    如果比较有空，可以稍微测试一下
  \end{itemize}
\end{itemize}

\hypertarget{ux5982ux4f55ux6bd4ux8f83ux65b9ux4fbfux5730ux6539ux8bbeux8ba1}{%
\subsection{如何比较方便地改设计}\label{ux5982ux4f55ux6bd4ux8f83ux65b9ux4fbfux5730ux6539ux8bbeux8ba1}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  可以在加 hook 机制的时候认为这是必须的
\item
  可以在扩展时认为这样可以简化数据通路
\item
  可以在部署部件时部署到比较方便实现的级
\item
  可以在实现内部流水线时认为这样方便调试
\item
  可以在暂停时认为这样可以简化设计
\end{enumerate}
\end{document}

