## 乘除法器

### 原理

乘除法器是 MIPS 体系结构中运算代价比较高的部件，需要多个时钟周期进行运算。因此，它必须要有 `busy` 信号指定它是不是忙，通过是不是忙来让控制模块决定暂停和转发。

两个 32 位数的乘法结果是 64 位，所以需要两个 32 位寄存器。同样地，除法有商和余数，所以也需要两个 32 位寄存器。总结起来，乘除法器需要两个 32 位寄存器。乘法有高低位的区别，把它们叫做 `HI` 和 `LO` 寄存器能区分过来。

乘除法需要多个周期，但是模拟时乘除法只要一个周期。因此，需要在乘除法器内部设定一个计时器，模拟需要多个周期乘除法的行为。还没有准备好时，就在 `HI` 和 `LO` 寄存器输出代替的值。

### 端口定义

端口 | 类型 | 位宽 | 功能
--- | --- | --- | ---
clk | 输入 | 1 | 时钟信号
dh | 输入 | 32 | 第一个输入的数据
dl | 输入 | 32 | 第二个输入的数据
op | 输入 | 4 | 需要的操作
busy | 输出 | 1 | 乘除法器是否繁忙
invalid | 输出 | 1 | 乘除法操作是否非法
hi | 输出 | 32 | `HI` 寄存器的值
lo | 输出 | 32 | `LO` 寄存器的值

### 宏定义

各宏的意义如果是对应的操作，就省略。

类别 | 定义 | 值 | 意义
--- | --- | --- | ---
`op` | `MD_NONE` | `4'd0000` |
`op` | `MD_MFHI` | `4'd0001` | 
`op` | `MD_MFLO` | `4'd0010` | 
`op` | `MD_MTHI` | `4'd0011` | 
`op` | `MD_MTLO` | `4'd0100` | 
`op` | `MD_MULT` | `4'd0101` | 
`op` | `MD_MULTU` | `4'd0110` | 
`op` | `MD_DIV` | `4'd0111` | 
`op` | `MD_DIVU` | `4'd1000` | 

### 功能

该部件为时序部件，所有寄存器初值为 0.

有一个 4 位宽的计时器 ctr。

无论什么时候，`hi` 和 `lo` 都分别是 `hi_reg` 和 `lo_reg` 的内容。无论什么时候，`busy` 都是 `ctr` 作为无符号数大于 0 时为 `1'b1`，否则为 `1'b0`。`invalid` 都是 `(op_i == MD_DIV || op_i == MD_DIVU) && dl_i == 32'b0` 时为 1'b1，否则为 1'b0。检查内部寄存器是因为内部寄存器才是 `md` 内保存的真正状态，而且在一个时钟周期内检查来得及。

每个时钟上升沿，若计时器 `ctr` 的值作为无符号数大于 1，则把 `ctr` 减 1。否则，若 `ctr` 的值作为无符号数等于 1，则令 `hi_reg` 和 `lo_reg` 分别为 `dh_i` 和 `dl_i` 寄存器在相应运算下的结果。否则，什么也不做。

每个时钟下降沿，若 `op == MD_NONE || $unsigned(ctr) > $unsigned(0)`，则什么也不做。

否则，若 `op == MD_MTHI || op == MD_MTLO`，则把 `dh` 的值写入相应的寄存器。若 `op == MD_MFHI || op == MD_MFLO`，也是什么也不做，因为控制模块会自动选择相应的寄存器作为要写入的值。若 `op == MD_MULT || op == MD_MULTU || op == MD_DIV || op == MD_DIVU`，则把 `ctr` 设置成对应的数值，而且把内部 `dh_i`、`dl_i` 和 `op_i` 寄存器的值分别设置成 `dh`、`dl`和 `op`。`乘法操作 `ctr` 初值是 5，除法操作 `ctr` 初值是 10。若 `op` 为其它值，也是什么也不做。

注意：**除法是把 `dh` 当被除数，`dl` 当除数。但结果表示的时候，`hi` 当余数，`lo` 当商。若 `dl == 32'b0`，则结果为 64'b0。**

注意：**没有考虑第一条指令是 `CAL_M` 类指令，但是时钟没有下降沿的情况。**

