## CP0

### 原理

CP0 是 0 号协处理器的意思，它负责异常和中断的处理，也负责保存和恢复出现异常时的 PC。

为了能够更方便地处理异常及其相关转发，CP0 部署在 M 级。

### 端口定义

端口 | 类型 | 位宽 | 功能
--- | --- | --- | ---
`clk` | 输入 | 1 | 时钟信号
`rst` | 输入 | 1 | 同步复位信号
`addr` | 输入 | 5 | 内部寄存器的读写地址
`write_enable` | 输入 | 1 | 内部寄存器的写使能信号
`write_data` | 输入 | 32 | 内部寄存器的写入数据
`exit_isr` | 输入 | 1 | `eret` 指令清除 `exl` 的控制信号
`in_bds` | 输入 | 1 | 当前指令是否在延迟槽中
`hwirq` | 输入 | 6 | 外部设备中断信号
`exc` | 输入 | 5 | 内部异常信号
`curr_pc` | 输入 | 32 | 受害指令当前 PC 值
`read_result` | 输出 | 32 | 内部寄存器的读取结果
`epc` | 输出 | 32 | 保存的要跳转回的 `pc` 值
`have2handle` | 输出 | 1 | 必须处理中断或异常

### 宏定义

类别 | 定义 | 值 | 意义
--- | --- | --- | ---
异常类型 | `EXC_NONE` | `5'd0` | 没有异常
异常类型 | `EXC_ADEL` | `5'd4` | AdEL 异常（读取时地址错误）
异常类型 | `EXC_ADES` | `5'd5` | AdES 异常（写入时地址错误）
异常类型 | `EXC_RI` | `5'd10` | RI 异常（未知指令）
异常类型 | `EXC_OV` | `5'd12` | Ov 异常（运算溢出）
`prid` | `CP0_PRID` | `32'h0000002a` | `cp0` 的处理器 ID
工作模式 | `MARS_COMPAT` | | `cp0` 是否工作在跟 MARS 兼容的模式下

### 功能

该部件为时序部件，没有特殊规定的话，所有寄存器初值均为全 0。但在 MARS 兼容模式下，`sr` 初值为 `32'h0000ff11`，意味着打开所有 8 个中断（包括 6 个硬件中断和 2 个软件中断），禁用所有 64 位内核地址空间、监管程序地址空间和用户地址空间的访问，基础模式为用户模式，未实现监管程序模式，`exl` 为 0，全局中断使能打开。

CP0 内部有四个寄存器，都是 32 位的。它们的概况如下。其中出现常量 0 的部分，是因为寄存器功能没有实现全或者按定义实现导致的，这些部分在普通模式下不允许写入，但在 MARS 兼容模式下允许写入，不会一直保持为 0，但写入的值目前还没有作用。PrID 寄存器为只读，所以它其实不是用寄存器实现的，是用 `wire`。

编号 | 寄存器 | 代码中的名字 | 结构 | 备注
--- | --- | --- | --- | ---
`12` | `SR` | `sr` |  `{16'b0, allow_hwirq, 8'b0, exl, g_allow_hwirq}` |
`13` | `Cause` | `cause` |  `{in_bds_i, 15'b0, hwirq_i, 3'b0, exc_i, 2'b0}` |
`14` | `EPC` | `epc` |  `{epc_i}` | 实际上也是输出端口
`15` | `PrID` | `prid` | `{prid}` | 直接用 `wire` 实现

各小寄存器的意义如下。

小寄存器 | 位宽 | 初值 | 意义
--- | --- | --- | ---
`allow_hwirq` | 6 | 6'b0 | 允许相应硬件的中断请求，作为掩码使用
`exl` | 1 | 1'b0 | 异常级别，在 ISR 时为 1
`g_allow_hwirq` | 1 | 1'b0 | 在全局允许相应硬件的中断请求
`in_bds_i` | 1 | 1'b0 | 在内部保存的受害指令是否在延迟槽中的信息
`hwirq_i` | 6 | 6'b000000 | 在内部保存的硬件中断请求情况
`exc_i` | 5 | 5'd0 | 在内部保存的异常代码
`epc_i` | 32 | 32'h0 | 在内部保存的从 ISR 中返回的 PC
`prid` | 32 | 32'h0000002a | 处理器 ID

小寄存器定义在寄存器里面，在实现中是用宏表示的。

无论什么时候，若 `addr` 为相应寄存器的编号，则在 `read_result` 端口输出相应寄存器的值。若编号超出范围，则输出 `32'b0`。定义两个表示内部和外部异常或中断请求的 `wire`：`have_irq`，`have_exc`。当且仅当 `(hwirq & allow_hwirq) != 0 && g_allow_hwirq == 1'b1 && exl == 1'b0` 时，`have_irq == 1'b1`，否则为 `1'b0`。当且仅当 `exc != EXC_NONE && exl == 1'b0` 时，`have_exc == 1'b1`，否则为 1'b0。`have2handle == 1'b1` 当且仅当 `have_irq || have_exc`，否则为 `1'b0`。

在每个时钟上升沿，首先检查 `have2handle`。若 `have2handle == 1'b1`，则 `exl <= 1'b1; in_bds_i <= in_bds; epc_i <= (in_bds == 1'b1) ? $unsigned(curr_pc) - $unsigned(4) : $unsigned(curr_pc)`。此时，若 `have_irq == 1'b1`，则 `exc_i <= 0`，否则若 `have_exc == 1'b1`，则 `exc_i <= exc`。在 MARS 兼容模式下，还需要把代表软件中断的两位（`[9:8]`）清空，无论发生了硬件中断还是软件异常。然后检查 `write_enable`。若 `write_enable == 1'b1 && (addr == 5'd12 || addr == 5'd13 || addr == 5'd14)`，则认为试图写入有效，否则进入下一步骤。直接把对应寄存器写入相应的值，但是注意在正常模式下寄存器定义时出现常量 0 的部分会忽略写入，在 MARS 兼容模式下不会。最后检查其它信号。若 `exit_isr == 1'b1`，则 `exl <= 1'b0`。若每一步的第一个条件符合，则不需要检查后面的步骤。

在每个时钟上升沿，若在普通模式下，一个附加的步骤（无论如何都要执行）是若不是写入地址有效或者写入的地址不是 `5'd13` 或者 `have2handle` 不是 `1'b0`，则 `hwirq_i <= hwirq`。这是为了让 CPU 跟硬件更好地同步。

### 注意事项

1. **中断优先级高于异常，这在功能中也能看出来**
2. **硬件 IRQ 是每个时钟周期都要响应，在 IRQ 内都要响应，不跟着 CPU 的节奏来**
3. **把寄存器做成全可以写入的并且用宏指定小寄存器，这样做是为了跟 MARS 兼容**
4. **把 `prid` 做成 `32'h0` 是为了跟 MARS 兼容**
5. **跟 MARS 对拍时记得去掉不写 `cause` 且不需要处理中断就更新的部分，因为 MARS 没有这个机制；但是要加上发生异常或中断时清除软件中断位（即 `hwirq`），因为 MARS 有这个机制**
6. **实际上更新 `hwirq_i` 在进入中断的时候更新不行，因为进入中断后还得更新 `hwirq_i`；`have2handle == 1'b0` 可以不用判断，因为如果 `have2handle == 1'b1`，`write_enable` 早就被屏蔽了**

