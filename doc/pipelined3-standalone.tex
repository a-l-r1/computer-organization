\PassOptionsToPackage{unicode=true}{hyperref} % options for packages loaded elsewhere
\PassOptionsToPackage{hyphens}{url}
%

\documentclass[12pt,AutoFakeBold,AutoFakeSlant]{article}
% 12pt == 小四

\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\usepackage{unicode-math}

% use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
% use microtype if available

\IfFileExists{microtype.sty}{%
\usepackage[]{microtype}
\UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}

\usepackage{hyperref}
\hypersetup{
            pdfborder={0 0 0},
            breaklinks=true}
\urlstyle{same}  % don't use monospace font for urls

\usepackage{longtable,booktabs}

% Fix footnotes in tables (requires footnote package)
\IfFileExists{footnote.sty}{\usepackage{footnote}\makesavenoteenv{longtable}}{}
\setlength{\emergencystretch}{3em}  % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}

\usepackage{fontspec}
\usepackage{ctex}

\usepackage{indentfirst}
\usepackage{fullpage}

\setmainfont{Times New Roman}
\setmonofont{Courier New}
\setCJKmainfont{SimSun}
\setCJKmonofont{SimSun}

\usepackage{listings}
\lstset{basicstyle=\ttfamily,breaklines=true}

\usepackage[table,svgnames]{xcolor}
\usepackage{cellspace}
\usepackage{etoolbox}
\definecolor{headercolor}{RGB}{198,217,241} % #c6d9f1

\linespread{1.5} % https://tex.stackexchange.com/questions/30073/why-is-the-linespread-factor-as-it-is
\usepackage[tmargin=1in,bmargin=1in,lmargin=1.25in,rmargin=1.25in]{geometry} % word-like, see https://tex.stackexchange.com/questions/35892/latex-optimal-settings-for-ms-word-like-document
\setlength{\arrayrulewidth}{0.5pt}

\AtBeginEnvironment{longtable}{\rowcolors{0}{\ifnumless{\rownum}{3}{white}{headercolor}}{}}
\AtBeginEnvironment{longtable}{\zihao{5}}

\usepackage{nameref}
\makeatletter
\newcommand*{\currentname}{\@currentlabelname}
\makeatother
\newcounter{tablecaption}
\AtBeginEnvironment{longtable}{\stepcounter{tablecaption}\flushright{{\setlength\parskip{0pt}\heiti{表 \arabic{tablecaption} \currentname{}}}}\vspace*{-7pt}} % NOTE: hack since \caption in longtable breaks the current way of setting colors for table header

\newcommand{\headingcellfirst}[1]{\multicolumn{1}{|c|}{\heiti{#1}}} % NOTE: \DeclareRobustCommand has issues
\newcommand{\headingcellmiddle}[1]{\multicolumn{1}{c|}{\heiti{#1}}}
\newcommand{\headingcelllast}[1]{\multicolumn{1}{c|}{\heiti{#1}}}

\usepackage{makecell}
\usepackage{multirow}

\usepackage{mips}

\begin{document}

{
\setlength{\parskip}{\baselineskip}%

\begin{center}
\zihao{3}
\heiti{计算机组成原理实验报告}
\end{center}
}

\tableofcontents
\newpage

\hypertarget{npc}{%
\section{NPC}\label{npc}}

\hypertarget{ux539fux7406}{%
\subsection{原理}\label{ux539fux7406}}

NPC 是下个 PC 值的意思。它能做到根据当前的 PC 值，计算出下一个 32 位的
PC 值。

一般来说，PC 值的转换是顺序转换。但是，NPC
必须要听控制模块的指令，做到在某些条件下进行符号转换。

\hypertarget{ux63a5ux53e3ux5b9aux4e49}{%
\subsection{接口定义}\label{ux63a5ux53e3ux5b9aux4e49}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{curr\_pc} & 输入 & 32 & 当前 PC\tabularnewline\hline
\texttt{jump\_mode} & 输入 & 4 & 是否可以跳转\tabularnewline\hline
\texttt{cmp\_result} & 输入 & 2 & \texttt{cmp} 的比较结果\tabularnewline\hline
\texttt{cmp\_sig\_result} & 输入 & 2 & \texttt{cmp}
的有符号比较结果\tabularnewline\hline
\texttt{num} & 输入 & 16 & 输入的立即数\tabularnewline\hline
\texttt{jnum} & 输入 & 26 & 输入的 J 型指令的立即数\tabularnewline\hline
\texttt{reg\_} & 输入 & 32 & 输入的寄存器值\tabularnewline\hline
\texttt{epc} & 输入 & 32 & 输入的 \texttt{EPC} 值\tabularnewline\hline
\texttt{next\_pc} & 输出 & 32 & 下一个 PC\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49}}

用把宏定义成宏的方法，定义表中值为宏的宏。把一个宏定义成另一个宏，那该宏的意义与定义它的宏一样，表中省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{jump\_mode} & \texttt{NPC\_JUMP\_DISABLE} & 4'b0000 &
不要跳转\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_JUMP\_DISABLED} &
\texttt{NPC\_JUMP\_DISABLE} &\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_JUMP\_WHEN\_EQUAL} & 4'b0001 &
当输入的比较结果相等时跳转\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_JUMP\_WHEN\_EQUALS\_TO} &
\texttt{NPC\_JUMP\_WHEN\_EQUAL} &\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_EQUAL} &
\texttt{NPC\_JUMP\_WHEN\_EQUAL} &\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_JUMP\_WHEN\_NOT\_EQUAL} & 4'b0010 &
当输入的比较结果不等时跳转\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_JUMP\_WHEN\_NOT\_EQUALS\_TO} &
\texttt{NPC\_JUMP\_WHEN\_NOT\_EQUAL} &\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_NOT\_EQUAL} &
\texttt{NOT\_JUMP\_WHEN\_NOT\_EQUAL} &\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_REG} & 4'b1111 &
按照寄存器内地址跳转\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_J} & 4'b1110 & 按照 J
型指令的立即数跳转\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_LARGER} & 4'b0011 &
当输入的比较结果为大于时跳转\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_SMALLER} & 4'b0100 &
当输入的比较结果为小于时跳转\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_LARGER\_OR\_EQUAL} & 4'b0101 &
当输入的比较结果为大于或等于时跳转\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_SMALLER\_OR\_EQUAL} & 4'b0110 &
当输入的比较结果为小于或等于时跳转\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_SIG\_LARGER} & 4'b0111 &
当输入的有符号比较结果为大于时跳转\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_SIG\_SMALLER} & 4'b1000 &
当输入的有符号比较结果为小于时跳转\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_SIG\_LARGER\_OR\_EQUAL} & 4'b1001 &
当输入的有符号比较结果为大于或等于时跳转\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_SIG\_SMALLER\_OR\_EQUAL} & 4'b1010 &
当输入的有符号比较结果为小于或等于时跳转\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_ISR} & 4'b1101 & 跳转到固定地址
\texttt{NPC\_ISR\_ADDR}\tabularnewline\hline
\texttt{jump\_mode} & \texttt{NPC\_EPC} & 4'b1100 & 跳转到
\texttt{epc}\tabularnewline\hline

\end{longtable}

\texttt{comp\_result} 的相应数值代表的意义，与相应的宏有关，这些宏在
\texttt{alu.h} 中。

\hypertarget{ux529fux80fd}{%
\subsection{功能}\label{ux529fux80fd}}

令跳转基准地址 \texttt{base\ =\ \$unsigned(curr\_pc)}。

若 \texttt{jump\_mode\ ==\ NPC\_JUMP\_DISABLE}，则令
\texttt{next\_pc\ =\ \$unsigned(base)\ +\ \$unsigned(4)}。

若 \texttt{jump\_mode\ ==\ NPC\_JUMP\_WHEN\_EQUAL}，则
\texttt{alu\_comp\_result\ ==\ ALU\_EQUAL} 时，首先把 \texttt{num}
扩展成 32 位有符号立即数，扩展方式是首先把 \texttt{num} 后面加上
\texttt{2\textquotesingle{}b0}，然后把这 18 位二进制数扩展成 32
位有符号二进制数。然后令
\texttt{next\_pc\ =\ \$signed(base)\ +\ \$signed(num)}。否则做跟
\texttt{jump\_mode\ ==\ NPC\_JUMP\_DISABLE} 时相同的步骤。

若 \texttt{jump\_mode} 对应的意义有其它的比较，则 \texttt{cmp\_result}
或 \texttt{cmp\_sig\_result}
满足相应条件时，做跟上面相同的步骤。否则做跟
\texttt{jump\_mode\ ==\ NPC\_JUMP\_DISABLE} 时相同的步骤。

若 \texttt{jump\_mode\ ==\ NPC\_REG}，则令 \texttt{next\_pc\ =\ reg\_}。

若 \texttt{jump\_mode\ ==\ NPC\_J}，则令
\texttt{next\_pc\ =\ \{base{[}31:28{]},\ jnum,\ 2\textquotesingle{}b0\}}。

若 \texttt{jump\_mode\ ==\ NPC\_ISR}，则令
\texttt{next\_pc\ =\ IM\_ISR\_START\_ADDRESS}。

若 \texttt{jump\_mode\ ==\ NPC\_EPC}，则令 \texttt{next\_pc\ =\ epc}。

若 \texttt{jump\_mode} 为其它值，则做跟
\texttt{jump\_mode\ ==\ NPC\_JUMP\_DISABLE} 时相同的步骤。

\hypertarget{ux6ce8ux610fux4e8bux9879}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  NPC 是在内部进行符号扩展，不用 ext。
\item
  \texttt{reg\_} 是为了避免和 \texttt{reg} 冲突。
\item
  \texttt{base} 抽象出来是为了方便调试和维护，它是跟 MIPS
  指令集手册相符的。
\end{enumerate}

\hypertarget{pc}{%
\section{PC}\label{pc}}

\hypertarget{ux539fux7406-1}{%
\subsection{原理}\label{ux539fux7406-1}}

PC
是程序计数器的意思，负责对当前的指令进行计数。它是标记程序执行到哪里的一种方法，同时输出的信息也被送入指令内存
IM，用来取指。

PC 只负责表示程序执行到哪里，而 PC 的更新由 NPC
模块负责。这样可以做到更简便地处理跳转指令、也对流水线 CPU
插入气泡有帮助。

\hypertarget{ux7aefux53e3ux5b9aux4e49}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & 输入 & 1 & 时钟信号\tabularnewline\hline
\texttt{next\_pc} & 输入 & 32 & NPC 计算得来的下一个 PC
地址\tabularnewline\hline
\texttt{enable} & 输入 & 1 & PC 使能\tabularnewline\hline
\texttt{invalid} & 输出 & 1 & 不对齐的 PC 值\tabularnewline\hline
\texttt{curr\_pc} & 输出 & 32 & PC 地址\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-1}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-1}}

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{enable} & \texttt{PC\_ENABLED} & 1'b1 & PC 使能\tabularnewline\hline
\texttt{enable} & \texttt{PC\_ENABLE} & \texttt{PC\_ENABLED}
&\tabularnewline\hline
\texttt{enable} & \texttt{PC\_DISABLED} & 1'b0 & PC
非使能\tabularnewline\hline
\texttt{enable} & \texttt{PC\_DISABLE} & \texttt{PC\_DISABLED}
&\tabularnewline\hline
\texttt{curr\_pc} & \texttt{PC\_START\_ADDRESS} & 32'h00003000 & PC
的起始地址\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-1}{%
\subsection{功能}\label{ux529fux80fd-1}}

该部件是时序部件。

有一个 32 位的寄存器保存当前 PC 的值，初值为
\texttt{PC\_START\_ADDRESS}。

在每个时钟上升沿，若 \texttt{enable\ ==\ PC\_ENABLED}，则把 PC
部件中保存的当前 PC 的值更新成 \texttt{next\_pc} 的值。否则，保存的当前
PC 的值不变。

无论什么时候，输出端口 \texttt{curr\_pc} 的值都是 PC 部件中保存的当前 PC
的值，但是把最低两位无条件清零。若 PC 最低两位不为 0 或 PC
作为无符号数超出 \texttt{im} 中指定的上下界，则
\texttt{invalid\ ==\ 1\textquotesingle{}b1}。

\hypertarget{ux6ce8ux610fux4e8bux9879-1}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-1}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  PC 和 IM 的起始地址是分开定义的，改的时候要注意。
\item
  \textbf{比较 PC 是无符号数比较}
\end{enumerate}

\hypertarget{ux7a0bux5e8fux5b58ux50a8ux5668}{%
\section{程序存储器}\label{ux7a0bux5e8fux5b58ux50a8ux5668}}

\hypertarget{ux539fux7406-2}{%
\subsection{原理}\label{ux539fux7406-2}}

程序存储器是存储程序指令的地方。为了加载程序指令，它可以通过系统任务读取编译后的指令内容。

为了简便，程序存储器由许多寄存器实现。

\hypertarget{ux7aefux53e3ux5b9aux4e49-1}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-1}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{addr} & 输入 & \texttt{IM\_ADDR\_WIDTH} & 读地址\tabularnewline\hline
\texttt{enable} & 输入 & 1 & 使能信号\tabularnewline\hline
\texttt{result} & 输出 & 32 & 读到的结果\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-2}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-2}}

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{enable} & \texttt{IM\_ENABLE} & \texttt{1\textquotesingle{}b1} &
IM 使能\tabularnewline\hline
\texttt{enable} & \texttt{IM\_ENABLED} & \texttt{IM\_ENABLE}
&\tabularnewline\hline
\texttt{enable} & \texttt{IM\_DISABLE} & \texttt{1\textquotesingle{}b0}
& IM 非使能\tabularnewline\hline
\texttt{enable} & \texttt{IM\_DISABLED} & \texttt{IM\_DISABLE}
&\tabularnewline\hline
\texttt{addr} & \texttt{IM\_ADDR\_WIDTH} & 8 & \texttt{addr}
的位宽\tabularnewline\hline
\texttt{addr} & \texttt{IM\_START\_ADDRESS} & 32 & IM
对外表现的起始地址\tabularnewline\hline
\texttt{addr} & \texttt{IM\_ISR\_START\_ADDRESS} & 32 & IM 对外表现的
ISR 的起始地址\tabularnewline\hline
指令存储器 & \texttt{IM\_SIZE} & 64 & 能存储指令的个数\tabularnewline\hline
指令存储器 & \texttt{IM\_CODE\_FILENAME} & \texttt{"code.hex"} &
要加载的机器码\tabularnewline\hline
指令存储器 & \texttt{IM\_ISR\_FILENAME} & \texttt{"code\_handler.hex"} &
要加载的 ISR 的机器码\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-2}{%
\subsection{功能}\label{ux529fux80fd-2}}

有 \texttt{IM\_SIZE} 个 32
位存储器，代表其中存储的指令。它们初值应该使用加载文件的系统任务加载。加载文件名由
\texttt{IM\_CODE\_FILENAME} 指定。\texttt{im} 同样存储
ISR，也是用加载文件的系统任务加载，加载文件名由
\texttt{IM\_ISR\_FILENAME} 指定，加载地址由
\texttt{(\$unsigned(IM\_ISR\_START\_ADDRESS)\ -\ \$unsigned(IM\_START\_ADDRESS))\ \textgreater{}\textgreater{}\ \$unsigned(2)}
指定，一共加载 2047 个字。

若 \texttt{addr} 作为无符号数小于 \texttt{IM\_START\_ADDRESS}，则也返回
\texttt{32\textquotesingle{}b0}。否则，\texttt{result} 为
\texttt{addr\ -\ IM\_START\_ADDRESS} 这个地址再取
\texttt{{[}IM\_ADDR\_WIDTH\ -\ 1:2{]}}
对应的指令（从存储器中取得，是两个无符号数相减）。若相减后的结果超出了已经加载的指令所占的地址空间，则
\texttt{result} 为 \texttt{32\textquotesingle{}b0}。

\hypertarget{ux6ce8ux610fux4e8bux9879-2}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-2}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{IM\_ADDR\_WIDTH} 和 \texttt{IM\_SIZE}
  需要一块改，因为它们的大小有关系
\item
  有 offset 了，注意跟 offset 相减是无符号数相减
\item
  offset 主要是为了和 MARS 兼容
\item
  比较和移位都是无符号数操作，无符号数操作能保证算术移位
\end{enumerate}

\hypertarget{ux5bc4ux5b58ux5668ux5806}{%
\section{寄存器堆}\label{ux5bc4ux5b58ux5668ux5806}}

\hypertarget{ux539fux7406-3}{%
\subsection{原理}\label{ux539fux7406-3}}

寄存器堆保存着 32 位 32 个通用寄存器，负责存储 CPU
立刻想要的数据，它是存储器层次结构中的最高一级，负责暂存数据。第 0
号寄存器 \texttt{\$0} 的值永远是
\texttt{32\textquotesingle{}b0}，写入不会改变它的值。

由于 MIPS
体系结构中的指令最多读两个寄存器，写一个寄存器，所以寄存器输入两个要读的地址，输出两个要读的数据；输入一个要写的地址和一个要写的数据；同时还有写使能端口。

寄存器的使用没有规定，这一般是软件关心的问题。

\hypertarget{ux7aefux53e3ux5b9aux4e49-2}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-2}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & 输入 & 1 & 时钟信号\tabularnewline\hline
\texttt{curr\_pc} & 输入 & 32 & 当前 PC 的值\tabularnewline\hline
\texttt{read\_addr1} & 输入 & 5 & 第一个读地址\tabularnewline\hline
\texttt{read\_addr2} & 输入 & 5 & 第二个读地址\tabularnewline\hline
\texttt{write\_addr} & 输入 & 5 & 写地址\tabularnewline\hline
\texttt{write\_data} & 输入 & 32 & 要写入的数据\tabularnewline\hline
\texttt{write\_enable} & 输入 & 1 & 写使能\tabularnewline\hline
\texttt{read\_result1} & 输出 & 32 &
第一个读地址读出的数据\tabularnewline\hline
\texttt{read\_result2} & 输出 & 32 &
第二个读地址读出的数据\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-3}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-3}}

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{.*\_addr.*} & \texttt{RF\_ADDR\_ZERO} & 5'b0 &
零寄存器的地址\tabularnewline\hline
\texttt{.*\_addr.*} & \texttt{RF\_ZERO} & \texttt{RF\_ADDR\_ZERO}
&\tabularnewline\hline
\texttt{write\_enable} & \texttt{RF\_WRITE\_ENABLED} & 1'b1 &
寄存器堆使能\tabularnewline\hline
\texttt{write\_enable} & \texttt{RF\_WRITE\_ENABLE} &
\texttt{RF\_WRITE\_ENABLED} &\tabularnewline\hline
\texttt{write\_enable} & \texttt{RF\_WRITE\_DISABLED} & 1'b0 &
寄存器堆非使能\tabularnewline\hline
\texttt{write\_enable} & \texttt{RF\_WRITE\_DISABLE} &
\texttt{RF\_WRITE\_DISABLED} &\tabularnewline\hline
输出 & \texttt{RF\_OUTPUT\_FORMAT} &
\texttt{"\%d:\ 0x\%08x\ =\textgreater{}\ 0x\%08x"} &
输出模版\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-3}{%
\subsection{功能}\label{ux529fux80fd-3}}

该部件为时序部件。

有 31 个 32 位寄存器，代表
\texttt{\$1}\textasciitilde{}\texttt{\$31}，它们初值都为
\texttt{32\textquotesingle{}b0}。\texttt{\$0} 实际上不需要寄存器。

在每个时钟上升沿，若 \texttt{write\_enable\ ==\ RF\_WRITE\_ENABLED} 且
\texttt{write\_addr\ !=\ RF\_ADDR\_ZERO}，则说明可以执行写操作，且写到的寄存器是可以保存数值的寄存器。此时把
\texttt{write\_addr} 指代的寄存器的值更新为
\texttt{write\_data}。更新时，以模版中的格式打印出数据变化，第一个参数是当前的模拟时钟的时间，第二个参数是当前
PC 的值，第三个参数是寄存器号，第四个参数是更新后的值。

无论什么时候，若 \texttt{read\_addr1\ !=\ RF\_ADDR\_ZERO}，则把
\texttt{read\_addr1} 指代的寄存器的值输出到 \texttt{read\_result1}
中，否则把 \texttt{32\textquotesingle{}b0} 输出到 \texttt{read\_result1}
中。对 \texttt{read\_addr2} 和 \texttt{read\_result2} 的相应操作相同。

\hypertarget{ux6ce8ux610fux4e8bux9879-3}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-3}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  暂时还没有内部转发。
\item
  寄存器可以定义为 \texttt{reg\ {[}31:1{]}\ registers\ {[}31:0{]}}，把
  \texttt{\$0} 空出来。
\item
  TODO: 应该把正常显示 wrap 起来，等到 ISE 装好后再说
\end{enumerate}

\hypertarget{ux6bd4ux8f83ux6a21ux5757}{%
\section{比较模块}\label{ux6bd4ux8f83ux6a21ux5757}}

\hypertarget{ux539fux7406-4}{%
\subsection{原理}\label{ux539fux7406-4}}

比较模块通过比较两个寄存器的数据，实现分支指令和条件传送指令的提前跳转，提高跳转的效率。

\hypertarget{ux63a5ux53e3ux5b9aux4e49-1}{%
\subsection{接口定义}\label{ux63a5ux53e3ux5b9aux4e49-1}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{reg1} & 输入 & 32 & 第一个寄存器的输入\tabularnewline\hline
\texttt{reg2} & 输入 & 32 & 第二个寄存器的输入\tabularnewline\hline
\texttt{cmp} & 输出 & 2 & 无符号比较结果输出\tabularnewline\hline
\texttt{sig\_cmp} & 输出 & 2 & 有符号比较结果输出\tabularnewline\hline
\texttt{reg2\_sig\_cmp} & 输出 & 2 & \texttt{reg2} 与 0
的有符号比较结果输出\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-4}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-4}}

把 \texttt{CMP\_LARGER,\ CMP\_SMALLER,\ CMP\_EQUAL} 分别定义成
\texttt{ALU\_LARGER,\ ALU\_SMALLER,\ ALU\_EQUAL}。

\hypertarget{ux529fux80fd-4}{%
\subsection{功能}\label{ux529fux80fd-4}}

在 \texttt{comp,\ sig\_comp,\ reg2comp}
三个输出端口分别输出第一个寄存器与第二个寄存器作为无符号数的比较结果、它们作为有符号数的比较结果和第二个寄存器与
0 作为有符号数的比较结果。

\hypertarget{ux6269ux5c55ux5668}{%
\section{扩展器}\label{ux6269ux5c55ux5668}}

\hypertarget{ux529fux80fd-5}{%
\subsection{功能}\label{ux529fux80fd-5}}

扩展器是专门执行扩展整数功能的运算。它能做到小于 32 位的整数向 32
位整数的转换，其中有符号转换，也有无符号转换。

转换器的模式由宏定义的方式指定，有符号扩展，也有无符号扩展，也有其它模式。由于没有明显的层次和类别关系，采用顺序编号和按常见顺序编号的方法。

\hypertarget{ux63a5ux53e3ux5b9aux4e49-2}{%
\subsection{接口定义}\label{ux63a5ux53e3ux5b9aux4e49-2}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{num} & 输入 & 16 & 输入的数字\tabularnewline\hline
\texttt{mode} & 输入 & 3 & 模式\tabularnewline\hline
\texttt{result} & 输出 & 32 & 扩展的结果\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-5}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-5}}

用把宏定义成宏的方法，定义表中值为宏的宏。把一个宏定义成另一个宏，那该宏的意义与定义它的宏一样，表中省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{mode} & \texttt{EXT\_MODE\_SIGNED} & 3'b000 &
符号扩展\tabularnewline\hline
\texttt{mode} & \texttt{EXT\_SIGNED} & \texttt{EXT\_MODE\_SIGNED}
&\tabularnewline\hline
\texttt{mode} & \texttt{EXT\_MODE\_UNSIGNED} & 3'b001 &
无符号扩展\tabularnewline\hline
\texttt{mode} & \texttt{EXT\_UNSIGNED} & \texttt{EXT\_MODE\_UNSIGNED}
&\tabularnewline\hline
\texttt{mode} & \texttt{EXT\_MODE\_PAD} & 3'b010 & 把输入的 16
位填充到输出结果的高 16 位，输出结果低 16 位置零的扩展\tabularnewline\hline
\texttt{mode} & \texttt{EXT\_PAD} & \texttt{EXT\_MODE\_PAD}
&\tabularnewline\hline
\texttt{mode} & \texttt{EXT\_MODE\_HIGH\_BITS} & \texttt{EXT\_MODE\_PAD}
&\tabularnewline\hline
\texttt{mode} & \texttt{EXT\_HIGH\_BITS} & \texttt{EXT\_MODE\_PAD}
&\tabularnewline\hline
\texttt{mode} & \texttt{EXT\_MODE\_ONE} & 3'b011 & 在数字前面填充二进制
1 的扩展\tabularnewline\hline
\texttt{mode} & \texttt{EXT\_ONE} & \texttt{EXT\_MODE\_ONE}
&\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-6}{%
\subsection{功能}\label{ux529fux80fd-6}}

若 \texttt{mode}
的值为合法操作（即上面``宏定义''一节中列出的操作），按照 \texttt{mode}
中给出的操作计算出结果，并把结果放入 \texttt{result} 中。

若 \texttt{mode} 的值为非法操作，就令
\texttt{result\ =\ 32\textquotesingle{}b0}。

\hypertarget{alu}{%
\section{ALU}\label{alu}}

\hypertarget{ux539fux7406-5}{%
\subsection{原理}\label{ux539fux7406-5}}

ALU 是运算控制单元的意思，负责两个 32
位整数的运算。它可以负责各种运算，包括数学运算和逻辑运算。易知它是纯组合逻辑。

由于定义运算的时候需要给运算编码，所以表示运算就有点类似于 C 语言中的
\texttt{enum}。因此，需要对各种运算进行宏定义，以保证系统的可维护性。宏定义也可以把定义的数据空间分隔开，以及对运算按照逻辑进行排序，从而得到对端口运算编码的更好理解。

\hypertarget{ux7aefux53e3ux5b9aux4e49-3}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-3}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{num1} & 输入 & 32 & 第一个操作数\tabularnewline\hline
\texttt{num2} & 输入 & 32 & 第二个操作数\tabularnewline\hline
\texttt{shamt} & 输入 & 5 & 移位运算的移位位数\tabularnewline\hline
\texttt{op} & 输入 & 5 & 操作符\tabularnewline\hline
\texttt{result} & 输出 & 32 & 结果\tabularnewline\hline
\texttt{cmp\_result} & 输出 & 2 & 作为无符号数的比较结果\tabularnewline\hline
\texttt{sig\_cmp\_result} & 输出 & 2 &
作为有符号数的比较结果\tabularnewline\hline
\texttt{overflow} & 输出 & 1 & 计算过程中是否发生溢出\tabularnewline\hline
\texttt{sig\_overflow} & 输出 & 1 &
计算过程中是否发生补码溢出\tabularnewline\hline
\texttt{op\_invalid} & 输出 & 1 & 操作符是否无效\tabularnewline\hline

\end{longtable}

由于在硬件层级对数的加减都是无符号数加减法，所以这里的溢出，是指操作过程中出现了做无符号数加减法时结果超出无符号数范围的现象。

\hypertarget{ux5b8fux5b9aux4e49-6}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-6}}

采用操作符最高两位区分类别的方法定义宏。用把宏定义成宏的方法，定义表中值为宏的宏。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{op} & \texttt{ALU\_ADD} & 5'b00000 & 加法运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_UNSIGNED\_ADD} & \texttt{ALU\_ADD} &
同上\tabularnewline\hline
\texttt{op} & \texttt{ALU\_SUB} & 5'b00001 & 减法运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_UNSIGNED\_SUB} & \texttt{ALU\_SUB} &
同上\tabularnewline\hline
\texttt{op} & \texttt{ALU\_AND} & 5'b10000 & 按位与运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_BITWISE\_AND} & \texttt{ALU\_AND} &
同上\tabularnewline\hline
\texttt{op} & \texttt{ALU\_OR} & 5'b10001 & 按位或运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_BITWISE\_OR} & \texttt{ALU\_OR} &
同上\tabularnewline\hline
\texttt{op} & \texttt{ALU\_NOT} & 5'b10010 & 按位非运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_BITWISE\_NOT} & \texttt{ALU\_NOT} &
同上\tabularnewline\hline
\texttt{op} & \texttt{ALU\_XOR} & 5'b10011 & 按位异或运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_MOVZ} & 5b'00010 &
数据转移运算（{[}1{]}）\tabularnewline\hline
\texttt{op} & \texttt{ALU\_NOR} & 5'b10100 & 按位或非运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_SLT} & 5'b00011 &
若小于则设置运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_SLTU} & 5'b00100 &
无符号的若小于则设置运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_SLL} & 5'b10101 & 左移位运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_SRL} & 5'b10110 &
逻辑右移位运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_SRA} & 5'b10111 &
算数右移位运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_SLLV} & 5'b11000 &
寄存器为参数的左移位运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_SRLV} & 5'b11001 &
寄存器为参数的逻辑右移位运算\tabularnewline\hline
\texttt{op} & \texttt{ALU\_SRAV} & 5'b11110 &
寄存器为参数的算数右移位运算\tabularnewline\hline
\texttt{.*cmp\_result} & \texttt{ALU\_EQUAL} & 2b'00 &
等于\tabularnewline\hline
\texttt{.*cmp\_result} & \texttt{ALU\_EQUAL\_TO} & \texttt{ALU\_EQUAL} &
同上\tabularnewline\hline
\texttt{.*cmp\_result} & \texttt{ALU\_LARGER} & 2b'01 &
大于\tabularnewline\hline
\texttt{.*cmp\_result} & \texttt{ALU\_LARGER\_THAN} &
\texttt{ALU\_LARGER} & 同上\tabularnewline\hline
\texttt{.*cmp\_result} & \texttt{ALU\_SMALLER} & 2b'10 &
小于\tabularnewline\hline
\texttt{.*cmp\_result} & \texttt{ALU\_SMALLER\_THAN} &
\texttt{ALU\_SMALLER} & 同上\tabularnewline\hline
\texttt{overflow} & \texttt{ALU\_OVERFLOW} & 1'b1 & 溢出\tabularnewline\hline
\texttt{overflow} & \texttt{ALU\_NOT\_OVERFLOW} & 1'b0 &
未溢出\tabularnewline\hline
\texttt{op\_invalid} & \texttt{ALU\_INVALID\_OP} & 1'b1 &
操作符无效\tabularnewline\hline
\texttt{op\_invalid} & \texttt{ALU\_INVALID} & \texttt{ALU\_INVALID\_OP}
& 同上\tabularnewline\hline
\texttt{op\_invalid} & \texttt{ALU\_VALID\_OP} & 1'b0 &
操作符有效\tabularnewline\hline
\texttt{op\_invalid} & \texttt{ALU\_VALID} & \texttt{ALU\_VALID\_OP} &
同上\tabularnewline\hline

\end{longtable}

注：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  数据转移运算只是简单地让结果等于第一个操作数，因为真正转不转移是控制模块判断写入哪个寄存器决定的。
\end{enumerate}

\hypertarget{ux529fux80fd-7}{%
\subsection{功能}\label{ux529fux80fd-7}}

若 \texttt{op} 的值为合法操作（即上面``宏定义''一节中列出的操作），按照
\texttt{op} 中给出的操作计算出结果，并把结果放入 \texttt{result}
中。然后把输入的数看成无符号数并比较，若发生上面提到的溢出现象，就令
\texttt{overflow} 或 \texttt{sig\_overflow} 为
\texttt{1\textquotesingle{}b1}，否则为
\texttt{1\textquotesingle{}b0}。注意不管 \texttt{num{[}12{]}}
输入的原来意义是什么，都把它看成无符号数进行计算。

检查无符号溢出的方式是用一个 33
位的中间变量，在加减法时用同样的方法算出该中间变量的值。如果有溢出，那它的最高位应该为
1，否则为 0。在做其它运算时，把这个中间变量变为恒 0。

检查有符号溢出的方式是利用另一个的中间变量，它是 33
位的。在加减法时用同样的方法算出该中间变量的值，但是在算以前进行符号扩展，算的时候把这两个数作为有符号数计算。对其它运算，它置为
\texttt{33\textquotesingle{}b0}。如果它的符号位与 \texttt{result}
的符号位相同，就说明没有溢出，否则有溢出。这是因为有符号加减法溢出都是上溢或者下溢，符号是一定要变化的。而把它们有符号扩展到
33
位再计算，计算结果一定不会溢出。把正确的结果的符号位和实际结果的符号位一比较，就可以知道是否发生溢出了。

如果 \texttt{op} 的值为非法操作，就令 \texttt{op\_invalid} 为
\texttt{1\textquotesingle{}b1}，否则为
\texttt{1\textquotesingle{}b0}。此时令 \texttt{result} 为
\texttt{32\textquotesingle{}b0}。

\texttt{.*cmp\_result} 的值仅由 \texttt{num{[}12{]}}
确定，与其它输入无关。\texttt{.*cmp\_result}
的比较方式，在端口定义中。比较的输出结果，在宏定义中。不会输出宏定义中没有定义的结果。

若小于则设置运算指的是把 \texttt{alu.num1} 和 \texttt{alu.num2}
作为有符号数比较，若 \texttt{alu.num1\ \textless{}\ alu.num2}，则
\texttt{result\ =\ 32\textquotesingle{}b1}，否则
\texttt{result\ =\ 32\textquotesingle{}b0}。无符号的若小于则设置运算是把要比较的两个数作为无符号数比较，之后和若小于则设置运算相同。

左右移位运算如果不说以寄存器为参数，就用 \texttt{shamt}
作为移位位数，否则用 \texttt{num1} 的最后 5
位作为移位位数。所有的移位运算都是对 \texttt{num2} 进行移位。如果当前
\texttt{op} 不对应移位运算，则移位位数为 0。

\hypertarget{ux6ce8ux610fux4e8bux9879-4}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-4}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  添加新运算时注意同时改 \texttt{op\_invalid} 的输出和 \texttt{result}
  的输出
\item
  如果不确定符号，就加上 \texttt{{[}un\textbar{}{]}signed}
\item
  由于 ISE 不支持以变量为位数对标量切片，所以只能提前穷举移位位数的 31
  种情况，然后进行切片，如果移位位数不属于 {[}0,
  31{]}，那么切片结果是原来的标量
\end{enumerate}

\hypertarget{ux4e58ux9664ux6cd5ux5668}{%
\section{乘除法器}\label{ux4e58ux9664ux6cd5ux5668}}

\hypertarget{ux539fux7406-6}{%
\subsection{原理}\label{ux539fux7406-6}}

乘除法器是 MIPS
体系结构中运算代价比较高的部件，需要多个时钟周期进行运算。因此，它必须要有
\texttt{busy}
信号指定它是不是忙，通过是不是忙来让控制模块决定暂停和转发。

两个 32 位数的乘法结果是 64 位，所以需要两个 32
位寄存器。同样地，除法有商和余数，所以也需要两个 32
位寄存器。总结起来，乘除法器需要两个 32
位寄存器。乘法有高低位的区别，把它们叫做 \texttt{HI} 和 \texttt{LO}
寄存器能区分过来。

乘除法需要多个周期，但是模拟时乘除法只要一个周期。因此，需要在乘除法器内部设定一个计时器，模拟需要多个周期乘除法的行为。还没有准备好时，就在
\texttt{HI} 和 \texttt{LO} 寄存器输出代替的值。

\hypertarget{ux7aefux53e3ux5b9aux4e49-4}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-4}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
clk & 输入 & 1 & 时钟信号\tabularnewline\hline
dh & 输入 & 32 & 第一个输入的数据\tabularnewline\hline
dl & 输入 & 32 & 第二个输入的数据\tabularnewline\hline
op & 输入 & 4 & 需要的操作\tabularnewline\hline
undo & 输出 & 1 & 根据当前操作恢复 \texttt{HI} 和 \texttt{LO}
寄存器的值或者停止运算\tabularnewline\hline
busy & 输出 & 1 & 乘除法器是否繁忙\tabularnewline\hline
invalid & 输出 & 1 & 乘除法操作是否非法\tabularnewline\hline
hi & 输出 & 32 & \texttt{HI} 寄存器的值\tabularnewline\hline
lo & 输出 & 32 & \texttt{LO} 寄存器的值\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-7}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-7}}

各宏的意义如果是对应的操作，就省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{op} & \texttt{MD\_NONE} & \texttt{4\textquotesingle{}d0000}
&\tabularnewline\hline
\texttt{op} & \texttt{MD\_MFHI} & \texttt{4\textquotesingle{}d0001}
&\tabularnewline\hline
\texttt{op} & \texttt{MD\_MFLO} & \texttt{4\textquotesingle{}d0010}
&\tabularnewline\hline
\texttt{op} & \texttt{MD\_MTHI} & \texttt{4\textquotesingle{}d0011}
&\tabularnewline\hline
\texttt{op} & \texttt{MD\_MTLO} & \texttt{4\textquotesingle{}d0100}
&\tabularnewline\hline
\texttt{op} & \texttt{MD\_MULT} & \texttt{4\textquotesingle{}d0101}
&\tabularnewline\hline
\texttt{op} & \texttt{MD\_MULTU} & \texttt{4\textquotesingle{}d0110}
&\tabularnewline\hline
\texttt{op} & \texttt{MD\_DIV} & \texttt{4\textquotesingle{}d0111}
&\tabularnewline\hline
\texttt{op} & \texttt{MD\_DIVU} & \texttt{4\textquotesingle{}d1000}
&\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-8}{%
\subsection{功能}\label{ux529fux80fd-8}}

该部件为时序部件，所有寄存器初值为 0.

有一个 4 位宽的计时器 ctr。

无论什么时候，\texttt{hi} 和 \texttt{lo} 都分别是 \texttt{hi\_reg} 和
\texttt{lo\_reg} 的内容。无论什么时候，\texttt{busy} 都是 \texttt{ctr}
作为无符号数大于 0 时为 \texttt{1\textquotesingle{}b1}，否则为
\texttt{1\textquotesingle{}b0}。\texttt{invalid} 都是
\texttt{(op\_i\ ==\ MD\_DIV\ \textbar{}\textbar{}\ op\_i\ ==\ MD\_DIVU)\ \&\&\ dl\_i\ ==\ 32\textquotesingle{}b0}
时为 1'b1，否则为 1'b0。检查内部寄存器是因为内部寄存器才是 \texttt{md}
内保存的真正状态，而且在一个时钟周期内检查来得及。

每个时钟上升沿，若计时器 \texttt{ctr} 的值作为无符号数大于 1，则把
\texttt{ctr} 减 1。否则，若 \texttt{ctr} 的值作为无符号数等于 1，则令
\texttt{hi\_reg} 和 \texttt{lo\_reg} 分别为 \texttt{dh\_i} 和
\texttt{dl\_i}
寄存器在相应运算下的结果，\texttt{hi\_reg\ \textless{}=\ old\_hi,\ lo\_reg\ \textless{}=\ old\_lo}。否则，什么也不做。

每个时钟下降沿，若
\texttt{op\ ==\ MD\_NONE\ \textbar{}\textbar{}\ stop\ ==\ 1\textquotesingle{}b1\ \textbar{}\textbar{}\ restore\ ==\ 1\textquotesingle{}b1}，则什么也不做。

否则，若
\texttt{op\ ==\ MD\_MTHI\ \textbar{}\textbar{}\ op\ ==\ MD\_MTLO}，则把
\texttt{dh}
的值写入相应的寄存器，\texttt{op\_i\ \textless{}=\ op}，\texttt{old\_hi\ \textless{}=\ hi\_reg;\ old\_lo\ \textless{}=\ lo\_reg}。若
\texttt{op\ ==\ MD\_MFHI\ \textbar{}\textbar{}\ op\ ==\ MD\_MFLO}，也是什么也不做，因为控制模块会自动选择相应的寄存器作为要读取的值。若
\texttt{op\ ==\ MD\_MULT\ \textbar{}\textbar{}\ op\ ==\ MD\_MULTU\ \textbar{}\textbar{}\ op\ ==\ MD\_DIV\ \textbar{}\textbar{}\ op\ ==\ MD\_DIVU}，则把
\texttt{ctr} 设置成对应的数值，而且把内部 \texttt{dh\_i}、\texttt{dl\_i}
和 \texttt{op\_i} 寄存器的值分别设置成 \texttt{dh}、\texttt{dl}和
\texttt{op}。乘法操作 \texttt{ctr} 初值是 5，除法操作 \texttt{ctr}
初值是 10。若 \texttt{op} 为其它值，也是什么也不做。

\hypertarget{ux6ce8ux610fux4e8bux9879-5}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-5}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{除法是把 \texttt{dh} 当被除数，\texttt{dl}
  当除数。但结果表示的时候，\texttt{hi} 当余数，\texttt{lo} 当商。若
  \texttt{dl\ ==\ 32\textquotesingle{}b0}，则不生成新的结果，\texttt{hi}
  和 \texttt{lo} 保持原来的结果，这是为了跟 MARS
  保持兼容，但是要覆盖保存的旧的 \texttt{hi} 和 \texttt{lo}
  寄存器的值为原来的结果，因为这样跟进入 ISR
  有关的复位操作在机制不变的情况下逻辑上才能说得过去}
\item
  \textbf{没有考虑第一条指令是 \texttt{CAL\_M}
  类指令，但是时钟没有下降沿的情况。}
\item
  \textbf{\texttt{restore\ /\ stop}
  信号只是名字上有指示，实际上如果出现了这种信号，下一个时钟下降沿就不会更新了，也不需要在下一个时钟上升沿复位}
\item
  \textbf{若 E 级指令为对应的指令，下降沿不会执行
  \texttt{mthi\ /\ mtlo\ /\ mfhi\ /\ mflo}，不过进 ISR
  时会在下个上升沿恢复；但是若 E
  级指令为其它指令，不会做任何撤销操作。这是因为乘除法会在后台进行，若
  ISR
  中需要乘除法指令则符合逻辑，否则也不影响正常计算，同样符合逻辑。即使
  ISR 中做了乘除法计算出 ISR
  后再用，需要计算结果的时候暂停机制也能保证暂停，也是符合逻辑的。即使
  ISR
  中需要乘除法指令，也不会轻易覆盖原来正在执行的乘除法指令的内容，因为还有暂停机制}
\item
  \textbf{不用担心取消了对 \texttt{ctr}
  的判断以后会出现操作做到一半被覆盖的问题，因为有 \texttt{busy}
  信号撑着，因为暂停机制，下一个能操作 \texttt{md} 的指令进不到 E 级来}
\end{enumerate}

\hypertarget{ux6570ux636eux5b58ux50a8ux5668}{%
\section{数据存储器}\label{ux6570ux636eux5b58ux50a8ux5668}}

\hypertarget{ux539fux7406-7}{%
\subsection{原理}\label{ux539fux7406-7}}

数据存储器是存储数据的地方。

为了简便，数据存储器由许多寄存器实现。

\hypertarget{ux7aefux53e3ux5b9aux4e49-5}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-5}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & 输入 & 1 & 时钟信号\tabularnewline\hline
\texttt{curr\_pc} & 输入 & 32 & 当前 PC 值\tabularnewline\hline
\texttt{addr} & 输入 & 32 & 读写的地址\tabularnewline\hline
\texttt{write\_data} & 输入 & 32 & 写数据\tabularnewline\hline
\texttt{write\_enable} & 输入 & 1 & 写使能信号\tabularnewline\hline
\texttt{mode} & 输入 & 3 & 模式选择\tabularnewline\hline
\texttt{read\_result} & 输出 & 32 & 读到的结果\tabularnewline\hline
\texttt{invalid} & 输出 & 1 & 地址是否错误\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-8}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-8}}

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{write\_enable} & \texttt{DM\_WRITE\_ENABLE} &
\texttt{1\textquotesingle{}b1} & DM 使能\tabularnewline\hline
\texttt{write\_enable} & \texttt{DM\_WRITE\_ENABLED} &
\texttt{DM\_WRITE\_ENABLE} &\tabularnewline\hline
\texttt{write\_enable} & \texttt{DM\_WRITE\_DISABLE} &
\texttt{1\textquotesingle{}b0} & DM 非使能\tabularnewline\hline
\texttt{write\_enable} & \texttt{DM\_WRITE\_DISABLED} &
\texttt{DM\_WRITE\_DISABLE} &\tabularnewline\hline
\texttt{mode} & \texttt{DM\_NONE} & 3'b000 & 不操作
\texttt{dm}\tabularnewline\hline
\texttt{mode} & \texttt{DM\_W} & 3'b001 & 读取/写入一个字\tabularnewline\hline
\texttt{mode} & \texttt{DM\_H} & 3'b011 & 读取/写入半个字\tabularnewline\hline
\texttt{mode} & \texttt{DM\_HU} & 3'b010 &
读取半个字，按无符号数读取\tabularnewline\hline
\texttt{mode} & \texttt{DM\_B} & 3'b101 &
读取/写入一个字节\tabularnewline\hline
\texttt{mode} & \texttt{DM\_BU} & 3'b110 &
读取一个字节，按无符号数读取\tabularnewline\hline
\texttt{.*\_addr} & \texttt{DM\_ADDR\_WIDTH} & 8 & \texttt{.*\_addr}
的位宽\tabularnewline\hline
指令存储器 & \texttt{DM\_SIZE} & 64 & 能存储 32
位字的个数\tabularnewline\hline
地址范围 & \texttt{DM\_ADDR\_UB} & 32 & \texttt{dm}
的地址上界\tabularnewline\hline
地址范围 & \texttt{DM\_ADDR\_LB} & 32 & \texttt{dm}
的地址下界\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-9}{%
\subsection{功能}\label{ux529fux80fd-9}}

该部件为时序部件。

有 \texttt{DM\_SIZE} 个 32 位存储器，代表其中存储的指令。它们初值都为
\texttt{32\textquotesingle{}b0}。

首先得出操作地址 \texttt{op\_addr}。若
\texttt{write\_enable\ ==\ DM\_ENABLED}，则操作地址为写地址，否则操作地址为读地址。

然后确定操作是否合法。若
\texttt{mode\ ==\ DM\_NONE\ \textbar{}\textbar{}\ (mode\ ==\ DM\_W\ \&\&\ op\_addr{[}1:0{]}\ ==\ 2\textquotesingle{}b0)\ \textbar{}\textbar{}\ (mode\ ==\ DM\_H\ \&\&\ op\_addr{[}0{]}\ ==\ 1\textquotesingle{}b0)\ \textbar{}\textbar{}\ (mode\ ==\ DM\_HU\ \&\&\ op\_addr{[}0{]}\ =\ 1\textquotesingle{}b0)\ \textbar{}\textbar{}\ mode\ ==\ DM\_B\ \textbar{}\textbar{}\ mode\ ==\ DM\_BU}
而且
\texttt{\$unsigned(op\_addr)\ \textgreater{}=\ DM\_ADDR\_LB\ \&\&\ \$unsigned(op\_addr)\ \textless{}=\ DM\_ADDR\_UB}，则操作合法，否则操作不合法。

在每个时钟上升沿，若
\texttt{write\_enable\ ==\ DM\_ENABLED\ \&\&\ invalid\ ==\ 0}，则根据操作模式写入相应地址对应的数据。写入半个字和字节分别取
\texttt{write\_data} 的低 16 位和低 8 位。同时，打印当前 PC
的值、\texttt{write\_addr}
对应的字和它对应字的新值。如果是写入半个字或者字节，也打印对应字的新值。

任何时候，若 \texttt{invalid\ ==\ 1\textquotesingle{}b1}，则
\texttt{read\_result\ ==\ 32\textquotesingle{}b0}。否则，若
\texttt{mode\ ==\ DM\_NONE}，则
\texttt{read\_result\ ==\ 32\textquotesingle{}b0}。若 \texttt{mode}
为其它 \texttt{dm} 宏的值，则按照相应宏的意义读出数据，读到
\texttt{read\_result} 中。若 \texttt{mode} 为其他值，则
\texttt{read\_result\ ==\ 32\textquotesingle{}b0}。

注意 \texttt{dm} 内部对 \texttt{write\_addr} 和 \texttt{read\_addr}
都截取了一部分。这样可以把 \texttt{dm}
直接接入数据通路，在数据通路中假定地址是 32 位的；同时 \texttt{dm}
的实现不需要那么多寄存器，更现实。但是实际上这样对地址空间进行了限制。

\hypertarget{ux6ce8ux610fux4e8bux9879-6}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-6}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{DM\_ADDR\_WIDTH} 和 \texttt{DM\_ADDR\_SIZE} 要一块改
\item
  地址空间是被截断的，看起来是 32 位，实际上不是
\item
  \textbf{CPU 是小端序的}
\item
  为了能打印出写到的字的值，可以把值提前用组合电路算出来
\end{enumerate}

\hypertarget{ux8bbeux5907ux6865}{%
\section{设备桥}\label{ux8bbeux5907ux6865}}

\hypertarget{ux539fux7406-8}{%
\subsection{原理}\label{ux539fux7406-8}}

设备桥是通过把设备的寄存器地址映射成数据内存地址，从而做到读写设备的寄存器，进而做到对设备的控制的。设备桥通过地址，把多个设备抽象成一个设备，从而避免了
CPU 识别设备的进一步开销。

设备桥对每个设备都需要知道它的寄存器特征和地址范围，这样才能做到有效地对设备的寄存器进行操作。地址范围不能跟数据内存的地址范围重叠，否则会造成冲突，而且无法对地址进行有效的抽象。

\hypertarget{ux7aefux53e3ux5b9aux4e49-6}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-6}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & 输入 & 1 & 时钟信号\tabularnewline\hline
\texttt{rst} & 输入 & 1 & 复位信号\tabularnewline\hline
\texttt{addr} & 输入 & 32 & 地址信号\tabularnewline\hline
\texttt{write\_enable} & 输入 & 1 & CPU
决定的设备写使能信号\tabularnewline\hline
\texttt{write\_data} & 输入 & 32 & CPU 要写入的数据\tabularnewline\hline
\texttt{read\_result} & 输出 & 32 & CPU 读取的数据\tabularnewline\hline
\texttt{hwirq} & 输出 & 6 & 硬件中断请求输出\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-9}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-9}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
设备地址 & \texttt{BRIDGE\_TIMER0\_LB} &
\texttt{32\textquotesingle{}h00007f00} & 第一个 \texttt{timer}
的地址下界\tabularnewline\hline
设备地址 & \texttt{BRIDGE\_TIMER0\_UB} &
\texttt{32\textquotesingle{}h00007f0b} & 第一个 \texttt{timer}
的地址上界\tabularnewline\hline
设备地址 & \texttt{BRIDGE\_TIMER1\_LB} &
\texttt{32\textquotesingle{}h00007f10} & 第二个 \texttt{timer}
的地址下界\tabularnewline\hline
设备地址 & \texttt{BRIDGE\_TIMER1\_UB} &
\texttt{32\textquotesingle{}h00007f1b} & 第二个 \texttt{timer}
的地址上界\tabularnewline\hline
设备地址 & \texttt{BRIDGE\_TIMER0\_BASE} &
\texttt{32\textquotesingle{}h00007f00} & 第一个 \texttt{timer}
的基址\tabularnewline\hline
设备地址 & \texttt{BRIDGE\_TIMER0\_BASE} &
\texttt{32\textquotesingle{}h00007f10} & 第二个 \texttt{timer}
的基址\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-10}{%
\subsection{功能}\label{ux529fux80fd-10}}

如果地址落在某个 \texttt{timer} 的地址范围内，就令这个 \texttt{timer}
的写使能与 \texttt{write\_enable} 相同，这个 \texttt{timer} 的
\texttt{read\_result} 为要输出的值。其余的 \texttt{timer}
屏蔽写使能。否则，\texttt{read\_result} 为
\texttt{32\textquotesingle{}b0}。

无论什么时候，\texttt{clk} 和 \texttt{rst} 的值都接入每个
\texttt{timer}。这是为了方便整体时钟信号同步和复位。\texttt{hwirq}
的最低位为第一个 \texttt{timer} 的 \texttt{irq}，倒数第二低位为第二个
\texttt{timer} 的 \texttt{irq}。

\hypertarget{ux6ce8ux610fux4e8bux9879-7}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-7}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{15 号设备（\texttt{curr\_dev} 表示的）代表没有设备，14
  号设备代表 \texttt{dm}}
\item
  \textbf{地址比较用无符号数比较}
\item
  \textbf{地址上下界以字节为单位，而且是包括边界的}
\end{enumerate}

\hypertarget{ux5730ux5740ux68c0ux67e5ux5668}{%
\section{地址检查器}\label{ux5730ux5740ux68c0ux67e5ux5668}}

\hypertarget{ux539fux7406-9}{%
\subsection{原理}\label{ux539fux7406-9}}

因为 p7 中引入了异常和中断，所以需要有一种检查地址的机制。但是，p7
里也引入了对设备的读写，而且和对 \texttt{dm}
的读写多少是统一的。所以，为了把对读写地址和模式的检查抽象出来，可以用地址检查器来实现。

\hypertarget{ux7aefux53e3ux5b9aux4e49-7}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-7}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{addr} & 输入 & 32 & 当前读写 \texttt{dm} 或 \texttt{bridge}
的地址\tabularnewline\hline
\texttt{dm\_mode} & 输入 & 3 & 当前 \texttt{dm} 的模式\tabularnewline\hline
\texttt{validity} & 输出 & 3 &
当前地址在当前模式下的有效性\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-10}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-10}}

地址检查器也使用 \texttt{dm} 和 \texttt{bridge} 的宏。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
地址有效性 & \texttt{AC\_VALID} & 3'd0 & 地址有效\tabularnewline\hline
地址有效性 & \texttt{AC\_BAD} & 3'd1 & 读取时地址无效\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-11}{%
\subsection{功能}\label{ux529fux80fd-11}}

若当前地址超出范围或者在当前模式下不对齐或者当前模式不适合对应的设备或者当前地址不可写，则判定为无效地址。范围按照
\texttt{dm.h} 和 \texttt{bridge.h} 中确定的值来确定。若
\texttt{write\_enable\ ==\ 1\textquotesingle{}b1}，则属于写入时地址无效，否则属于读取时地址无效。当前地址既不超出范围又不在当前模式下不对齐时，地址有效。按照地址有效性的各种意义在
\texttt{validity} 端口输出相应的值。

各个小条件的判断逻辑首先假定模式不是 \texttt{DM\_NONE}，之后判断
\texttt{invalid} 的时候会统一判断。

\hypertarget{ux6ce8ux610f}{%
\subsection{注意}\label{ux6ce8ux610f}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{地址范围要和 \texttt{bridge} 同步}
\item
  \textbf{如果当前地址是设备地址，则锁定模式为按字读写}
\item
  \textbf{地址要作为无符号数比较}
\item
  \textbf{如果当前模式是 \texttt{DM\_NONE}，就不存在超出范围的问题了}
\item
  \textbf{不检查 \texttt{write\_enable} 的原因是 \texttt{ac}
  是组合逻辑，如果检查出错，\texttt{write\_enable} 会被禁用，因此只能给
  \texttt{control} 查}
\item
  \textbf{对设备读写不对齐是不能被原谅的，往 \texttt{timer{[}01{]}} 的
  \texttt{count} 的地址范围写不行，读写模式不是字也不行}
\item
  \textbf{忽略判断模式是 \texttt{DM\_NONE}
  是为了避免各个小判断的逻辑复杂化，从而出错}
\end{enumerate}

\hypertarget{cp0}{%
\section{CP0}\label{cp0}}

\hypertarget{ux539fux7406-10}{%
\subsection{原理}\label{ux539fux7406-10}}

CP0 是 0
号协处理器的意思，它负责异常和中断的处理，也负责保存和恢复出现异常时的
PC。

为了能够更方便地处理异常及其相关转发，CP0 部署在 M 级。

\hypertarget{ux7aefux53e3ux5b9aux4e49-8}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-8}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & 输入 & 1 & 时钟信号\tabularnewline\hline
\texttt{rst} & 输入 & 1 & 同步复位信号\tabularnewline\hline
\texttt{addr} & 输入 & 5 & 内部寄存器的读写地址\tabularnewline\hline
\texttt{write\_enable} & 输入 & 1 &
内部寄存器的写使能信号\tabularnewline\hline
\texttt{write\_data} & 输入 & 32 & 内部寄存器的写入数据\tabularnewline\hline
\texttt{exit\_isr} & 输入 & 1 & \texttt{eret} 指令清除 \texttt{exl}
的控制信号\tabularnewline\hline
\texttt{in\_bds} & 输入 & 1 & 当前指令是否在延迟槽中\tabularnewline\hline
\texttt{hwirq} & 输入 & 6 & 外部设备中断信号\tabularnewline\hline
\texttt{exc} & 输入 & 5 & 内部异常信号\tabularnewline\hline
\texttt{curr\_pc} & 输入 & 32 & 受害指令当前 PC 值\tabularnewline\hline
\texttt{read\_result} & 输出 & 32 & 内部寄存器的读取结果\tabularnewline\hline
\texttt{epc} & 输出 & 32 & 保存的要跳转回的 \texttt{pc}
值\tabularnewline\hline
\texttt{have2handle} & 输出 & 1 & 必须处理中断或异常\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-11}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-11}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
异常类型 & \texttt{EXC\_NONE} & \texttt{5\textquotesingle{}d0} &
没有异常\tabularnewline\hline
异常类型 & \texttt{EXC\_ADEL} & \texttt{5\textquotesingle{}d4} & AdEL
异常（读取时地址错误）\tabularnewline\hline
异常类型 & \texttt{EXC\_ADES} & \texttt{5\textquotesingle{}d5} & AdES
异常（写入时地址错误）\tabularnewline\hline
异常类型 & \texttt{EXC\_RI} & \texttt{5\textquotesingle{}d10} & RI
异常（未知指令）\tabularnewline\hline
异常类型 & \texttt{EXC\_OV} & \texttt{5\textquotesingle{}d12} & Ov
异常（运算溢出）\tabularnewline\hline
\texttt{prid} & \texttt{CP0\_PRID} &
\texttt{32\textquotesingle{}h0000002a} & \texttt{cp0} 的处理器
ID\tabularnewline\hline
工作模式 & \texttt{MARS\_COMPAT} & & \texttt{cp0} 是否工作在跟 MARS
兼容的模式下\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-12}{%
\subsection{功能}\label{ux529fux80fd-12}}

该部件为时序部件，没有特殊规定的话，所有寄存器初值均为全 0。但在 MARS
兼容模式下，\texttt{sr} 初值为
\texttt{32\textquotesingle{}h0000ff11}，意味着打开所有 8 个中断（包括 6
个硬件中断和 2 个软件中断），禁用所有 64
位内核地址空间、监管程序地址空间和用户地址空间的访问，基础模式为用户模式，未实现监管程序模式，\texttt{exl}
为 0，全局中断使能打开。

CP0 内部有四个寄存器，都是 32 位的。它们的概况如下。其中出现常量 0
的部分，是因为寄存器功能没有实现全或者按定义实现导致的，这些部分在普通模式下不允许写入，但在
MARS 兼容模式下允许写入，不会一直保持为
0，但写入的值目前还没有作用。PrID
寄存器为只读，所以它其实不是用寄存器实现的，是用 \texttt{wire}。

\begin{longtable}[]{@{}|l|l|l|l|l|@{}}
\hline
编号 & 寄存器 & 代码中的名字 & 结构 & 备注\tabularnewline\hline

\endhead\hiderowcolors
\texttt{12} & \texttt{SR} & \texttt{sr} &
\texttt{\{16\textquotesingle{}b0,\ allow\_hwirq,\ 8\textquotesingle{}b0,\ exl,\ g\_allow\_hwirq\}}
&\tabularnewline\hline
\texttt{13} & \texttt{Cause} & \texttt{cause} &
\texttt{\{in\_bds\_i,\ 15\textquotesingle{}b0,\ hwirq\_i,\ 3\textquotesingle{}b0,\ exc\_i,\ 2\textquotesingle{}b0\}}
&\tabularnewline\hline
\texttt{14} & \texttt{EPC} & \texttt{epc} & \texttt{\{epc\_i\}} &
实际上也是输出端口\tabularnewline\hline
\texttt{15} & \texttt{PrID} & \texttt{prid} & \texttt{\{prid\}} & 直接用
\texttt{wire} 实现\tabularnewline\hline

\end{longtable}

各小寄存器的意义如下。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
小寄存器 & 位宽 & 初值 & 意义\tabularnewline\hline

\endhead\hiderowcolors
\texttt{allow\_hwirq} & 6 & 6'b0 &
允许相应硬件的中断请求，作为掩码使用\tabularnewline\hline
\texttt{exl} & 1 & 1'b0 & 异常级别，在 ISR 时为 1\tabularnewline\hline
\texttt{g\_allow\_hwirq} & 1 & 1'b0 &
在全局允许相应硬件的中断请求\tabularnewline\hline
\texttt{in\_bds\_i} & 1 & 1'b0 &
在内部保存的受害指令是否在延迟槽中的信息\tabularnewline\hline
\texttt{hwirq\_i} & 6 & 6'b000000 &
在内部保存的硬件中断请求情况\tabularnewline\hline
\texttt{exc\_i} & 5 & 5'd0 & 在内部保存的异常代码\tabularnewline\hline
\texttt{epc\_i} & 32 & 32'h0 & 在内部保存的从 ISR 中返回的
PC\tabularnewline\hline
\texttt{prid} & 32 & 32'h0000002a & 处理器 ID\tabularnewline\hline

\end{longtable}

小寄存器定义在寄存器里面，在实现中是用宏表示的。

无论什么时候，若 \texttt{addr} 为相应寄存器的编号，则在
\texttt{read\_result} 端口输出相应寄存器的值。若编号超出范围，则输出
\texttt{32\textquotesingle{}b0}。定义两个表示内部和外部异常或中断请求的
\texttt{wire}：\texttt{have\_irq}，\texttt{have\_exc}。当且仅当
\texttt{(hwirq\ \&\ allow\_hwirq)\ !=\ 0\ \&\&\ g\_allow\_hwirq\ ==\ 1\textquotesingle{}b1\ \&\&\ exl\ ==\ 1\textquotesingle{}b0}
时，\texttt{have\_irq\ ==\ 1\textquotesingle{}b1}，否则为
\texttt{1\textquotesingle{}b0}。当且仅当
\texttt{exc\ !=\ EXC\_NONE\ \&\&\ exl\ ==\ 1\textquotesingle{}b0}
时，\texttt{have\_exc\ ==\ 1\textquotesingle{}b1}，否则为
1'b0。\texttt{have2handle\ ==\ 1\textquotesingle{}b1} 当且仅当
\texttt{have\_irq\ \textbar{}\textbar{}\ have\_exc}，否则为
\texttt{1\textquotesingle{}b0}。

在每个时钟上升沿，首先检查 \texttt{have2handle}。若
\texttt{have2handle\ ==\ 1\textquotesingle{}b1}，则
\texttt{exl\ \textless{}=\ 1\textquotesingle{}b1;\ in\_bds\_i\ \textless{}=\ in\_bds;\ epc\_i\ \textless{}=\ (in\_bds\ ==\ 1\textquotesingle{}b1)\ ?\ \$unsigned(curr\_pc)\ -\ \$unsigned(4)\ :\ \$unsigned(curr\_pc)}。此时，若
\texttt{have\_irq\ ==\ 1\textquotesingle{}b1}，则
\texttt{exc\_i\ \textless{}=\ 0}，否则若
\texttt{have\_exc\ ==\ 1\textquotesingle{}b1}，则
\texttt{exc\_i\ \textless{}=\ exc}。在 MARS
兼容模式下，还需要把代表软件中断的两位（\texttt{{[}9:8{]}}）清空，无论发生了硬件中断还是软件异常。然后检查
\texttt{write\_enable}。若
\texttt{write\_enable\ ==\ 1\textquotesingle{}b1\ \&\&\ (addr\ ==\ 5\textquotesingle{}d12\ \textbar{}\textbar{}\ addr\ ==\ 5\textquotesingle{}d13\ \textbar{}\textbar{}\ addr\ ==\ 5\textquotesingle{}d14)}，则认为试图写入有效，否则进入下一步骤。直接把对应寄存器写入相应的值，但是注意在正常模式下寄存器定义时出现常量
0 的部分会忽略写入，在 MARS 兼容模式下不会。最后检查其它信号。若
\texttt{exit\_isr\ ==\ 1\textquotesingle{}b1}，则
\texttt{exl\ \textless{}=\ 1\textquotesingle{}b0}。若每一步的第一个条件符合，则不需要检查后面的步骤。

在每个时钟上升沿，若在普通模式下，一个附加的步骤（无论如何都要执行）是若不是写入地址有效或者写入的地址不是
\texttt{5\textquotesingle{}d13} 或者 \texttt{have2handle} 不是
\texttt{1\textquotesingle{}b0}，则
\texttt{hwirq\_i\ \textless{}=\ hwirq}。这是为了让 CPU
跟硬件更好地同步。

\hypertarget{ux6ce8ux610fux4e8bux9879-8}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-8}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{中断优先级高于异常，这在功能中也能看出来}
\item
  \textbf{硬件 IRQ 是每个时钟周期都要响应，在 IRQ 内都要响应，不跟着 CPU
  的节奏来}
\item
  \textbf{把寄存器做成全可以写入的并且用宏指定小寄存器，这样做是为了跟
  MARS 兼容}
\item
  \textbf{把 \texttt{prid} 做成 \texttt{32\textquotesingle{}h0} 是为了跟
  MARS 兼容}
\item
  \textbf{跟 MARS 对拍时记得去掉不写 \texttt{cause}
  且不需要处理中断就更新的部分，因为 MARS
  没有这个机制；但是要加上发生异常或中断时清除软件中断位（即
  \texttt{hwirq}），因为 MARS 有这个机制}
\item
  \textbf{实际上更新 \texttt{hwirq\_i}
  在进入中断的时候更新不行，因为进入中断后还得更新
  \texttt{hwirq\_i}；\texttt{have2handle\ ==\ 1\textquotesingle{}b0}
  可以不用判断，因为如果
  \texttt{have2handle\ ==\ 1\textquotesingle{}b1}，\texttt{write\_enable}
  早就被屏蔽了}
\end{enumerate}

\hypertarget{ux6d41ux6c34ux7ebfux5bc4ux5b58ux5668}{%
\section{流水线寄存器}\label{ux6d41ux6c34ux7ebfux5bc4ux5b58ux5668}}

\hypertarget{ux539fux7406-11}{%
\subsection{原理}\label{ux539fux7406-11}}

流水线中需要很多寄存器来保存中间状态，而直接使用 \texttt{always}
块写，有不容易管理的缺点。所以更好的方法是设置流水线寄存器。

\hypertarget{ux7aefux53e3ux5b9aux4e49-9}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-9}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & 输入 & 1 & 时钟信号\tabularnewline\hline
\texttt{rst} & 输入 & 1 & 同步复位信号\tabularnewline\hline
\texttt{enable} & 输入 & 1 & 使能\tabularnewline\hline
\texttt{i} & 输入 & \texttt{BIT\_WIDTH} & 输入的数据\tabularnewline\hline
\texttt{o} & 输出 & \texttt{BIT\_WIDTH} & 输出的数据\tabularnewline\hline

\end{longtable}

\hypertarget{ux53c2ux6570ux5b9aux4e49}{%
\subsection{参数定义}\label{ux53c2ux6570ux5b9aux4e49}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
类别 & 定义 & 默认值 & 意义\tabularnewline\hline

\endhead\hiderowcolors
寄存器位宽 & \texttt{BIT\_WIDTH} & 32 & 寄存器的位宽\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-12}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-12}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{enable} & \texttt{PFF\_ENABLED} & \texttt{1\textquotesingle{}b1}
& 使能\tabularnewline\hline
\texttt{enable} & \texttt{PFF\_DISABLED} &
\texttt{1\textquotesingle{}b0} & 使能\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-13}{%
\subsection{功能}\label{ux529fux80fd-13}}

该部件为时序部件。

该部件内部的寄存器初值为全 0。

每个时钟上升沿，如果
\texttt{rst\ ==\ 1\textquotesingle{}b1}，就令寄存器的值为全
\texttt{0}。否则，如果
\texttt{enable\ ==\ PFF\_ENABLED}，则令寄存器的值为 \texttt{i}
的值。否则寄存器的值不变。

输出端口 \texttt{o} 的值总是寄存器的值。

\hypertarget{ux6ce8ux610fux4e8bux9879-9}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-9}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  复位设成了同步复位，这是为了更好地插入气泡。
\end{enumerate}

\hypertarget{mux}{%
\section{MUX}\label{mux}}

\hypertarget{ux529fux80fd-14}{%
\subsection{功能}\label{ux529fux80fd-14}}

MUX
是多路选择器的意思，是从多个数据源中选择数据的部件。其实它也是数据通路和控制之间的接口，控制部件通过
MUX 来控制数据的流向，实现指令的功能。

\hypertarget{ux7c7bux522b}{%
\subsection{类别}\label{ux7c7bux522b}}

MUX 有多个类别。有 2 路 MUX、3 路 MUX 以至于多路 MUX。实际上，在单周期
CPU 中只能用到路数比较少的 MUX，多路的 MUX 要等到流水线 CPU
的时候才能用。

\hypertarget{ux547dux540d}{%
\subsection{命名}\label{ux547dux540d}}

由于 MUX 有多个类别，所以它也有多个
\texttt{module}，也有多个命名。\emph{n} 路 MUX 命名为
\texttt{mux}\emph{n}。

\hypertarget{ux5b8fux5b9aux4e49-13}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-13}}

暂无

但是仍然保留 \texttt{mux.h} 宏文件并填入模版，以备以后使用。

\hypertarget{ux53c2ux6570ux5b9aux4e49-1}{%
\subsection{参数定义}\label{ux53c2ux6570ux5b9aux4e49-1}}

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
参数 & 默认值 & 功能\tabularnewline\hline

\endhead\hiderowcolors
\texttt{BIT\_WIDTH} & 32 & 输入和输出数据的位宽\tabularnewline\hline

\end{longtable}

\hypertarget{ux7aefux53e3ux5b9aux4e49-10}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-10}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{control} & 输入 & \emph{见注 1} & 输入控制信号\tabularnewline\hline
\texttt{result} & 输出 & \texttt{BIT\_WIDTH} & 输出数据\tabularnewline\hline
\texttt{input}\emph{n} & 输入 & \texttt{BIT\_WIDTH} & \emph{见注
2}\tabularnewline\hline

\end{longtable}

注：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  输入控制信号的位宽如下计算：有 \emph{n} 个输入信号，就取最小的使
  \emph{2\^{}width} 能够超过 \emph{n} 的 \emph{width}，这就是
  \texttt{control} 的位宽。
\item
  功能是输入端口，但是个数有 \emph{n} 个。输入端口\textbf{从 0
  开始计数}。
\end{enumerate}

\hypertarget{ux529fux80fd-15}{%
\subsection{功能}\label{ux529fux80fd-15}}

若 \texttt{control} 的值为
\emph{width}\texttt{\textquotesingle{}d}\emph{n}，则令 \texttt{result}
的值为 \texttt{input}\emph{n} 的值。但是若 \emph{n} 超出了 MUX
的输入端口个数（即路数）或 \emph{n} 为其它值，则令 \texttt{result}
的值为 \texttt{input0} 的值。

\hypertarget{ux6ce8ux610fux4e8bux9879-10}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-10}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{BIT\_WIDTH} 默认为 32，是因为一般传送的数据都是 32 位的。
\item
  接线时端口顺序\textbf{按照数据通路部分最终总结出来的接线表格中指定的顺序来！}
\item
  \textbf{\emph{n} 为其他值可能是 \texttt{x} 或 \texttt{z}！}
\end{enumerate}

\hypertarget{ux6d41ux6c34ux7ebf-cpu-ux6570ux636eux901aux8def}{%
\section{流水线 CPU
数据通路}\label{ux6d41ux6c34ux7ebf-cpu-ux6570ux636eux901aux8def}}

\hypertarget{ux539fux7406-12}{%
\subsection{原理}\label{ux539fux7406-12}}

流水线技术是通过指令级并行，缩短每级的执行时间从而提高频率的技术。这样可以让关键路径缩短，从而提升频率，因此提高了执行效率。

流水线要注意会出现冒险问题，因此会有暂停和转发机制。暂停和转发实际上是控制的内容，数据通路只需要留出需要的部件即可。

\hypertarget{ux5206ux6790}{%
\subsection{分析}\label{ux5206ux6790}}

p7 需要实现的指令为：

\begin{verbatim}
addu, subu, add, sub, sll, srl, sra, and, or, nor, xor, slt, sltu, sllv, srlv, srav
lui, ori, addi, addiu, andi, xori, slti, sltiu
lw, lh, lhu, lb, lbu
sw, sh, sb
beq, bne, blez, bgez, bltz, bgtz
j, jal
jr, jalr
movz
mult, multu, div, divu
mfhi, mflo
mthi, mtlo
mfc0
mtc0
eret
\end{verbatim}

\texttt{nop} 作为 \texttt{sll} 指令的一种特殊情况存在。

由于不同指令的数据通路可以归类，因此首先需要对数据通路进行分类，之后再对每类数据通路总结连接。数据通路分类表如下。

\begin{longtable}[]{@{}|l|l|@{}}
\hline
数据通路类型 & 指令\tabularnewline\hline

\endhead\hiderowcolors
\texttt{UNKNOWN} & （未知指令）\tabularnewline\hline
\texttt{CAL\_R} &
\texttt{addu,\ subu,\ add,\ sub,\ sll,\ srl,\ sra,\ and,\ or,\ nor,\ xor,\ slt,\ sltu,\ sllv,\ srlv,\ srav}\tabularnewline\hline
\texttt{CAL\_I} &
\texttt{lui,\ ori,\ addi,\ addiu,\ andi,\ xori,\ slti,\ sltiu}\tabularnewline\hline
\texttt{LOAD} & \texttt{lw,\ lh,\ lhu,\ lb,\ lbu}\tabularnewline\hline
\texttt{STORE} & \texttt{sw,\ sh,\ sb}\tabularnewline\hline
\texttt{BRANCH} &
\texttt{beq,\ bne,\ blez,\ bgez,\ bltz,\ bgtz}\tabularnewline\hline
\texttt{JUMP\_I} & \texttt{j,\ jal}\tabularnewline\hline
\texttt{JUMP\_R} & \texttt{jr,\ jalr}\tabularnewline\hline
\texttt{CMOV} & \texttt{movz}\tabularnewline\hline
\texttt{CAL\_M} & \texttt{mult,\ multu,\ div,\ divu}\tabularnewline\hline
\texttt{LOAD\_M} & \texttt{mfhi,\ mflo}\tabularnewline\hline
\texttt{STORE\_M} & \texttt{mthi,\ mtlo}\tabularnewline\hline
\texttt{LOAD\_C0} & \texttt{mfc0}\tabularnewline\hline
\texttt{STORE\_C0} & \texttt{mtc0}\tabularnewline\hline
\texttt{JUMP\_C0} & \texttt{eret}\tabularnewline\hline

\end{longtable}

通过分析它们的
RTL，可以得到每条指令对应的数据通路连接如下。其中表格某一列的值表示这个输入端口是哪个输出端口的输出。端口用
\texttt{流水线级:\ 部件.端口名字}
格式表示。空白的单元格表示不用关心相对应的端口的值，因为它们会被忽略，不影响指令的正常执行。未知指令只需要屏蔽各个写入的使能，这样就可以避免未知指令的影响，因此不用分析未知指令。

有时部件名称可能和级不对应。这表示相应端口的值是经过流水后的结果。

由于指令分析函数可以分析到指令读写的寄存器，因此把 D 级和 E
级的三个寄存器地址端口交给控制模块控制。这样也能避免在不该写寄存器的指令写寄存器，因为哪怕寄存器写入使能打开，要写入的寄存器也是
\texttt{ZERO}。

注意：\textbf{使用延迟槽来简化暂停和转发的分析。}

\hypertarget{f-ux7ea7if}{%
\paragraph{F 级（IF）}\label{f-ux7ea7if}}

\begin{longtable}[]{@{}lllllllll@{}}
\hline
数据通路类型 & \texttt{F:\ npc.curr\_pc} & \texttt{F:\ npc.cmp\_result}
& \texttt{F:\ npc.cmp\_sig\_result} & \texttt{F:\ npc.num} &
\texttt{F:\ npc.jnum} & \texttt{F:\ npc.reg\_} & \texttt{F:\ npc.epc} &
\texttt{F:\ pc.next\_pc}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{BRANCH} & \texttt{F:\ pc.curr\_pc} & \texttt{D:\ cmp.cmp} &
\texttt{D:\ cmp.sig\_cmp} & \texttt{D:\ im.result{[}15:0{]}} & & & &
\texttt{F:\ npc.next\_pc}\tabularnewline\hline
\texttt{JUMP\_I} & \texttt{F:\ pc.curr\_pc} & & & &
\texttt{D:\ im.result{[}25:0{]}} & & &
\texttt{F:\ npc.next\_pc}\tabularnewline\hline
\texttt{JUMP\_R} & \texttt{F:\ pc.curr\_pc} & & & & &
\texttt{D:\ rf.read\_result1} & &
\texttt{F:\ npc.next\_pc}\tabularnewline\hline
\texttt{JUMP\_C0} & \texttt{F:\ pc.curr\_pc} & & & & & &
\texttt{M:\ cp0.epc} & \texttt{F:\ npc.next\_pc}\tabularnewline\hline
（其它） & \texttt{F:\ pc.curr\_pc} & & & & & & &
\texttt{F:\ npc.next\_pc}\tabularnewline\hline
综合 & \texttt{F:\ pc.curr\_pc} & \texttt{D:\ cmp.cmp} &
\texttt{D:\ cmp.sig\_cmp} & \texttt{D:\ im.result{[}15:0{]}} &
\texttt{D:\ im.result{[}25:0{]}} & \texttt{D:\ rf.read\_result1} &
\texttt{M:\ cp0.epc} & \texttt{F:\ npc.next\_pc}\tabularnewline\hline

\end{longtable}

\hypertarget{d-ux7ea7id}{%
\paragraph{D 级（ID）}\label{d-ux7ea7id}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
数据通路类型 & \texttt{D:\ ext.num} & \texttt{D:\ cmp.reg1} &
\texttt{D:\ cmp.reg2}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{CAL\_R} & & &\tabularnewline\hline
\texttt{CAL\_I} & \texttt{D:\ im.result{[}15:0{]}} & &\tabularnewline\hline
\texttt{LOAD} & \texttt{D:\ im.result{[}15:0{]}} & &\tabularnewline\hline
\texttt{STORE} & & &\tabularnewline\hline
\texttt{BRANCH} & & \texttt{D:\ rf.read\_result1} &
\texttt{D:\ rf.read\_result2}\tabularnewline\hline
\texttt{NOP} & & &\tabularnewline\hline
\texttt{JUMP\_I} & & &\tabularnewline\hline
\texttt{JUMP\_R} & & &\tabularnewline\hline
\texttt{CMOV} & & \texttt{D:\ rf.read\_result2} &\tabularnewline\hline
\texttt{CAL\_M} & & &\tabularnewline\hline
\texttt{LOAD\_M} & & &\tabularnewline\hline
\texttt{STORE\_M} & & &\tabularnewline\hline
\texttt{LOAD\_C0} & & &\tabularnewline\hline
\texttt{STORE\_C0} & & &\tabularnewline\hline
\texttt{JUMP\_C0} & & &\tabularnewline\hline
综合 & \texttt{D:\ im.result{[}15:0{]}} & \texttt{D:\ rf.read\_result1}
& \texttt{D:\ rf.read\_result2}\tabularnewline\hline

\end{longtable}

\hypertarget{e-ux7ea7ex}{%
\paragraph{E 级（EX）}\label{e-ux7ea7ex}}

\begin{longtable}[]{@{}|l|l|l|l|l|l|@{}}
\hline
数据通路类型 & \texttt{E:\ alu.num1} & \texttt{E:\ alu.num2} &
\texttt{E:\ alu.shamt} & \texttt{E:\ md.dh} &
\texttt{E:\ md.dl}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{CAL\_R} & \texttt{D:\ rf.read\_result1} &
\texttt{D:\ rf.read\_result2} & \texttt{D:\ im.result{[}10:6{]}} &
&\tabularnewline\hline
\texttt{CAL\_I} & \texttt{D:\ rf.read\_result1} &
\texttt{D:\ ext.result} & & &\tabularnewline\hline
\texttt{LOAD} & \texttt{D:\ rf.read\_result1} & \texttt{D:\ ext.result}
& & &\tabularnewline\hline
\texttt{STORE} & \texttt{D:\ rf.read\_result1} & \texttt{D:\ ext.result}
& & &\tabularnewline\hline
\texttt{BRANCH} & & & & &\tabularnewline\hline
\texttt{NOP} & & & & &\tabularnewline\hline
\texttt{JAL} & & & & &\tabularnewline\hline
\texttt{JR} & & & & &\tabularnewline\hline
\texttt{CMOV} & \texttt{D:\ rf.read\_result1} &
\texttt{D:\ rf.read\_result2} & & &\tabularnewline\hline
\texttt{CAL\_M} & & & & \texttt{D:\ rf.read\_result1} &
\texttt{D:\ rf.read\_result2}\tabularnewline\hline
\texttt{LOAD\_M} & & & & &\tabularnewline\hline
\texttt{STORE\_M} & & & & \texttt{D:\ rf.read\_result1} &
\texttt{D:\ rf.read\_result2}\tabularnewline\hline
\texttt{LOAD\_C0} & & & & &\tabularnewline\hline
\texttt{STORE\_C0} & & & & &\tabularnewline\hline
\texttt{JUMP\_C0} & & & & &\tabularnewline\hline
综合 & \texttt{D:\ rf.read\_result1} &
\texttt{D:\ rf.read\_result2,\ D:\ ext.result} &
\texttt{D:\ im.result{[}10:6{]}} & \texttt{D:\ rf.read\_result1} &
\texttt{D:\ rf.read\_result2}\tabularnewline\hline

\end{longtable}

\hypertarget{m-ux7ea7mem}{%
\paragraph{M 级（MEM）}\label{m-ux7ea7mem}}

\begin{longtable}[]{@{}lllllllll@{}}
\hline
数据通路类型 & \texttt{M:\ dm.read\_addr} & \texttt{M:\ dm.write\_addr}
& \texttt{M:\ dm.write\_data} & \texttt{M:\ cpu\_addr} &
\texttt{M:\ cpu\_write\_data} & \texttt{M:\ ac.addr} &
\texttt{M:\ cp0.addr} & \texttt{M:\ cp0.write\_data}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{CAL\_R} & & & & & & & &\tabularnewline\hline
\texttt{CAL\_I} & & & & & & & &\tabularnewline\hline
\texttt{LOAD} & \texttt{E:\ alu.result} & & & \texttt{E:\ alu.result} &
& \texttt{E:\ alu.result} & &\tabularnewline\hline
\texttt{STORE} & & \texttt{E:\ alu.result} &
\texttt{E:\ rf.read\_result2} & \texttt{E:\ alu.result} &
\texttt{E:\ rf.read\_result2} & \texttt{E:\ alu.result} &
&\tabularnewline\hline
\texttt{BRANCH} & & & & & & & &\tabularnewline\hline
\texttt{NOP} & & & & & & & &\tabularnewline\hline
\texttt{JAL} & & & & & & & &\tabularnewline\hline
\texttt{JR} & & & & & & & &\tabularnewline\hline
\texttt{CMOV} & & & & & & & &\tabularnewline\hline
\texttt{CAL\_M} & & & & & & & &\tabularnewline\hline
\texttt{LOAD\_M} & & & & & & & &\tabularnewline\hline
\texttt{STORE\_M} & & & & & & & &\tabularnewline\hline
\texttt{LOAD\_C0} & & & & & & & \texttt{F:\ im.result{[}15:10{]}} &
\texttt{E:\ rf.read\_result2}\tabularnewline\hline
\texttt{STORE\_C0} & & & & & & & \texttt{F:\ im.result{[}15:10{]}} &
\texttt{E:\ rf.read\_result2}\tabularnewline\hline
\texttt{ERET} & & & & & & & &\tabularnewline\hline
综合 & \texttt{E:\ alu.result} & \texttt{E:\ alu.result} &
\texttt{E:\ rf.read\_result2} & \texttt{E:\ alu.result} &
\texttt{E:\ rf.read\_result2} & \texttt{E:\ alu.result} &
\texttt{F:\ im.result{[}15:11{]}} &
\texttt{E:\ rf.read\_result2}\tabularnewline\hline

\end{longtable}

\hypertarget{w-ux7ea7wb}{%
\paragraph{W 级（WB）}\label{w-ux7ea7wb}}

\begin{longtable}[]{@{}|l|l|@{}}
\hline
数据通路类型 & \texttt{W:\ rf.write\_data}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{CAL\_R} & \texttt{E:\ alu.result}\tabularnewline\hline
\texttt{CAL\_I} & \texttt{E:\ alu.result}\tabularnewline\hline
\texttt{LOAD} & \texttt{M:\ dm.read\_result}\tabularnewline\hline
\texttt{STORE} &\tabularnewline\hline
\texttt{BRANCH} &\tabularnewline\hline
\texttt{NOP} &\tabularnewline\hline
\texttt{JAL} &
\texttt{F:\ \$unsigned(pc.curr\_pc)\ +\ \$unsigned(8)}\tabularnewline\hline
\texttt{JR} &\tabularnewline\hline
\texttt{CMOV} & \texttt{E:\ alu.result}\tabularnewline\hline
\texttt{CAL\_M} &\tabularnewline\hline
\texttt{LOAD\_M} & \texttt{E:\ md.out}\tabularnewline\hline
\texttt{STORE\_M} &\tabularnewline\hline
\texttt{LOAD\_C0} & \texttt{M:\ cp0.read\_result}\tabularnewline\hline
\texttt{STORE\_C0} &\tabularnewline\hline
\texttt{ERET} &\tabularnewline\hline
综合 &
\texttt{E:\ alu.result,\ M:\ dm.read\_result,\ F:\ \$unsigned(pc.curr\_pc)\ +\ \$unsigned(8),\ E:\ md.out,\ M:\ cp0.read\_result}\tabularnewline\hline

\end{longtable}

\hypertarget{ux6d41ux6c34ux7ebfux5bc4ux5b58ux5668-1}{%
\paragraph{流水线寄存器}\label{ux6d41ux6c34ux7ebfux5bc4ux5b58ux5668-1}}

由于流水线需要保存每一级流水线的执行结果，所以需要流水线寄存器。需要保存的执行结果，可以从上面数据通路表格中综合出来。为了方便和上面的表格对应，每一级流水线的流水线寄存器都保存上一级流水线的数据。

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
流水线级 & 信号 & 流水线寄存器名称\tabularnewline\hline

\endhead\hiderowcolors
D & \texttt{pc.curr\_pc} & \texttt{d\_pc}\tabularnewline\hline
D & \texttt{im.result} & \texttt{d\_im}\tabularnewline\hline
E & \texttt{pc.curr\_pc} & \texttt{e\_pc}\tabularnewline\hline
E & \texttt{rf.read\_result1} & \texttt{e\_reg1}\tabularnewline\hline
E & \texttt{rf.read\_result2} & \texttt{e\_reg2}\tabularnewline\hline
E & \texttt{ext.result} & \texttt{e\_ext}\tabularnewline\hline
E & \texttt{im.result} & \texttt{e\_im}\tabularnewline\hline
M & \texttt{pc.curr\_pc} & \texttt{m\_pc}\tabularnewline\hline
M & \texttt{alu.result} & \texttt{m\_alu}\tabularnewline\hline
M & \texttt{rf.read\_result2} & \texttt{m\_reg2}\tabularnewline\hline
W & \texttt{alu.result} & \texttt{w\_alu}\tabularnewline\hline
W & \texttt{dm.read\_result} & \texttt{w\_dm}\tabularnewline\hline
W & \texttt{pc.curr\_pc} & \texttt{w\_pc}\tabularnewline\hline
W & \texttt{md.out} & \texttt{w\_md}\tabularnewline\hline
W & \texttt{cp0.read\_result} & \texttt{w\_cp0}\tabularnewline\hline

\end{longtable}

由于需要的流水线寄存器没有跨级的（比如只有 D 级和 W
级），所以不需要把漏掉的级补充上。

这里没有补充 D 级 \texttt{BRANCH} 类指令需要的 \texttt{cmp.cmp} 到 F
级的连接、 \texttt{JAL} 和 \texttt{JR} 类指令相应数据到 F 级的连接和
\texttt{cp0.epc} 到 F 级的连接，因为为了正确控制 PC
的转换，它们必须是实时的，不需要流水线寄存器。

注意：\textbf{返回 \texttt{PC\ +\ 8} 实际上是通过流水 \texttt{PC} 再加 8
实现的。}

注意：\textbf{D 级流水线寄存器都要接使能信号，E
级流水线寄存器都要接复位信号，因为要插入气泡。}

注意：\textbf{所有级流水线都要接复位信号，因为要做到在异常产生时清空流水线。}

\hypertarget{ux8c03ux8bd5ux76f8ux5173ux529fux80fd}{%
\subsection{调试相关功能}\label{ux8c03ux8bd5ux76f8ux5173ux529fux80fd}}

为了能够正确地打印出写入寄存器和 \texttt{dm} 时需要的 \texttt{pc}
值，需要流水 \texttt{pc.curr\_pc}，一直到 W
级。因此，需要新增流水线寄存器，并把相应的 \texttt{pc} 值流水。

注意：\textbf{写入寄存器是使用 \texttt{w} 级流水到的 \texttt{pc}
值，然后把它看成无符号数，再加 8。}

\hypertarget{ux6570ux636eux901aux8def-mux}{%
\paragraph{数据通路 MUX}\label{ux6570ux636eux901aux8def-mux}}

最后是把所有可能的连接综合起来以后，得到的结果。如果有多个可能的连接，就需要一个
MUX。把 MUX 的输出端口连接在相应的输入端口上，MUX
的输入端口要保证所有可能的输入端口都能连接上。

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
端口 & 所有的信号来源 & MUX 名称\tabularnewline\hline

\endhead\hiderowcolors
\texttt{E:\ alu.num2} & \texttt{D:\ rf.read\_result2,\ D:\ ext.result} &
\texttt{m\_alusrc}\tabularnewline\hline
\texttt{M:\ dm.read\_result} &
\texttt{M:\ dm.read\_result,\ M:\ cpu\_read\_result} &
\texttt{m\_bridge}\tabularnewline\hline
\texttt{W:\ rf.write\_data} &
\texttt{（无）,\ E:\ alu.result,\ M:\ dm.read\_result,\ D:\ npc.next\_pc,\ E:\ md.out,\ M:\ cp0.read\_result}
& \texttt{m\_regdata}\tabularnewline\hline

\end{longtable}

注意：\textbf{都是把信号来源从 0 开始编号，对应 MUX 的
\texttt{input}\emph{n} 接第 \emph{n} 个信号源。}

注意：\textbf{如果写了（无），那么相应端口的数据为全
0，不过这时相应端口实际上也没有作用。}

注意：\textbf{\texttt{m\_bridge}
是根据地址范围判断读取结果是哪个的，信号来源里的
\texttt{M:\ dm.read\_result} 是原来的
\texttt{dm.read\_result}。这是为了方便把 \texttt{bridge}
实现成钩子机制。}

\hypertarget{ux8f6cux53d1}{%
\paragraph{转发}\label{ux8f6cux53d1}}

需要转发是因为可能出现后面的指令需要使用前面的指令的结果，而前面的指令结果来不及写回（数据冒险）的情况。由于同一个时钟周期只有一条指令读写
\texttt{dm}，所以 \texttt{dm} 不需要转发。但是 \texttt{rf}
在同一个时钟周期内一般会有多条指令读写，所以 \texttt{rf} 需要转发。

转发的原则就是比较新的指令需要读的寄存器和比较老的指令需要写的寄存器一样。对这个条件的判断，在指令识别函数中已经有了。注意一条指令最多读
2 个寄存器，所以要判断 2 次。

转发是通过转发 MUX
来更改数据通路上寄存器的值，从而达到提前更新的目的。首先，数据通路上有寄存器值的地方，一共有五处：\texttt{D:\ rf.read\_result1,\ D:\ rf.read\_result2,\ E:\ rf.read\_result1,\ E:\ rf.read\_result2,\ M:\ dm.write\_data}。其中
E
级的两处是通过流水线寄存器暂存的。这五处可以分三类。对每类需要构造的转发
MUX 总结如下。

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
端口 & 所有的信号来源 & MUX 名称\tabularnewline\hline

\endhead\hiderowcolors
\texttt{D:\ rf.read\_result{[}12{]}} &
\texttt{E:\ rf.read\_result1,\ E:\ npc.next\_pc,\ M:\ npc.next\_pc,\ M:\ alu.result,\ W:\ rf.write\_data,\ M:\ md.out,\ M:\ cp0.read\_result}
& \texttt{fm\_d1}\tabularnewline\hline
\texttt{E:\ rf.read\_result{[}12{]}} &
\texttt{M:\ npc.next\_pc,\ M:\ alu.result,\ W:\ rf.write\_data,\ M:\ md.out,\ M:\ cp0.read\_result}
& \texttt{fm\_e1}\tabularnewline\hline
\texttt{M:\ dm.write\_data} & \texttt{W:\ rf.write\_data} &
\texttt{fm\_m}\tabularnewline\hline
\texttt{M:\ cp0.epc} &
\texttt{D:\ rf.read\_result2,\ E:\ rf.read\_result2,\ M:\ rf.read\_result2}
& \texttt{fm\_epc}\tabularnewline\hline

\end{longtable}

注意：\textbf{不能在 M 级设置 MUX 转发 \texttt{dm} 的数据，因为这样 D
级或 E 级会等待 M 级 \texttt{dm}
的数据，关键路径会变得非常长，极大地降低流水线性能。同样地，也不能在 E
级设置 MUX 转发 \texttt{alu} 的数据。}

注意：\textbf{\texttt{M:\ cp0.epc}
是流水线前面的级转发优先的，这是因为最前面的级写入的 \texttt{epc}
才是逻辑上最终的 \texttt{epc}。}

转发 MUX
最终是由控制模块控制的。但是控制模块也没法克服有些数据通路不能转发的现实（比如
\texttt{M:\ dm.read\_result}）。这就需要------

\hypertarget{ux6682ux505c}{%
\paragraph{暂停}\label{ux6682ux505c}}

需要暂停是因为有些数据冒险靠转发解决不了，必须要让后面的指令暂停一个时钟周期。暂停的方式是在流水线中插入一个
NOP（这时候也叫气泡），从而让发生数据冒险的指令能够转发。

流水线 CPU 数据通路中能提供的暂停机制有锁定 \texttt{pc} 和清空 E
级各个流水线寄存器。这样就可以在流水线 E 级插入气泡。清空 E
级各个寄存器是通过流水线寄存器的同步复位功能实现的。

\hypertarget{ux5f02ux5e38ux5904ux7406}{%
\paragraph{异常处理}\label{ux5f02ux5e38ux5904ux7406}}

异常处理首先是在流水线寄存器中建立清除机制，让异常或者中断发生的时候能够清空整个流水线。然后，就是传输好
\texttt{epc}，建立好 \texttt{epc} 的转发机制，这样就能正确地从 ISR
中返回。从 ISR 中返回时需要考虑暂停和填充 \texttt{JUMP\_C0}
类指令气泡的关系，还有因为 \texttt{JUMP\_C0}
类指令新带来的数据转发。还有就是做好回退和禁止写入的机制，这样中断发生的那个时钟周期的下一个时钟上升沿就能正确地抵消所有效果。

清除机制和回退、禁止写入的机制是各个数据通路部件内部实现的，\texttt{epc}
的转发机制在数据通路内部已经有转发 MUX 了。具体的控制由控制模块实现。

\hypertarget{ux6307ux4ee4ux8bc6ux522bux673aux5236}{%
\section{指令识别机制}\label{ux6307ux4ee4ux8bc6ux522bux673aux5236}}

\hypertarget{ux539fux7406-13}{%
\subsection{原理}\label{ux539fux7406-13}}

指令识别机制是为了判断指令的功能而设计的。它可以实现判断指令的具体类型、数据通路类型、需要的控制信号等功能。用这些函数识别出来的数据，就可以判断指令的数据流、转发和暂停相关信息和异常相关信息等。

\hypertarget{ux5b8fux5b9aux4e49-14}{%
\paragraph{宏定义}\label{ux5b8fux5b9aux4e49-14}}

由于有特殊的指令读写固定的寄存器，所以寄存器号也要宏定义。

由于函数的声明需要一定的范式保证健壮性，所以函数的声明本身也要定义。

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
寄存器号 & \texttt{ZERO} & \texttt{5\textquotesingle{}d0} & 0
号寄存器（或者表示某指令在某函数下对应的寄存器不存在）\tabularnewline\hline
寄存器号 & \texttt{NULL} & \texttt{ZERO} &\tabularnewline\hline
寄存器号 & \texttt{RA} & \texttt{5\textquotesingle{}d31} & 31
号寄存器（\texttt{\$ra}，\texttt{jal} 指令要写入）\tabularnewline\hline
函数声明 & \texttt{ROBUST\_FUNCTION} & \texttt{function\ automatic} &
\texttt{automatic} 保证函数同时调用时一定使用不同的硬件块\tabularnewline\hline

\end{longtable}

\hypertarget{ux7aefux53e3ux5b9aux4e49-11}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-11}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{instr} & 输入 & 32 & 要分析的指令\tabularnewline\hline
\texttt{kind} & 输出 & 9 & 当前指令的具体类型\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-16}{%
\paragraph{功能}\label{ux529fux80fd-16}}

获取当前指令的具体类型。返回的结果一共 9 位，前 4 位是数据通路类型，后 5
位是具体类型。

若指令的格式符合 MIPS
指令集中的相应格式，则返回对应指令的代码（在宏定义一节中描述）。否则，返回
0。

\hypertarget{ux5b8fux5b9aux4e49-15}{%
\paragraph{宏定义}\label{ux5b8fux5b9aux4e49-15}}

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

编码方式为前 4 位为数据通路类型，后 5 位为其下的具体类型。

指令的意义在表示相应指令的情况下省略不写。但如果有相应备注，也会在这栏注明。

\hypertarget{ux6307ux4ee4ux5b57ux6bb5}{%
\subparagraph{指令字段}\label{ux6307ux4ee4ux5b57ux6bb5}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
指令字段 & \texttt{OP(x)} & \texttt{(x{[}31:26{]})} & 指令的 \texttt{op}
字段\tabularnewline\hline
指令字段 & \texttt{RS(x)} & \texttt{(x{[}25:21{]})} & 指令的 \texttt{rs}
字段\tabularnewline\hline
指令字段 & \texttt{RT(x)} & \texttt{(x{[}20:16{]})} & 指令的 \texttt{rt}
字段\tabularnewline\hline
指令字段 & \texttt{RD(x)} & \texttt{(x{[}15:11{]})} & 指令的 \texttt{rd}
字段\tabularnewline\hline
指令字段 & \texttt{SHAMT(x)} & \texttt{(x{[}10:6{]})} & 指令的
\texttt{shamt} 字段\tabularnewline\hline
指令字段 & \texttt{FUNCT(x)} & \texttt{(x{[}5:0{]})} & 指令的
\texttt{funct} 字段\tabularnewline\hline
指令字段 & \texttt{IMM(x)} & \texttt{(x{[}15:0{]})} & 指令的
\texttt{imm} 字段\tabularnewline\hline
指令字段 & \texttt{IMM\_J(x)} & \texttt{(x{[}25:0{]})} & \texttt{j}
指令的 \texttt{imm} 字段\tabularnewline\hline

\end{longtable}

\hypertarget{ux6307ux4ee4ux7c7bux578b}{%
\subparagraph{指令类型}\label{ux6307ux4ee4ux7c7bux578b}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
指令类型 & \texttt{UNKNOWN} & \texttt{9\textquotesingle{}b0000\_00000} &
未知指令\tabularnewline\hline
指令类型 & \texttt{UNK} & \texttt{UNKNOWN} &\tabularnewline\hline
指令类型 & \texttt{ADDU} & \texttt{9\textquotesingle{}b0001\_00000}
&\tabularnewline\hline
指令类型 & \texttt{SUBU} & \texttt{9\textquotesingle{}b0001\_00001}
&\tabularnewline\hline
指令类型 & \texttt{ADD} & \texttt{9\textquotesingle{}b0001\_00010}
&\tabularnewline\hline
指令类型 & \texttt{SUB} & \texttt{9\textquotesingle{}b0001\_00011}
&\tabularnewline\hline
指令类型 & \texttt{SLL} & \texttt{9\textquotesingle{}b0001\_00100}
&\tabularnewline\hline
指令类型 & \texttt{SRL} & \texttt{9\textquotesingle{}b0001\_00101}
&\tabularnewline\hline
指令类型 & \texttt{SRA} & \texttt{9\textquotesingle{}b0001\_00110}
&\tabularnewline\hline
指令类型 & \texttt{AND} & \texttt{9\textquotesingle{}b0001\_00111}
&\tabularnewline\hline
指令类型 & \texttt{OR} & \texttt{9\textquotesingle{}b0001\_01000}
&\tabularnewline\hline
指令类型 & \texttt{NOR} & \texttt{9\textquotesingle{}b0001\_01001}
&\tabularnewline\hline
指令类型 & \texttt{XOR} & \texttt{9\textquotesingle{}b0001\_01010}
&\tabularnewline\hline
指令类型 & \texttt{SLT} & \texttt{9\textquotesingle{}b0001\_01011}
&\tabularnewline\hline
指令类型 & \texttt{SLTU} & \texttt{9\textquotesingle{}b0001\_01100}
&\tabularnewline\hline
指令类型 & \texttt{SLLV} & \texttt{9\textquotesingle{}b0001\_01101}
&\tabularnewline\hline
指令类型 & \texttt{SRLV} & \texttt{9\textquotesingle{}b0001\_01110}
&\tabularnewline\hline
指令类型 & \texttt{SRAV} & \texttt{9\textquotesingle{}b0001\_01111}
&\tabularnewline\hline
指令类型 & \texttt{LUI} & \texttt{9\textquotesingle{}b0010\_00000}
&\tabularnewline\hline
指令类型 & \texttt{ORI} & \texttt{9\textquotesingle{}b0010\_00001}
&\tabularnewline\hline
指令类型 & \texttt{ADDI} & \texttt{9\textquotesingle{}b0010\_00010}
&\tabularnewline\hline
指令类型 & \texttt{ADDIU} & \texttt{9\textquotesingle{}b0010\_00011}
&\tabularnewline\hline
指令类型 & \texttt{ANDI} & \texttt{9\textquotesingle{}b0010\_00100}
&\tabularnewline\hline
指令类型 & \texttt{XORI} & \texttt{9\textquotesingle{}b0010\_00101}
&\tabularnewline\hline
指令类型 & \texttt{SLTI} & \texttt{9\textquotesingle{}b0010\_00110}
&\tabularnewline\hline
指令类型 & \texttt{SLTIU} & \texttt{9\textquotesingle{}b0010\_00111}
&\tabularnewline\hline
指令类型 & \texttt{LW} & \texttt{9\textquotesingle{}b0011\_00000}
&\tabularnewline\hline
指令类型 & \texttt{LH} & \texttt{9\textquotesingle{}b0011\_00001}
&\tabularnewline\hline
指令类型 & \texttt{LHU} & \texttt{9\textquotesingle{}b0011\_00010}
&\tabularnewline\hline
指令类型 & \texttt{LB} & \texttt{9\textquotesingle{}b0011\_00011}
&\tabularnewline\hline
指令类型 & \texttt{LBU} & \texttt{9\textquotesingle{}b0011\_00100}
&\tabularnewline\hline
指令类型 & \texttt{SW} & \texttt{9\textquotesingle{}b0100\_00000}
&\tabularnewline\hline
指令类型 & \texttt{SH} & \texttt{9\textquotesingle{}b0100\_00001}
&\tabularnewline\hline
指令类型 & \texttt{SB} & \texttt{9\textquotesingle{}b0100\_00010}
&\tabularnewline\hline
指令类型 & \texttt{BEQ} & \texttt{9\textquotesingle{}b0101\_00000}
&\tabularnewline\hline
指令类型 & \texttt{BNE} & \texttt{9\textquotesingle{}b0101\_00001}
&\tabularnewline\hline
指令类型 & \texttt{BLEZ} & \texttt{9\textquotesingle{}b0101\_00010}
&\tabularnewline\hline
指令类型 & \texttt{BGEZ} & \texttt{9\textquotesingle{}b0101\_00011}
&\tabularnewline\hline
指令类型 & \texttt{BLTZ} & \texttt{9\textquotesingle{}b0101\_00100}
&\tabularnewline\hline
指令类型 & \texttt{BGTZ} & \texttt{9\textquotesingle{}b0101\_00101}
&\tabularnewline\hline
指令类型 & \texttt{J} & \texttt{9\textquotesingle{}b0110\_00000}
&\tabularnewline\hline
指令类型 & \texttt{JAL} & \texttt{9\textquotesingle{}b0110\_00001}
&\tabularnewline\hline
指令类型 & \texttt{JR} & \texttt{9\textquotesingle{}b0111\_00000}
&\tabularnewline\hline
指令类型 & \texttt{JALR} & \texttt{9\textquotesingle{}b0111\_00001}
&\tabularnewline\hline
指令类型 & \texttt{MOVZ} & \texttt{9\textquotesingle{}b1000\_00000}
&\tabularnewline\hline
指令类型 & \texttt{MULT} & \texttt{9\textquotesingle{}b1001\_00000}
&\tabularnewline\hline
指令类型 & \texttt{MULTU} & \texttt{9\textquotesingle{}b1001\_00001}
&\tabularnewline\hline
指令类型 & \texttt{DIV} & \texttt{9\textquotesingle{}b1001\_00010}
&\tabularnewline\hline
指令类型 & \texttt{DIVU} & \texttt{9\textquotesingle{}b1001\_00011}
&\tabularnewline\hline
指令类型 & \texttt{MFHI} & \texttt{9\textquotesingle{}b1010\_00000}
&\tabularnewline\hline
指令类型 & \texttt{MFLO} & \texttt{9\textquotesingle{}b1010\_00001}
&\tabularnewline\hline
指令类型 & \texttt{MTHI} & \texttt{9\textquotesingle{}b1011\_00000}
&\tabularnewline\hline
指令类型 & \texttt{MTLO} & \texttt{9\textquotesingle{}b1011\_00001}
&\tabularnewline\hline
指令类型 & \texttt{MFC0} & \texttt{9\textquotesingle{}b1100\_00000}
&\tabularnewline\hline
指令类型 & \texttt{MTC0} & \texttt{9\textquotesingle{}b1101\_00000}
&\tabularnewline\hline
指令类型 & \texttt{ERET} & \texttt{9\textquotesingle{}b1110\_00000}
&\tabularnewline\hline
数据通路类型 & \texttt{UNKNOWN} & \texttt{4\textquotesingle{}b0000} &
未知指令\tabularnewline\hline
数据通路类型 & \texttt{CAL\_R} & \texttt{4\textquotesingle{}b0001} & R
型计算指令\tabularnewline\hline
数据通路类型 & \texttt{CAL\_I} & \texttt{4\textquotesingle{}b0010} & I
型计算指令\tabularnewline\hline
数据通路类型 & \texttt{LOAD} & \texttt{4\textquotesingle{}b0011} &
加载指令\tabularnewline\hline
数据通路类型 & \texttt{STORE} & \texttt{4\textquotesingle{}b0100} &
保存指令\tabularnewline\hline
数据通路类型 & \texttt{BRANCH} & \texttt{4\textquotesingle{}b0101} &
分支指令\tabularnewline\hline
数据通路类型 & \texttt{JUMP\_I} & \texttt{4\textquotesingle{}b0110} &
带立即数的跳转指令\tabularnewline\hline
数据通路类型 & \texttt{JUMP\_R} & \texttt{4\textquotesingle{}b0111} &
读写寄存器的跳转指令\tabularnewline\hline
数据通路类型 & \texttt{CMOV} & \texttt{4\textquotesingle{}b1000} &
条件传送指令\tabularnewline\hline
数据通路类型 & \texttt{CAL\_M} & \texttt{4\textquotesingle{}b1001} &
使用 \texttt{md} 的计算指令\tabularnewline\hline
数据通路类型 & \texttt{LOAD\_M} & \texttt{4\textquotesingle{}b1010} &
读取 \texttt{md} 内部寄存器的指令\tabularnewline\hline
数据通路类型 & \texttt{STORE\_M} & \texttt{4\textquotesingle{}b1011} &
写入 \texttt{md} 内部寄存器的指令\tabularnewline\hline
数据通路类型 & \texttt{LOAD\_C0} & \texttt{4\textquotesingle{}b1100} &
读取 \texttt{cp0} 内部寄存器的指令\tabularnewline\hline
数据通路类型 & \texttt{STORE\_C0} & \texttt{4\textquotesingle{}b1101} &
写入 \texttt{cp0} 内部寄存器的指令\tabularnewline\hline
数据通路类型 & \texttt{JUMP\_C0} & \texttt{4\textquotesingle{}b1110} &
按照 \texttt{cp0} 的内容跳转的指令\tabularnewline\hline

\end{longtable}

\hypertarget{ux6ce8ux610f-1}{%
\subsection{注意}\label{ux6ce8ux610f-1}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  临时的数据通路类型都是从上往下长的。
\item
  \textbf{只剩下一种临时数据通路类型了（TODO）}
\end{enumerate}

\hypertarget{ux63a7ux5236}{%
\section{控制}\label{ux63a7ux5236}}

\hypertarget{ux539fux7406-14}{%
\subsection{原理}\label{ux539fux7406-14}}

控制是指通过识别指令，控制数据的流通，从而让 CPU
执行指定的计算的过程。数据通路只是得到了数据可能的流向，真正要控制还是控制完成。控制通过已有的控制信号和数据通路的分叉完成控制。

在流水线 CPU
中，由于存在结构冒险和数据冒险，所以需要通过暂停和转发解决。暂停控制和转发控制可以放在单独的控制模块中，从而不影响原来单周期时的控制模块。但是，也可以通过改造控制模块的方式集成暂停和转发功能。通过指令识别系列函数（实际上综合时也会被综合成电路），可以分析指令，做到有效的暂停和转发。

\hypertarget{ux7aefux53e3ux5b9aux4e49-12}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-12}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & 输入 & 1 & 时钟信号\tabularnewline\hline
\texttt{d\_instr} & 输入 & 32 & 当前在 D 级（ID）的指令\tabularnewline\hline
\texttt{e\_instr} & 输入 & 32 & 当前在 E 级（EX）的指令\tabularnewline\hline
\texttt{m\_instr} & 输入 & 32 & 当前在 M 级（MEM）的指令\tabularnewline\hline
\texttt{w\_instr} & 输入 & 32 & 当前在 W 级（WB）的指令\tabularnewline\hline

\end{longtable}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{rf\_read\_result2} & 输入 & 32 & \texttt{rf} 的 2
号读取结果\tabularnewline\hline
\texttt{e\_md\_busy} & 输入 & 1 & 输入
\texttt{E:\ md.busy}\tabularnewline\hline
\texttt{m\_dm\_addr} & 输入 & 32 & 输入
\texttt{M:\ dm.read\_addr}（其实也是
\texttt{M:\ dm.write\_addr}）\tabularnewline\hline

\end{longtable}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{f\_pc\_invalid} & 输入 & 1 & 输入
\texttt{F:\ pc.invalid}\tabularnewline\hline
\texttt{e\_alu\_sig\_overflow} & 输入 & 1 & 输入
\texttt{E:\ alu.sig\_overflow}\tabularnewline\hline
\texttt{d\_pc\_curr\_pc} & 输入 & 32 & 输入
\texttt{D:\ pc.curr\_pc}\tabularnewline\hline
\texttt{e\_pc\_curr\_pc} & 输入 & 32 & 输入
\texttt{E:\ pc.curr\_pc}\tabularnewline\hline
\texttt{m\_pc\_curr\_pc} & 输入 & 32 & 输入
\texttt{M:\ pc.curr\_pc}\tabularnewline\hline
\texttt{have2handle} & 输入 & 1 & \texttt{cp0} 是否必须进入
ISR\tabularnewline\hline

\end{longtable}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{cw\_f\_pc\_enable} & 输出 & 1 & 控制 \texttt{pc}
使能\tabularnewline\hline
\texttt{cw\_d\_pff\_enable} & 输出 & 1 & 控制 D
级流水线寄存器使能\tabularnewline\hline
\texttt{cw\_d\_pff\_rst} & 输出 & 1 & 控制 D
级流水线寄存器复位\tabularnewline\hline
\texttt{cw\_e\_pff\_rst} & 输出 & 1 & 控制 E
级流水线寄存器复位\tabularnewline\hline
\texttt{cw\_m\_pff\_rst} & 输出 & 1 & 控制 M
级流水线寄存器复位\tabularnewline\hline
\texttt{cw\_w\_pff\_rst} & 输出 & 1 & 控制 W
级流水线寄存器复位\tabularnewline\hline

\end{longtable}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{cw\_f\_npc\_jump\_mode} & 输出 & 4 & 控制 \texttt{npc}
的跳转模式\tabularnewline\hline

\end{longtable}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{cw\_d\_ext\_mode} & 输出 & 3 & 控制
\texttt{D:\ ext.mode}\tabularnewline\hline
\texttt{cw\_d\_rf\_read\_addr1} & 输出 & 5 & 控制
\texttt{D:\ rf.read\_addr1}\tabularnewline\hline
\texttt{cw\_d\_rf\_read\_addr2} & 输出 & 5 & 控制
\texttt{D:\ rf.read\_addr2}\tabularnewline\hline

\end{longtable}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{cw\_e\_m\_alusrc} & 输出 & 1 & 控制
\texttt{E:\ m\_alusrc}\tabularnewline\hline
\texttt{cw\_e\_alu\_op} & 输出 & 5 & 控制
\texttt{E:\ alu.op}\tabularnewline\hline
\texttt{cw\_e\_md\_op} & 输出 & 3 & 控制
\texttt{E:\ md.op}\tabularnewline\hline
\texttt{cw\_e\_m\_hilo} & 输出 & 1 & 控制
\texttt{E:\ m\_hilo}\tabularnewline\hline

\end{longtable}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{cw\_m\_m\_bridge} & 输出 & 1 & 控制
\texttt{M:\ m\_bridge}\tabularnewline\hline
\texttt{cw\_m\_dm\_write\_enable} & 输出 & 1 & 控制
\texttt{M:\ dm.write\_enable}\tabularnewline\hline
\texttt{cw\_m\_dm\_mode} & 输出 & 1 & 控制
\texttt{M:\ dm.mode}\tabularnewline\hline
\texttt{cw\_m\_cp0\_write\_enable} & 输出 & 1 & 控制
\texttt{M:\ cp0.write\_enable}\tabularnewline\hline
\texttt{cw\_m\_cp0\_exit\_isr} & 输出 & 1 & 控制
\texttt{M:\ cp0.exit\_isr}\tabularnewline\hline
\texttt{cw\_m\_cp0\_in\_bds} & 输出 & 1 & 控制
\texttt{M:\ cp0.in\_bds}\tabularnewline\hline
\texttt{cw\_m\_cp0\_exc} & 输出 & 5 & 控制
\texttt{M:\ cp0.exc}\tabularnewline\hline
\texttt{cw\_m\_cp0\_curr\_pc} & 输出 & 32 & 控制
\texttt{M:\ cp0.curr\_pc}\tabularnewline\hline

\end{longtable}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{cw\_w\_rf\_write\_enable} & 输出 & 1 & 控制
\texttt{W:\ rf.write\_enable}\tabularnewline\hline
\texttt{cw\_w\_m\_regdata} & 输出 & 3 & 控制
\texttt{W:\ m\_rf\_write\_data}\tabularnewline\hline
\texttt{cw\_w\_rf\_write\_addr} & 输出 & 5 & 控制
\texttt{W:\ rf.write\_addr}\tabularnewline\hline

\end{longtable}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{cw\_fm\_d{[}12{]}} & 输出 & 4 & 控制
\texttt{fm\_d{[}12{]}}\tabularnewline\hline
\texttt{cw\_fm\_e{[}12{]}} & 输出 & 4 & 控制
\texttt{fm\_e{[}12{]}}\tabularnewline\hline
\texttt{cw\_fm\_m} & 输出 & 3 & 控制 \texttt{fm\_w}\tabularnewline\hline
\texttt{cw\_fm\_epc} & 输出 & 3 & 控制 \texttt{fm\_epc}\tabularnewline\hline

\end{longtable}

\hypertarget{ux603bux4f53ux7ed3ux6784}{%
\subsection{总体结构}\label{ux603bux4f53ux7ed3ux6784}}

控制模块是时序部件。不设置成组合逻辑部件的原因如下。

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  哪怕控制本身不设置成时序部件，也需要流水控制信号或者异常信号，这是流水线
  CPU 结构上的需要。
\item
  控制本身是时序部件，就可以流水更多的信息。最明显的就是指令读写寄存器的信息。比如暴力转发也把指令读写寄存器的信息放在流水线中流水。
\item
  保留单周期处理器的控制机制实际上过渡不是那么平滑，因为还有多周期处理器，它的控制是类似状态机的结构。
\end{enumerate}

但是实际上控制模块在内部并不流水指令，而是把流水指令放到了数据通路中。这是因为数据通路的
E 级和 M 级都需要指令，而且在处理暂停和进入 ISR
时，统一的指令存储和流水线寄存器清除逻辑实际上更方便。

控制模块在内部流水异常信号和指令需要的寄存器，把流水指令的任务交给数据通路，从而做到比较有效的控制信号发射、数据冒险分析和异常收集与分析。负责控制信号发射的部分是纯组合逻辑，用函数实现。

同时，控制模块也在内部计算出指令需要读取和写入的三个寄存器。因为流水线
CPU 和单周期 CPU
逻辑上应该一样，所以一条指令需要读取和写入的三个寄存器可以直接判断出来。这样也可以更方便地处理数据冒险。

\hypertarget{ux6570ux636eux901aux8defux548cux529fux80fdux63a7ux5236ux4fe1ux53f7}{%
\subsection{数据通路和功能控制信号}\label{ux6570ux636eux901aux8defux548cux529fux80fdux63a7ux5236ux4fe1ux53f7}}

由于指令的数据通路可以分成几个类型，每种类型中需要的数据通路是一样的，只是某些控制信号不同。而且，流水线是分级的，所以每级控制数据通路形状的信号可以单独列表。

但是，不同的具体指令对不同部件的某些具体操作不同。比如 \texttt{CAL\_R}
类指令对 ALU
的具体操作就不同。因此，对这些控制具体操作的信号，需要单独列表。

通过对数据通路形状的分析，可以得到每种数据通路类型需要的控制信号如下。其中表格某一单元格的值有两种情况：若该单元格所在的行最左边的单元格是
MUX，则说明对应的指令需要让该 MUX
的输入端口接入该单元格表示的端口；若该单元格所在的行最左边的单元格是端口，则说明对应的指令需要的控制信号为该单元格表示的控制信号。

若单元格以 \texttt{\#}
开头，则说明该控制信号或端口只是为了使控制单元功能明晰而加上的，实际上并不需要关心该控制信号或要接入的端口的值。如果想理解该单元格的值，去掉
\texttt{\#} 再按照上一段理解即可。

由于加入了中断和异常处理，而且有些中断和异常处理是需要覆盖当前指令的正常控制信号的，所以跟中断和异常处理有关的控制信号省略不写。

\hypertarget{f-ux7ea7}{%
\paragraph{F 级}\label{f-ux7ea7}}

\begin{longtable}[]{@{}|l|l|@{}}
\hline
数据通路类型 & \texttt{F:\ npc.jump\_mode}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{BRANCH} & 视具体指令而定\tabularnewline\hline
\texttt{JUMP\_I} & \texttt{NPC\_J}\tabularnewline\hline
\texttt{JUMP\_R} & \texttt{NPC\_REG}\tabularnewline\hline
\texttt{JUMP\_C0} & \texttt{NPC\_EPC}\tabularnewline\hline
（其它） & \texttt{NPC\_JUMP\_DISABLED}\tabularnewline\hline

\end{longtable}

\texttt{BRANCH} 类指令类型与 \texttt{F:\ npc.jump\_mode} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
指令类型 & \texttt{F:\ npc.jump\_mode}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{BEQ} & \texttt{NPC\_EQUAL}\tabularnewline\hline
\texttt{BNE} & \texttt{NPC\_NOT\_EQUAL}\tabularnewline\hline
\texttt{BLEZ} & \texttt{NPC\_SIG\_SMALLER\_OR\_EQUAL}\tabularnewline\hline
\texttt{BGEZ} & \texttt{NPC\_SIG\_LARGER\_OR\_EQUAL}\tabularnewline\hline
\texttt{BLTZ} & \texttt{NPC\_SIG\_SMALLER}\tabularnewline\hline
\texttt{BGTZ} & \texttt{NPC\_SIG\_LARGER}\tabularnewline\hline

\end{longtable}

注意：\textbf{F 级的控制信号是由 D 级指令控制的。}

注意：\textbf{BRANCH 类指令要跟 0 比较的那些指令，是通过读 \texttt{\$0}
比较的，所以能直接进行大小比较。}

\hypertarget{d-ux7ea7id-1}{%
\paragraph{D 级（ID）}\label{d-ux7ea7id-1}}

\begin{longtable}[]{@{}|l|l|@{}}
\hline
数据通路类型 & \texttt{D:\ ext.mode}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{CAL\_I} & 视具体指令而定\tabularnewline\hline
\texttt{LOAD} & \texttt{EXT\_MODE\_SIGNED}\tabularnewline\hline
\texttt{STORE} & \texttt{EXT\_MODE\_SIGNED}\tabularnewline\hline
（其它） & \texttt{\#EXT\_MODE\_SIGNED}\tabularnewline\hline

\end{longtable}

\texttt{CAL\_I} 类指令类型与 \texttt{D:\ ext.mode} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
指令类型 & \texttt{D:\ ext.mode}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{LUI} & \texttt{EXT\_PAD}\tabularnewline\hline
\texttt{ORI} & \texttt{EXT\_UNSIGNED}\tabularnewline\hline
\texttt{ADDI} & \texttt{EXT\_SIGNED}\tabularnewline\hline
\texttt{ADDIU} & \texttt{EXT\_SIGNED}\tabularnewline\hline
\texttt{ANDI} & \texttt{EXT\_UNSIGNED}\tabularnewline\hline
\texttt{XORI} & \texttt{EXT\_UNSIGNED}\tabularnewline\hline
\texttt{SLTI} & \texttt{EXT\_SIGNED}\tabularnewline\hline
\texttt{SLTIU} & \texttt{EXT\_SIGNED}\tabularnewline\hline

\end{longtable}

注意：\textbf{\texttt{SLTIU}
扩展立即数的时候确实是按照有符号扩展的，但比较是按照无符号数比较，可以查指令手册。}

\hypertarget{e-ux7ea7ex-1}{%
\paragraph{E 级（EX）}\label{e-ux7ea7ex-1}}

\begin{longtable}[]{@{}|l|l|l|l|l|@{}}
\hline
数据通路类型 & \texttt{E:\ m\_alusrc} & \texttt{E:\ alu.op} &
\texttt{E:\ md.op} & \texttt{E:\ m\_hilo}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{CAL\_R} & \texttt{D:\ rf.read\_result2} & 视具体指令而定 &
\texttt{MD\_NONE} & \texttt{\#E:\ md.hi}\tabularnewline\hline
\texttt{CAL\_I} & \texttt{D:\ ext.result} & 视具体指令而定 &
\texttt{MD\_NONE} & \texttt{\#E:\ md.hi}\tabularnewline\hline
\texttt{LOAD} & \texttt{D:\ ext.result} & \texttt{ALU\_ADD} &
\texttt{MD\_NONE} & \texttt{\#E:\ md.hi}\tabularnewline\hline
\texttt{STORE} & \texttt{D:\ ext.result} & \texttt{ALU\_ADD} &
\texttt{MD\_NONE} & \texttt{\#E:\ md.hi}\tabularnewline\hline
\texttt{BRANCH} & \texttt{D:\ rf.read\_result2} & \texttt{\#ALU\_OR} &
\texttt{MD\_NONE} & \texttt{\#E:\ md.hi}\tabularnewline\hline
\texttt{CMOV} & \texttt{D:\ rf.read\_result2} & 视具体指令而定 &
\texttt{MD\_NONE} & \texttt{\#E:\ md.hi}\tabularnewline\hline
\texttt{CAL\_M} & \texttt{\#D:\ rf.read\_result2} & \texttt{\#ALU\_OR} &
视具体指令而定 & \texttt{\#E:\ md.hi}\tabularnewline\hline
\texttt{LOAD\_M} & \texttt{\#D:\ rf.read\_result2} & \texttt{\#ALU\_OR}
& 视具体指令而定 & 视具体指令而定\tabularnewline\hline
\texttt{STORE\_M} & \texttt{\#D:\ rf.read\_result2} & \texttt{\#ALU\_OR}
& 视具体指令而定 & \texttt{\#E:\ md.hi}\tabularnewline\hline
（其它） & \texttt{\#D:\ rf.read\_result2} & \texttt{\#ALU\_OR} &
\texttt{MD\_NONE} & \texttt{\#E:\ md.hi}\tabularnewline\hline

\end{longtable}

\texttt{CAL\_R} 类指令类型与 \texttt{E:\ alu.op} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
指令类型 & \texttt{E:\ alu.op}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{ADDU} & \texttt{ALU\_ADD}\tabularnewline\hline
\texttt{SUBU} & \texttt{ALU\_SUB}\tabularnewline\hline
\texttt{ADD} & \texttt{ALU\_ADD}\tabularnewline\hline
\texttt{SUB} & \texttt{ALU\_SUB}\tabularnewline\hline
\texttt{AND} & \texttt{ALU\_AND}\tabularnewline\hline
\texttt{OR} & \texttt{ALU\_OR}\tabularnewline\hline
\texttt{NOR} & \texttt{ALU\_NOR}\tabularnewline\hline
\texttt{XOR} & \texttt{ALU\_XOR}\tabularnewline\hline
\texttt{SLT} & \texttt{ALU\_SLT}\tabularnewline\hline
\texttt{SLTU} & \texttt{ALU\_SLTU}\tabularnewline\hline
\texttt{SLL} & \texttt{ALU\_SLL}\tabularnewline\hline
\texttt{SRL} & \texttt{ALU\_SRL}\tabularnewline\hline
\texttt{SRA} & \texttt{ALU\_SRA}\tabularnewline\hline
\texttt{SLLV} & \texttt{ALU\_SLLV}\tabularnewline\hline
\texttt{SRLV} & \texttt{ALU\_SRLV}\tabularnewline\hline
\texttt{SRAV} & \texttt{ALU\_SRAV}\tabularnewline\hline

\end{longtable}

\texttt{CAL\_I} 类指令类型与 \texttt{E:\ alu.op} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
指令类型 & \texttt{E:\ alu.op}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{LUI} & \texttt{ALU\_OR}\tabularnewline\hline
\texttt{ORI} & \texttt{ALU\_OR}\tabularnewline\hline
\texttt{ADDI} & \texttt{ALU\_ADD}\tabularnewline\hline
\texttt{ADDIU} & \texttt{ALU\_ADD}\tabularnewline\hline
\texttt{ANDI} & \texttt{ALU\_AND}\tabularnewline\hline
\texttt{XORI} & \texttt{ALU\_XOR}\tabularnewline\hline
\texttt{SLTI} & \texttt{ALU\_SLT}\tabularnewline\hline
\texttt{SLTIU} & \texttt{ALU\_SLTU}\tabularnewline\hline

\end{longtable}

\texttt{CMOV} 类指令类型与 \texttt{E:\ alu.op} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
指令类型 & \texttt{E:\ alu.op}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{MOVZ} & \texttt{ALU\_MOVZ}\tabularnewline\hline

\end{longtable}

\texttt{CAL\_M} 类指令类型与 \texttt{E:\ md.op} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
指令类型 & E: md.op\tabularnewline\hline

\endhead\hiderowcolors
\texttt{MULT} & \texttt{MD\_MULT}\tabularnewline\hline
\texttt{MULTU} & \texttt{MD\_MULTU}\tabularnewline\hline
\texttt{DIV} & \texttt{MD\_DIV}\tabularnewline\hline
\texttt{DIVU} & \texttt{MD\_DIVU}\tabularnewline\hline

\end{longtable}

\texttt{LOAD\_M} 类指令类型与 \texttt{E:\ md.op} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
指令类型 & \texttt{E:\ md.op}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{MFHI} & \texttt{MD\_MFHI}\tabularnewline\hline
\texttt{MFLO} & \texttt{MD\_MFLO}\tabularnewline\hline

\end{longtable}

\texttt{STORE\_M} 类指令类型与 \texttt{E:\ md.op} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
指令类型 & \texttt{E:\ md.op}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{MTHI} & \texttt{MD\_MTHI}\tabularnewline\hline
\texttt{MTLO} & \texttt{MD\_MTLO}\tabularnewline\hline

\end{longtable}

\texttt{LOAD\_M} 类指令类型与 \texttt{E:\ m\_hilo} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
指令类型 & \texttt{E:\ m\_hilo}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{MFHI} & \texttt{E:\ md.hi}\tabularnewline\hline
\texttt{MFLO} & \texttt{E:\ md.lo}\tabularnewline\hline

\end{longtable}

\hypertarget{m-ux7ea7mem-1}{%
\paragraph{M 级（MEM）}\label{m-ux7ea7mem-1}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
数据通路类型 & \texttt{M:\ dm.write\_enable} & \texttt{M:\ dm.mode} &
\texttt{M:\ cp0.write\_enable}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{LOAD} & 1'b0 & 视具体指令而定 &
\texttt{1\textquotesingle{}b0}\tabularnewline\hline
\texttt{STORE} & \texttt{1\textquotesingle{}b1} & 视具体指令而定 &
\texttt{1\textquotesingle{}b0}\tabularnewline\hline
\texttt{LOAD\_C0} & \texttt{1\textquotesingle{}b0} & \texttt{DM\_NONE} &
\texttt{1\textquotesingle{}b0}\tabularnewline\hline
\texttt{STORE\_C0} & \texttt{1\textquotesingle{}b0} & \texttt{DM\_NONE}
& \texttt{1\textquotesingle{}b1}\tabularnewline\hline
（其它） & \texttt{1\textquotesingle{}b0} & \texttt{DM\_NONE} &
\texttt{1\textquotesingle{}b0}\tabularnewline\hline

\end{longtable}

注意：\textbf{\texttt{STORE} 类指令类型会把 \texttt{dm} 和
\texttt{bridge} 的写使能都打开，但是它们两个写到无效地址时会无效，而且有
\texttt{ac} 检查地址，所以出错时不会有副作用。}

注意：\textbf{\texttt{M:\ ac.dm\_mode} 和 \texttt{M:\ dm.write\_enable}
和 \texttt{M:\ dm.mode} 相同，实现的时候把它的信号设置成 \texttt{dm}
对应的信号。}

\texttt{LOAD} 类指令类型与 \texttt{M:\ dm.mode} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
指令类型 & \texttt{M:\ dm.mode}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{LW} & \texttt{DM\_W}\tabularnewline\hline
\texttt{LH} & \texttt{DM\_H}\tabularnewline\hline
\texttt{LHU} & \texttt{DM\_HU}\tabularnewline\hline
\texttt{LB} & \texttt{DM\_B}\tabularnewline\hline
\texttt{LBU} & \texttt{DM\_BU}\tabularnewline\hline

\end{longtable}

\texttt{STORE} 类指令类型与 \texttt{M:\ dm.mode} 的关系：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
指令类型 & \texttt{M:\ dm.mode}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{SW} & \texttt{DM\_W}\tabularnewline\hline
\texttt{SH} & \texttt{DM\_H}\tabularnewline\hline
\texttt{SB} & \texttt{DM\_B}\tabularnewline\hline

\end{longtable}

\hypertarget{w-ux7ea7wb-1}{%
\paragraph{W 级（WB）}\label{w-ux7ea7wb-1}}

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
数据通路类型 & \texttt{W:\ rf.write\_enable} &
\texttt{W:\ m\_regdata}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{CAL\_R} & \texttt{1\textquotesingle{}b1} &
\texttt{E:\ alu.result}\tabularnewline\hline
\texttt{CAL\_I} & \texttt{1\textquotesingle{}b1} &
\texttt{E:\ alu.result}\tabularnewline\hline
\texttt{LOAD} & \texttt{1\textquotesingle{}b1} &
\texttt{E:\ dm.read\_result}\tabularnewline\hline
\texttt{JUMP\_I} & \texttt{1\textquotesingle{}b1} &
\texttt{D:\ npc.next\_pc}\tabularnewline\hline
\texttt{JUMP\_R} & \texttt{1\textquotesingle{}b1} &
\texttt{D:\ npc.next\_pc}\tabularnewline\hline
\texttt{CMOV} & \texttt{1\textquotesingle{}b1} &
\texttt{E:\ alu.result}\tabularnewline\hline
\texttt{LOAD\_M} & 1'b1 & \texttt{E:\ md.out}\tabularnewline\hline
\texttt{LOAD\_C0} & \texttt{1\textquotesingle{}b1} &
\texttt{E:\ cp0.read\_result}\tabularnewline\hline
（其它） & \texttt{1\textquotesingle{}b0} &
\texttt{\#E:\ alu.result}\tabularnewline\hline

\end{longtable}

\hypertarget{ux6d41ux6c34ux7684ux5185ux5bb9}{%
\paragraph{流水的内容}\label{ux6d41ux6c34ux7684ux5185ux5bb9}}

流水 E 级、M 级、W 级指令及其要读的两个寄存器和要写的一个寄存器。不流水
D 级指令是为了配合暂停机制，D 级一被暂停，D
级指令只在组合逻辑跟着变化，不需要再在控制模块里改变 D 级指令的值。

为了处理异常和中断，还要把每级指令的异常流水。下一级的异常默认流水这一级保存的异常，但是如果这一级又新增了异常，那么就流水这一级新增的异常。D
级异常流水寄存器默认流水
\texttt{EXC\_NONE}。这样可以保证异常不断流水，而且能够做到先处理老异常再处理新异常。

注意：\textbf{检测到新异常就流水会让一条指令中更新级的异常覆盖这条指令更老级产生的异常，比如
\texttt{lw} 指令加法溢出了同时不对齐。}

\hypertarget{ux6307ux4ee4ux8bfbux5199ux5bc4ux5b58ux5668ux8bc6ux522b}{%
\paragraph{指令读写寄存器识别}\label{ux6307ux4ee4ux8bfbux5199ux5bc4ux5b58ux5668ux8bc6ux522b}}

比较显然的一点是数据通路类型决定指令要读写的寄存器号。所以，可以直接用取指令字段的宏来完成。

数据通路类型和指令读写寄存器的关系如下。如果指令不读写哪个寄存器，就用
\texttt{ZERO} 替换，因为 \texttt{ZERO}
不参与转发。这样，对转发正确性也没有影响。其中使用的获取指令字段的宏隐含着用要分析的指令作为参数。

指令读写寄存器识别并没有识别 \texttt{cp0} 的相应寄存器，因为
\texttt{cp0} 大体上和 \texttt{dm} 类似，需要解决数据冒险的只是
\texttt{STORE\_C0} +\texttt{JUMP\_C0}
着一种情况。这种情况只要在转发逻辑上加入相应逻辑即可解决。

指令读写寄存器识别也要在进入 ISR
时把所有流水指令读写寄存器号的寄存器全部清空。为了使设计更简洁，也是通过借用数据通路流水线的复位信号实现的。如果某一级数据通路流水线寄存器的复位信号为
\texttt{1\textquotesingle{}b1}，那么这一级对应的流水指令读写寄存器号的寄存器也要复位。否则，就直接写入上一级数据通路流水线寄存器的值。

注意：\textbf{W
级也有这一级数据通路流水线寄存器的复位信号（为了防止出现异常的指令进入下一级），所以也要设置上一段说的复位逻辑。}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
数据通路类型 & \texttt{reg1} & \texttt{reg2} &
\texttt{regw}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{CAL\_R} & \texttt{RS} & \texttt{RT} & \texttt{RD}\tabularnewline\hline
\texttt{CAL\_I} & \texttt{RS} & \texttt{ZERO} &
\texttt{RT}\tabularnewline\hline
\texttt{LOAD} & \texttt{RS} & \texttt{ZERO} & \texttt{RT}\tabularnewline\hline
\texttt{STORE} & \texttt{RS} & \texttt{RT} &
\texttt{ZERO}\tabularnewline\hline
\texttt{BRANCH} & \texttt{RS} & 视指令类型而定（{[}4{]}） &
\texttt{ZERO}\tabularnewline\hline
\texttt{JUMP\_I} & \texttt{ZERO} & \texttt{ZERO} &
视指令而定（{[}2{]}）\tabularnewline\hline
\texttt{JUMP\_R} & \texttt{RS} & \texttt{ZERO} &
视指令而定（{[}3{]}）\tabularnewline\hline
\texttt{CMOV} & \texttt{RS} & \texttt{RT} &
视寄存器值而定（{[}1{]}）\tabularnewline\hline
\texttt{CAL\_M} & \texttt{RS} & \texttt{RT} &
\texttt{ZERO}\tabularnewline\hline
\texttt{LOAD\_M} & \texttt{ZERO} & \texttt{ZERO} &
\texttt{RD}\tabularnewline\hline
\texttt{STORE\_M} & \texttt{RS} & \texttt{ZERO} &
\texttt{ZERO}\tabularnewline\hline
\texttt{LOAD\_C0} & \texttt{ZERO} & \texttt{ZERO} &
\texttt{RT}\tabularnewline\hline
\texttt{STORE\_C0} & \texttt{ZERO} & \texttt{RT} &
\texttt{ZERO}\tabularnewline\hline
\texttt{JUMP\_C0} & \texttt{ZERO} & \texttt{ZERO} &
\texttt{ZERO}\tabularnewline\hline
（其它） & \texttt{ZERO} & \texttt{ZERO} & \texttt{ZERO}\tabularnewline\hline

\end{longtable}

注：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  有一点就是 \texttt{CMOV}
  类指令。这类指令的一种实现是无条件把要写入的数据看成是 \texttt{\$rs}
  的值，但是\textbf{改变要写入的寄存器号}。如果
  \texttt{\$rt\ ==\ 32\textquotesingle{}b0}，就写入
  \texttt{\$rd}，否则写入
  \texttt{\$0\ /\ ZERO}。这样，加上把要读写的寄存器号流水的机制，能保证
  \texttt{CMOV} 类指令的数据冒险处理不出错。哪怕在 W 级打开了
  \texttt{rf} 的写使能，写入 \texttt{\$0} 也没有影响。
\item
  \texttt{JUMP} 类指令若为 \texttt{jal}，则 \texttt{regw\ ==\ RA}。若为
  \texttt{j}，则 \texttt{regw\ ==\ ZERO}。
\item
  \texttt{JUMP\_R} 类指令若为 \texttt{jr}，则
  \texttt{regw\ ==\ ZERO}。若为 \texttt{jalr}，则
  \texttt{regw\ ==\ RD}。由于 \texttt{jr} 指令 \texttt{RS} 字段永远为
  0，所以这样分析是正确的。
\item
  \texttt{BRANCH} 类指令若为 \texttt{beq} 或 \texttt{bne}，则
  \texttt{reg2\ ==\ RT}。若为 \texttt{blez,\ bgez,\ bltz,\ bgtz}，则
  \texttt{reg2\ ==\ ZERO}。由于这样会让 \texttt{cmp}
  的比较结果变成对应寄存器与 0
  的比较，符合指令功能描述，所以这样分析是正确的。
\end{enumerate}

\hypertarget{ux8f6cux53d1ux63a7ux5236ux4fe1ux53f7}{%
\subsection{转发控制信号}\label{ux8f6cux53d1ux63a7ux5236ux4fe1ux53f7}}

由于流水线 CPU
中存在数据冒险，所以需要转发。由于有了指令识别函数，所以转发是非常抽象的，只需要判断涉及的寄存器号。而且只有两个级是转发的接收端（数据的需求者），因此可以在某一级的角度，一级一级往后排查。

注意：\textbf{先检查较新级的数据冒险，再检查较老级的，因为 \texttt{rf}
中的内容最终还是较新级的。}

对 D 级，先检查 E 级，再检查 M 级，再检查 W 级。对 E 级的寄存器，先检查
M 级，再检查 W 级。这样就能保证转发的完整性。

对 M 级的 \texttt{epc}，先检查 D 级，再检查 E
级，这样也是为了保证转发的完整性。现在只有一种情况可以转发，就是
\texttt{mtc0} + \texttt{eret}。如果 \texttt{mtc0} 要写入的寄存器号正好是
\texttt{epc} 的寄存器号，就要转发。

转发控制信号最终需要控制的是转发 MUX，因此转发 MUX 也要进行定义。

下表是所有转发的情况和具体的描述。意义中说的数据通路类型，都是源指令的数据通路类型。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
所有转发 MUX & \texttt{orig} & \texttt{0} &
不转发，保持原样\tabularnewline\hline
\texttt{fm\_d{[}12{]}} & \texttt{E2D\_rf} & \texttt{1} & E 级到 D
级，数据通路类型是 \texttt{CMOV}，要写入的数据在 D 级产生好了，到了 E
级才能转发\tabularnewline\hline
\texttt{fm\_d{[}12{]}} & \texttt{E2D\_npc} & \texttt{2} & E 级到 D
级，数据通路类型是 \texttt{JUMP\_I\ /\ JUMP\_R}，要写入的数据在 D
级产生好了，到了 E 级才能转发\tabularnewline\hline
\texttt{fm\_d{[}12{]}} & \texttt{M2D\_npc} & \texttt{3} & M 级到 D
级，之后同上\tabularnewline\hline
\texttt{fm\_d{[}12{]}} & \texttt{M2D\_alu} & \texttt{4} & M 级到 D
级，数据通路类型是 \texttt{CAL\_R\ /\ CAL\_I\ /\ CMOV}，数据在 D 级或 E
级产生好了，但对 \texttt{CAL\_R\ /\ CAL\_I} 来说，到了 M
级才能转发\tabularnewline\hline
\texttt{fm\_d{[}12{]}} & \texttt{W2D\_rf} & \texttt{5} & W 级到 D
级，数据通路类型是所有能够写入寄存器的类型，数据在 W
级都可以转发了\tabularnewline\hline
\texttt{fm\_d{[}12{]}} & \texttt{M2D\_md} & \texttt{6} & M 级到 D
级，数据通路类型是 \texttt{LOAD\_M}，数据在 E 级产生好了\tabularnewline\hline
\texttt{fm\_d{[}12{]}} & \texttt{E2D\_md} & \texttt{7} & E 级到 D
级，数据通路类型是 \texttt{LOAD\_M}，数据在 E 级产生好了\tabularnewline\hline
\texttt{fm\_d{[}12{]}} & \texttt{M2D\_cp0} & \texttt{8} & E 级到 D
级，数据通路类型是 \texttt{LOAD\_C0}，数据在 M 级产生好了\tabularnewline\hline

\end{longtable}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{fm\_e{[}12{]}} & \texttt{M2E\_npc} & \texttt{1} & M 级到 E
级，数据通路类型是 \texttt{JUMP\_I\ /\ JUMP\_R}，要写入的数据在 D
级产生好了，到了 E 级才能转发\tabularnewline\hline
\texttt{fm\_e{[}12{]}} & \texttt{M2E\_alu} & \texttt{2} & M 级到 E
级，数据通路类型是 \texttt{CAL\_R\ /\ CAL\_I\ /\ CMOV}，数据在 D 级或 E
级产生好了，但对 \texttt{CAL\_R\ /\ CAL\_I} 来说，到了 M
级才能转发\tabularnewline\hline
\texttt{fm\_e{[}12{]}} & \texttt{W2E\_rf} & \texttt{3} & W 级到 E
级，数据通路类型是所有能够写入寄存器的类型，数据在 W
级都可以转发了\tabularnewline\hline
\texttt{fm\_e{[}12{]}} & \texttt{M2E\_md} & \texttt{4} & M 级到 E
级，数据通路类型为 \texttt{LOAD\_M}，数据在 E 级产生好了\tabularnewline\hline
\texttt{fm\_e{[}12{]}} & \texttt{M2E\_cp0} & \texttt{5} & M 级到 E
级，数据通路类型是 \texttt{LOAD\_C0}，数据在 M 级产生好了\tabularnewline\hline

\end{longtable}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{fm\_m} & \texttt{W2M\_rf} & \texttt{1} & W 级到 M
级，数据通路类型是所有能够写入寄存器的类型，数据在 W
级都可以转发了（比如 \texttt{sw} 指令转发 \texttt{rf}
内容）\tabularnewline\hline

\end{longtable}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{fm\_epc} & \texttt{EPC\_D2M\_rf} & \texttt{1} & D 级到 M
级，数据通路类型是 \texttt{STORE\_C0}，数据在 D
级产生好了\tabularnewline\hline
\texttt{fm\_epc} & \texttt{EPC\_E2M\_rf} & \texttt{2} & E 级到 M
级，数据通路类型是 \texttt{STORE\_C0}，数据在 D
级产生好了\tabularnewline\hline
\texttt{fm\_epc} & \texttt{EPC\_M2M\_rf} & \texttt{3} & M 级到 M
级，数据通路类型是 \texttt{STORE\_C0}，数据在 M 级产生好了，但是 D 级的
\texttt{JUMP\_C0} 类指令马上就需要新的 \texttt{epc}
值了，来不及等到下一个时钟上升沿\tabularnewline\hline

\end{longtable}

注意：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{\texttt{B2A\_.*} 表示 B 级从 A 级转发。}
\item
  \textbf{宏的值要和对应转发 MUX 的接线顺序相符。}
\item
  \textbf{\texttt{E2D\_rf} 表示把 E
  级的第一个寄存器转发出去，因为用到这条指令的是 \texttt{CMOV}
  类指令，它可以在 D 级完成要写入数据的判断。}
\item
  \emph{\texttt{fm\_m}
  检查的是要读取的第二个寄存器，因为现在用到的所有写入内存或设备的指令，要写入内存的数据都与相应指令第二个寄存器的读取结果对应。类似地，\texttt{fm\_epc}
  检查的也是要读取的第二个寄存器，因为现在用到的所有写入 \texttt{epc}
  的指令，要写入 \texttt{cp0}
  的数据也是都与相应指令第二个寄存器的读取结果对应。以后可能加上检查要读取的第一个寄存器，不过也是要根据指令类型判断了。}*
\end{enumerate}

\hypertarget{ux6682ux505cux63a7ux5236ux4fe1ux53f7}{%
\subsection{暂停控制信号}\label{ux6682ux505cux63a7ux5236ux4fe1ux53f7}}

由于流水线中有些数据冒险通过转发解决不了，所以需要暂停机制。暂停机制的前提是产生数据冒险。暂停机制是通过
Tuse 和 Tnew 机制实现的。

Tuse 是指指令到 D 级以后还剩最晚多少时间就需要新值。Tnew
是指指令还需要多长时间才能开始转发。因此只要 Tuse \textless{}
Tnew，就需要暂停，因为在流水线中如果没有暂停，两条指令的相对位置是不变的，如果不暂停，就不能解决数据冒险。

数据冒险可以只在 D 级检测和在 E 级解决，因为在 E 级插入气泡，就可以保证
Tuse 和 Tnew 最终会回归正常。

插入气泡是通过锁定 \texttt{pc} 和清空 E
级各个流水线寄存器实现的。但是，控制内部的流水线也要插入气泡。同时，判断异常的流水线也要插入气泡。

暂停要分两个寄存器，因为数据冒险也是要分成两个寄存器的情况的。

注意：\textbf{Tnew
的计算是要看能够开始转发的时间，而不是生成好要转发数据的时间，因为不是所有转发路径都是可能的。}

注意：\textbf{控制内部的流水线和判断异常的流水线也要插入气泡。}

在 D 级各种数据通路类型的 Tuse 如下。

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
数据通路类型 & Tuse (read\_addr1) & Tuse (read\_addr2)\tabularnewline\hline

\endhead\hiderowcolors
\texttt{UNKNOWN} & &\tabularnewline\hline
\texttt{CAL\_R} & 1 & 1\tabularnewline\hline
\texttt{CAL\_I} & 1 & 1\tabularnewline\hline
\texttt{LOAD} & 1 &\tabularnewline\hline
\texttt{STORE} & 1 & 2\tabularnewline\hline
\texttt{BRANCH} & 0 & 0\tabularnewline\hline
\texttt{JUMP\_I} & &\tabularnewline\hline
\texttt{JUMP\_R} & 0 &\tabularnewline\hline
\texttt{CMOV} & 0 & 0\tabularnewline\hline
\texttt{CAL\_M} & 1 & 1\tabularnewline\hline
\texttt{LOAD\_M} & &\tabularnewline\hline
\texttt{STORE\_M} & 1 & 1\tabularnewline\hline
\texttt{LOAD\_C0} & &\tabularnewline\hline
\texttt{STORE\_C0} & & 2\tabularnewline\hline
\texttt{JUMP\_C0} & &\tabularnewline\hline

\end{longtable}

在 E 级和 M 级各种数据通路类型的 Tnew 如下。忽略 W 级，因为所有指令到 W
级时都可以马上转发数据。

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
数据通路类型 & Tnew (E) & Tnew (M)\tabularnewline\hline

\endhead\hiderowcolors
\texttt{UNKNOWN} & &\tabularnewline\hline
\texttt{CAL\_R} & 1 & 0\tabularnewline\hline
\texttt{CAL\_I} & 1 & 0\tabularnewline\hline
\texttt{LOAD} & 2 & 1\tabularnewline\hline
\texttt{STORE} & &\tabularnewline\hline
\texttt{BRANCH} & &\tabularnewline\hline
\texttt{JUMP\_I} & 0 & 0\tabularnewline\hline
\texttt{JUMP\_R} & 0 & 0\tabularnewline\hline
\texttt{CMOV} & 0 & 0\tabularnewline\hline
\texttt{NOP} & &\tabularnewline\hline
\texttt{CAL\_M} & &\tabularnewline\hline
\texttt{LOAD\_M} & 0 & 0\tabularnewline\hline
\texttt{STORE\_M} & &\tabularnewline\hline
\texttt{LOAD\_C0} & 1 & 0\tabularnewline\hline
\texttt{STORE\_C0} & &\tabularnewline\hline
\texttt{JUMP\_C0} & &\tabularnewline\hline

\end{longtable}

以上列表中 Tuse 没有列出的，是因为它没有意义，认为 Tuse 足够大。Tnew
同理，认为 Tnew 为 0。

这样，只要算出每个阶段的 Tuse 和
Tnew，并且保证发生数据冒险时对两个寄存器，Tuse \textgreater{}=
Tnew，就能控制暂停和转发。当且仅当 \texttt{t\_use\_reg{[}12{]}} 小于
\texttt{t\_new\_{[}em{]}} 中的任何一个时，需要暂停。

\texttt{e\_md\_busy\ ==\ 1\textquotesingle{}b1} 时，会一直插入气泡，直到
\texttt{e\_md\_busy\ ==\ 1\textquotesingle{}b0}。而且，\texttt{CAL\_M}
类指令虽然进行计算，但不写普通寄存器，所以跟其它指令没有转发解决不了的数据冒险，所以不停地插入气泡这种方式是可以解决数据冒险的。而且，跟
\texttt{dm} 类似，\texttt{md} 的 \texttt{HI} 和 \texttt{LO}
寄存器也没有数据冒险。因此，乘除法相关指令和其它指令之间，可以看成解决了需要暂停的问题，虽然
\texttt{md} 需要多个周期运行。

由于 \texttt{cp0} 和 \texttt{dm}
类似，只有一种需要转发的情况，所以暂停不需要通过 Tuse 和 Tnew
机制来实现。但是，确实有一种情况需要暂停，就是 D 级为
\texttt{JUMP\_C0}、E 级为 \texttt{STORE\_C0} 而且写入的寄存器就是
\texttt{epc}，M 级 Tnew 为 1 的情况。这是因为 \texttt{JUMP\_C0} 只能在 D
级，\texttt{STORE\_C0} 在 M 级或者往后就直接能转发了。如果
\texttt{STORE\_C0} 在 E 级，那么 M 级的 Tnew 为 0
时，就能两级转发了。但是，如果 M 级的 Tnew 大于
0，两级转发就构造不起来，但是 D 级的 \texttt{JUMP\_C0}
这类指令又马上要用，所以只能暂停了。

注意：\textbf{比较 Tuse 和 Tnew 应该用无符号比较，避免数值最高位是 1
时被看成负数。}

注意：\textbf{异常处理需要的 F 级暂停在异常处理一节里。}

\hypertarget{ux5bc4ux5b58ux5668ux5730ux5740ux63a7ux5236ux4fe1ux53f7}{%
\subsection{寄存器地址控制信号}\label{ux5bc4ux5b58ux5668ux5730ux5740ux63a7ux5236ux4fe1ux53f7}}

由于已经有指令识别机制了，所以寄存器的地址控制可以简化。只需要在 D 级和
M 级的三个地址端口输入指令识别机制相应的结果即可。

\hypertarget{ux8bbeux5907ux8bbfux95ee}{%
\subsection{设备访问}\label{ux8bbeux5907ux8bbfux95ee}}

\hypertarget{ux8bbeux5907ux8bfbux5199}{%
\paragraph{设备读写}\label{ux8bbeux5907ux8bfbux5199}}

设备读写是通过 \texttt{bridge} 模块进行的。\texttt{bridge}
模块通过把设备的内部寄存器读写映射成类似 \texttt{dm}
的方式，通过按字索引操作设备的内部寄存器。

但是，读写的地址验证，还是通过专门的 \texttt{ac}
模块进行的，\texttt{bridge}、\texttt{dm}
和外部设备只是忽略不合法的读写操作。

\hypertarget{ux63a7ux5236ux8bfbux5165ux7ed3ux679c}{%
\paragraph{控制读入结果}\label{ux63a7ux5236ux8bfbux5165ux7ed3ux679c}}

由于有了 \texttt{bridge} 和
\texttt{dm}，所以会有两个并行的读入结果。在这种情况下，选择哪个读入结果是根据地址决定的。这样就把
\texttt{bridge} 和 \texttt{dm} 的结果统一成了
\texttt{M:\ dm.read\_result}，使数据冒险的处理更为简便。

由于内存的地址范围是固定的，所以采用只判断内存地址范围的方式来选择
\texttt{M:\ dm.read\_result} 其实是哪个结果。如果 \texttt{m\_dm\_addr}
在内存地址的范围之内，就选择原来的
\texttt{M:\ dm.read\_result}，否则选择
\texttt{cpu\_read\_result}。选择的 MUX 是 \texttt{m\_bridge}，定义原来的
\texttt{M:\ dm.read\_result} 和 \texttt{cpu\_read\_result} 分别为
\texttt{1\textquotesingle{}b0} 和
\texttt{1\textquotesingle{}b1}，按照这种选择逻辑选择相应的信号。

注意：\textbf{地址比较要用无符号数比较。}

\hypertarget{ux5f02ux5e38ux548cux4e2dux65adux5904ux7406}{%
\subsection{异常和中断处理}\label{ux5f02ux5e38ux548cux4e2dux65adux5904ux7406}}

\hypertarget{ux5f02ux5e38ux5904ux7406-1}{%
\paragraph{异常处理}\label{ux5f02ux5e38ux5904ux7406-1}}

通过异常流水线的机制处理异常。但是，下一级的存储异常的寄存器能够用这一级的异常覆盖这一级存储异常的寄存器原来存储的值。而且，在暂停时，相应级的寄存器也要插入气泡，也就是
\texttt{EXC\_NONE}。

由于 \texttt{cp0} 部署在 M 级处理异常，但需要防止受害指令进入 M
级，所以在 D 级、E 级、M 级和 W 级有异常流水寄存器。然后，在 M
级把这一级的异常流水寄存器和这一级产生的异常再进行比较，如果这一级有地址异常（也就是
\texttt{M:\ ac.validity\ !=\ AC\_VALID}），就认为 M
级指令产生了异常，首先处理 M 级指令的异常，把 M 级指令的异常字段设成
\texttt{ac.validity} 的非正常情况对应的值，同时根据 \texttt{dm}
是否写使能的原来的信号判断 \texttt{dm} 的读写模式。然后，把最终得到的 M
级指令的异常输出给 \texttt{cp0}。

注意：\textbf{为了正确判断 \texttt{dm}
写使能原来的信号，需要在控制模块内部判断。不能用输出的 \texttt{dm}
写使能信号，因为这样能被 \texttt{have2handle} 覆盖。}

如果需要进入 ISR，就把 D 级、E 级、M 级和 W
级的流水线寄存器全部复位，并加上相应的钩子机制，使下个时钟上升沿带来的数据写入被取消，而且把
PC 改成 ISR 的。

注意：\textbf{为了防止受害指令进入 M 级，需要把 M 级流水线寄存器复位。}

由于暂停会让 F 级和 D 级的指令停住不动，所以它的优先级最大。由于
\texttt{JUMP\_C0}
类指令不是跳转指令，所以不能实现延迟槽，不暂停的时候需要复位 D
级流水线寄存器，通过这种方式插入气泡。这样，存储异常的寄存器的更改逻辑需要一定的调整。

每级存储异常的寄存器更新逻辑如下：

\begin{longtable}[]{@{}|l|l|@{}}
\hline
流水线级 & 更新逻辑\tabularnewline\hline

\endhead\hiderowcolors
D 级 & 若 \texttt{cw\_d\_pff\_rst\ ==\ 1\textquotesingle{}b1}，则值变为
\texttt{EXC\_NONE}。若需要暂停，则值不变。否则，若 D 级数据通路类型为
\texttt{JUMP\_C0}，则插入气泡。否则，若
\texttt{F:\ pc.invalid\ ==\ 1\textquotesingle{}b1}，则写入
\texttt{EXC\_ADEL}。否则，写入 \texttt{EXC\_NONE}。\tabularnewline\hline
E 级 & 若 \texttt{cw\_e\_pff\_rst\ ==\ 1\textquotesingle{}b1}，则值变为
\texttt{EXC\_NONE}。若需要暂停，则写入 \texttt{EXC\_NONE}。否则，若
\texttt{d\_instr\_kind\ ==\ UNKNOWN}，则写入
\texttt{EXC\_RI}。否则，写入 D 级的值。\tabularnewline\hline
M 级 & 若 \texttt{cw\_m\_pff\_rst\ ==\ 1\textquotesingle{}b1}，则值变为
\texttt{EXC\_NONE}。若 \texttt{ekind} 为 \texttt{ADD\ /\ ADDI\ /\ SUB}
且 \texttt{E:\ alu.sig\_overflow\ ==\ 1\textquotesingle{}b1}，则写入
\texttt{EXC\_OV}。否则，写入 E 级的值。\tabularnewline\hline

\end{longtable}

因为每级存储异常的流水线寄存器的复位逻辑与每级数据通路中的流水线寄存器是一致的，而每级数据通路中流水线寄存器的复位逻辑是正确的，因此可以这样借用控制信号。

TODO: \texttt{EXC\_RI} 好像只是 \texttt{opcode} 未知

\hypertarget{ux4e2dux65adux5904ux7406}{%
\paragraph{中断处理}\label{ux4e2dux65adux5904ux7406}}

中断处理是通过 \texttt{bridge} 进行的。\texttt{bridge}
负责捕获硬件的中断，并把它送到 \texttt{cp0}
的端口。如果当前指令发生了异常，也要优先处理中断，因为中断的优先级更高。

注意：\textbf{中断的优先级比异常高。}

\hypertarget{ux8fdbux5165-isr}{%
\paragraph{进入 ISR}\label{ux8fdbux5165-isr}}

\texttt{cp0} 中有专门的输出端口 \texttt{have2handle} 来做这件事。如果在
ISR 外面执行指令突然碰到异常或中断，\texttt{have2handle}
由组合逻辑驱动，就会变成
\texttt{1\textquotesingle{}b1}。下一个时钟周期的时候，就会处理中断或异常。\texttt{cp0}
会与控制模块写作，保存中断发生时需要的信息。

首先，为了干净地处理中断或异常，需要复位所有的流水线寄存器，然后把新 PC
定位为 ISR 的起始地址。这就需要把原来对 NPC 模式的控制信号
\texttt{cw\_npc\_mode} 加上钩子，如果出现了中断或异常，就直接改成
\texttt{NPC\_ISR}，让 \texttt{pc}
跳转。这就需要四个控制信号：\texttt{{[}demw{]}\_pff\_rst}。其中
\texttt{e\_pff\_rst} 已经有了，所以需要加上钩子。同时，由于
\texttt{JUMP\_C0} 类指令不需要延迟槽，所以 \texttt{d\_pff\_rst} 在 D
级指令为 \texttt{JUMP\_C0} 类指令的时候，也需要为
\texttt{1\textquotesingle{}b1}。

其次，为了彻底地取消流水线的效果，需要在下个时钟上升沿禁止所有可写入部件的写入。这也需要把原来对
\texttt{dm}、\texttt{bridge}、\texttt{cp0} 和 \texttt{md}
的控制信号屏蔽掉，同样也是加入钩子机制，如果出现了中断或异常，哪怕写入使能也要取消使能。但是，\texttt{rf}
不需要这样做，因为把 \texttt{cp0} 部署在 M
级以后，任何出现异常的指令最晚到 M 级都会被处理，而且 W
级指令只有写回寄存器，不会产生异常，在下一个时钟上升沿正好写入寄存器，完成了最终的指令功能。

对 \texttt{md}，如果 E 级或 M 级指令是 \texttt{STORE\_M}
类指令，那么需要把 \texttt{restore} 信号置成
\texttt{1\textquotesingle{}b1}，因为在下一个时钟下降沿，\texttt{md}
已经开始或者早已结束解析控制信号并存储新值了。因为 E 级或 M
级指令会重新执行。如果 E 级或 M 级指令是 \texttt{CAL\_M} 类指令，那么把
\texttt{stop} 信号置成
\texttt{1\textquotesingle{}b1}，因为有正在进行的运算，需要停止。

注意：\textbf{如果有 \texttt{mult\ /\ multu\ /\ div\ /\ divu}
指令执行完了然后 \texttt{md} 在执行，\texttt{md}
执行结束前有指令出现异常，那么 \texttt{md}
的值同样会更新。暂停机制保证了操作 \texttt{md}
的三类数据通路类型都是实际上顺序执行的，所以 \texttt{md}
的值会更新，不过会出现在 ISR 里，让 ISR 用。}

控制信号与其加了钩子后的控制信号的关系如下。

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
控制信号 & 加钩子后的控制信号 & 与原来控制信号和 \texttt{have2handle}
的关系 & 备注\tabularnewline\hline

\endhead\hiderowcolors
\texttt{cw\_m\_dm\_write\_enable\_orig} &
\texttt{cw\_m\_dm\_write\_enable} &
\texttt{cw\_m\_dm\_write\_enable\ \&\ (\textasciitilde{}have2handle)}
&\tabularnewline\hline
\texttt{cw\_m\_cp0\_write\_enable\_orig} &
\texttt{cw\_cp0\_write\_enable} &
\texttt{cw\_cp0\_write\_enable\_orig\ \&\ (\textasciitilde{}have2handle)}
& {[}1{]}\tabularnewline\hline
\texttt{cw\_e\_pff\_rst\_orig} & \texttt{cw\_e\_pff\_rst} &
\texttt{cw\_e\_pff\_rst\_orig} 或 \texttt{have2handle} &\tabularnewline\hline
\texttt{cw\_f\_npc\_jump\_mode\_orig} & \texttt{cw\_f\_npc\_jump\_mode}
&
\texttt{(have2handle\ ==\ 1\textquotesingle{}b1)\ ?\ NPC\_ISR\ :\ cw\_f\_npc\_jump\_mode\_orig}
& {[}2{]}\tabularnewline\hline
\texttt{cw\_f\_pc\_enable\_orig} & \texttt{cw\_f\_pc\_enable} &
\texttt{cw\_f\_pc\_enable\_orig} 或 \texttt{have2handle} &
{[}3{]}\tabularnewline\hline

\end{longtable}

注：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  实际上不需要加钩子，因为 \texttt{cp0}
  内部就是写入的优先级比处理异常和中断的优先级低。
\item
  如果 \texttt{have2handle\ ==\ 1\textquotesingle{}b1}，那么
  \texttt{cw\_f\_npc\_jump\_mode} 必须为
  \texttt{NPC\_ISR}，因为需要强制跳转到 ISR 的起始地址。
\item
  为了避免暂停时 \texttt{pc} 不动的问题，暂停时 \texttt{pc} 必须强行跳到
  ISR 的起始地址
\end{enumerate}

然后，为了能让 \texttt{cp0}
获得准确的数据，必须把控制模块分析出来的相应的 \texttt{cp0} 控制信号接入
\texttt{cp0} 相应的输入漩口。接入关系及意义如下。

\begin{longtable}[]{@{}|l|l|l|l|l|@{}}
\hline
控制模块输出端口 & \texttt{cp0} 输入端口 & 生成方法 & 意义 &
备注\tabularnewline\hline

\endhead\hiderowcolors
\texttt{cw\_m\_cp0\_write\_enable} & \texttt{write\_enable} & M 级指令为
\texttt{STORE\_C0} 类指令 & 能够让 \texttt{STORE\_C0} 类指令写入
\texttt{cp0} 内部寄存器 & {[}5{]}\tabularnewline\hline
\texttt{cw\_m\_cp0\_exit\_isr} & \texttt{exit\_isr} & M 级指令为
\texttt{JUMP\_C0} 类指令 & 能够让 \texttt{JUMP\_C0}
类指令正常去掉中断状态 & {[}1{]}\tabularnewline\hline
\texttt{cw\_m\_cp0\_in\_bds} & \texttt{in\_bds} & W 级指令为
\texttt{BRANCH\ /\ JUMP\_I\ /\ JUMP\_R} 类指令 & 能够让 \texttt{cp0}
判断出受害指令是否在延迟槽内 & {[}2{]}\tabularnewline\hline
\texttt{cw\_m\_cp0\_exc} & \texttt{exc} & M 级存储异常的流水线寄存器和 M
级的异常情况综合后的结果 & 能够让 \texttt{cp0} 得到当前发生的异常 &
{[}3{]}\tabularnewline\hline
\texttt{cw\_m\_cp0\_curr\_pc} & \texttt{curr\_pc} & 若
\texttt{M:\ curr\_pc\ !=\ 0}，则为 \texttt{M:\ curr\_pc}；否则一直追溯到
D 级的 \texttt{curr\_pc} 为止 & 能够让 \texttt{cp0} 得到受害指令的 PC
作为 \texttt{epc} & {[}4{]}\tabularnewline\hline

\end{longtable}

注：

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  一般来说 \texttt{JUMP\_C0} 类指令应该马上写 \texttt{cp0}
  的相应寄存器，从而去掉 \texttt{exl}，以方便之后的 \texttt{LOAD\_C0}
  类指令。但是，\texttt{JUMP\_C0} 类指令由于不是跳转类指令却在 D
  级译码，后面一定跟着一个气泡。所以，它到了 M
  级的时候，\texttt{LOAD\_C0} 类指令最早才到 D
  级，下一个时钟上升沿后就可以转发，转发来得及，因此不需要再做
  \texttt{cp0} 内部寄存器的转发，直接让 M 级指令为 \texttt{JUMP\_C0}
  类指令时设置
  \texttt{cw\_m\_cp0\_exit\_isr\ \textless{}=\ 1\textquotesingle{}b1}
  即可。
\item
  受害指令是 M 级指令，所以如果 M 级指令在延迟槽中，W
  级指令一定为以上三种类型。W 级指令为 \texttt{JUMP\_C0}
  类指令时，后面一定跟着一个气泡，再说 \texttt{JUMP\_C0}
  类指令没有延迟槽，所以不需要考虑。如果受害指令在延迟槽内，保存的
  \texttt{epc} 是受害指令的 PC 作为无符号数再减去
  4，因为要恢复到跳转指令，把跳转指令再执行一遍。
\item
  异常情况按照处理异常这一节，是一定要综合的。综合以后就能让
  \texttt{cp0} 得到 M
  级指令最近的异常情况，因为异常原则上都是一级一级往下传递，而且新异常会覆盖老异常。
\item
  M 级指令出现异常，那么 M 级一定有指令，所以
  \texttt{M:\ curr\_pc\ !=\ 0}，受害指令的 PC
  就能被找到。但是，如果出现中断而且 M
  级是气泡，\texttt{M:\ curr\_pc\ ==\ 0}，这是就应该回溯找到没有气泡的指令。回溯到
  D 级就可以，因为一般暂停产生的气泡都是只在 E
  级生成，只有一种情况例外，就是 \texttt{JUMP\_C0} 类指令。但是它在 D
  级生成气泡的时候，自己也到了 E
  级，表格中的逻辑照样适合。流水线刚被全部清空，正要进入 ISR
  的那个上升沿不会再出现中断。这是因为中断被屏蔽了，况且 ISR
  起始地址肯定是关于字对齐的，否则就是硬件设计缺陷了，之后各级由于都是气泡，也不会再出现中断。所以，用表格中的逻辑不用担心找不到不合法的
  PC。
\item
  这里的信号是原来的信号，注意要像加钩子表格那样加上钩子。
\end{enumerate}

\hypertarget{cp0-1}{%
\paragraph{CP0}\label{cp0-1}}

\texttt{cp0}
主要是负责获取中断时的情况和保存中断的相关信息。\texttt{cp0}
输入了当前的中断和异常情况、\texttt{epc}、受害指令是否再延迟槽内这些相关信息，等到从
ISR 返回时恢复。同时，\texttt{cp0} 也支持读写它内部的寄存器。

\texttt{cp0} 需要通过组合电路判断这个时钟上升沿后 M
级是否出现了异常，以及是否出现了硬件中断。它的内部寄存器有全局中断使能、硬件中断使能掩码和中断层级等设置。硬件中断首先与硬件中断使能掩码相与，然后再根据全局中断使能和中断层级来判断是否进入
ISR。软件异常直接根据全局中断使能和中断层级来判断是否进入
ISR。如果中断层级为 \texttt{1\textquotesingle{}b1}，就不需要再进入 ISR
了。

\texttt{cp0} 首先是在 \texttt{have2handle\ ==\ 1\textquotesingle{}b1}
的情况下进入 ISR 并设定相应的状态，其次才是处理写请求，最后是处理清除
\texttt{exl}
的请求。这样能保证中断机制符合一般的认知，而且不妨碍指令执行逻辑上的顺序性。

\hypertarget{ux4ece-isr-ux8fd4ux56de}{%
\paragraph{从 ISR 返回}\label{ux4ece-isr-ux8fd4ux56de}}

从 ISR 返回是用 \texttt{JUMP\_C0} 类指令，现在只有一条，就是
\texttt{ERET} 指令。\texttt{ERET} 指令需要读取 \texttt{M:\ cp0.epc} 作为
\texttt{F:\ npc.next\_pc}，而且有 \texttt{STORE\_C0} 类指令，所以
\texttt{epc} 也要转发，这在前面的转发一节中已经提到了。

虽然 \texttt{JUMP\_C0} 类指令也写 \texttt{cp0}
的内部寄存器，但是它们不需要转发，因为它并没有延迟槽，后面会带一个气泡。这样保证了它在
M
级的时候，新指令才会进来，转发来得及，更何况还有暂停机制。实际上，\texttt{ERET}
指令并不算跳转类指令，所以它没有延迟槽。在 \texttt{JUMP\_C0}
类指令后面插入气泡的方法，是 D 级指令为 \texttt{JUMP\_C0}
类指令时，如果不暂停，在下个时钟上升沿就复位 D 级寄存器。这样，D
级就会插入一个气泡，同时不跟暂停机制冲突，因为暂停时 D
级指令是不动的。实际上，这跟流水线寄存器的复位和暂停优先级冲突了，但是暂时没有好的办法。

从 ISR 返回时，在 D 级的跳转模式是 \texttt{NPC\_EPC}，是经过转发的
\texttt{M:\ cp0.epc}。转发也是较新的级优先级较大，因为这样符合逻辑。转发后就不需要清空流水线了，因为正常的指令可以继续执行下去，不像进入
ISR 时需要撤销比 M 级还新的几条指令的执行结果。

注意：\textbf{D 级流水线寄存器的复位逻辑是在前面进入 ISR
时实现的，并不在最后。}

注意：\textbf{D 级流水线只有不暂停的时候才能复位，否则一暂停会把 D 级的
\texttt{JUMP\_C0} 类指令清空。}

注意：\textbf{可以在 M 级时判断出 \texttt{JUMP\_C0} 类指令再清空
\texttt{exl}，因为 \texttt{JUMP\_C0} 类指令清空 \texttt{exl} 后到了 W
级，会正常执行完，这时正好当时的受害指令到了 M
级，如果还有中断或者异常，该指令及其之后指令仍然会被中断，重新进入
ISR。但是，会出现 \texttt{eret} 没到 M 级的时候或者刚清空流水线 ISR
的第一条指令还来不及进入 M
级的时候不持续的硬件中断不会响应的问题，这种问题应该可以忽略，把它当成
ISR 已经进入或者还没退出来解决。}

\hypertarget{cpu}{%
\section{CPU}\label{cpu}}

\hypertarget{ux539fux7406-15}{%
\subsection{原理}\label{ux539fux7406-15}}

CPU
是宏观部件，主要连接起数据通路和控制。该部件主要起的是宏观功能，也就是读取指令并完成计算。但是，为了更好地和外部设备通信，CPU
和 \texttt{bridge}
模块相连接，通过除了时钟信号的其它输入输出端口与外部设备通信。

\hypertarget{ux7aefux53e3ux5b9aux4e49-13}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-13}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & 输入 & 1 & 时钟信号\tabularnewline\hline
\texttt{rst} & 输入 & 1 & 复位信号\tabularnewline\hline
\texttt{cpu\_read\_result} & 输入 & 32 & CPU
从设备得到的读取结果\tabularnewline\hline
\texttt{hwirq} & 输入 & 6 & 设备的中断信号\tabularnewline\hline
\texttt{cpu\_addr} & 输出 & 32 & CPU
要对设备相应寄存器操作的地址\tabularnewline\hline
\texttt{dev\_write\_enable} & 输出 & 1 & CPU
对设备的写使能信号\tabularnewline\hline
\texttt{cpu\_write\_data} & 输出 & 32 & CPU
要对设备写入的数据\tabularnewline\hline

\end{longtable}

\hypertarget{ux63a5ux7ebf}{%
\subsection{接线}\label{ux63a5ux7ebf}}

按照数据通路和控制部分的定义进行接线。数据通路中的接线方式在数据通路部分的文档中描述，控制部分按照控制部分的文档中描述。控制部分控制数据通路的哪部分，在控制部分的文档中。

\hypertarget{ux529fux80fd-17}{%
\subsection{功能}\label{ux529fux80fd-17}}

CPU 需要的外部数据输入是极少的，只有时钟信号、必要的其它信号和指令文件。

\hypertarget{ux6ce8ux610fux4e8bux9879-11}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-11}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  对部件分级是个好习惯，在流水线 CPU 时会有用。
\end{enumerate}

\hypertarget{ux8ba1ux65f6ux5668}{%
\section{计时器}\label{ux8ba1ux65f6ux5668}}

\hypertarget{ux539fux7406-16}{%
\subsection{原理}\label{ux539fux7406-16}}

计时器是产生硬件中断的一种示例部件。它由状态机组成，可以进行定时，并在规定的时间到时产生中断。它内部维护一个计数器和保存控制信号的两个寄存器，从而可以对计数进行控制。CPU
可以通过 \texttt{bridge} 模块更改各寄存器的值。

\hypertarget{ux7aefux53e3ux5b9aux4e49-14}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-14}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & 输入 & 1 & 时钟信号\tabularnewline\hline
\texttt{rst} & 输入 & 1 & 同步复位信号\tabularnewline\hline
\texttt{addr} & 输入 & 32 & 地址信号\tabularnewline\hline
\texttt{write\_enable} & 输入 & 1 & 写使能信号\tabularnewline\hline
\texttt{write\_data} & 输入 & 32 & 要写入内部寄存器的数据\tabularnewline\hline
\texttt{read\_result} & 输出 & 32 &
从内部寄存器读出的数据\tabularnewline\hline
\texttt{irq} & 输出 & 1 & 中断请求输出\tabularnewline\hline

\end{longtable}

\hypertarget{ux5b8fux5b9aux4e49-16}{%
\subsection{宏定义}\label{ux5b8fux5b9aux4e49-16}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{类别} & \headingcellmiddle{定义} & \headingcellmiddle{值} & \headingcelllast{意义}\tabularnewline\hline

\endhead\hiderowcolors
状态 & \texttt{TIMER\_IDLE} & \texttt{3\textquotesingle{}b000} &
空闲状态\tabularnewline\hline
状态 & \texttt{TIMER\_LOAD} & \texttt{3\textquotesingle{}b001} &
装载状态\tabularnewline\hline
状态 & \texttt{TIMER\_CNT} & \texttt{3\textquotesingle{}b010} &
计数状态\tabularnewline\hline
状态 & \texttt{TIMER\_INT} & \texttt{3\textquotesingle{}b011} &
处理中断状态\tabularnewline\hline

\end{longtable}

\hypertarget{ux53c2ux6570ux5b9aux4e49-2}{%
\subsection{参数定义}\label{ux53c2ux6570ux5b9aux4e49-2}}

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
参数 & 默认值 & 功能\tabularnewline\hline

\endhead\hiderowcolors
\texttt{BASE} & \texttt{32\textquotesingle{}h00007f00} & 在
\texttt{bridge} 模块中该模块实例的基址\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-18}{%
\subsection{功能}\label{ux529fux80fd-18}}

该部件为时序部件。

内部维护 3 个 32 位寄存器，名字按地址从小到大分别为
\texttt{ctrl,\ preset,\ count}。\texttt{ctrl} 的结构为
\texttt{\{28\textquotesingle{}b0,\ allow\_irq,\ 1\textquotesingle{}b0,\ mode,\ enable\}}，\texttt{preset}
和 \texttt{count} 分别作为 32
位计数的预设值和当前值。\texttt{allow\_irq}，\texttt{mode} 和
\texttt{enable}
分别表示是否允许中断、计数模式和计数器使能。它们的初值都为全 0。
每个时钟上升沿，首先检查 \texttt{rst} 是否为
\texttt{1\textquotesingle{}b1}，若是，则把所有寄存器都恢复初值。

之后，检查写入是否有效。若 \texttt{write\_enable} 为
\texttt{1\textquotesingle{}b1} 且要写入的地址为 \texttt{preset} 或
\texttt{ctrl} 的起始地址，则写入有效，把对应的寄存器写入
\texttt{write\_data} 对应的内容。注意 \texttt{count}
寄存器禁止写入。注意写入 \texttt{CTRL} 寄存器时，原来为全 0
的位仍然保持全 0。若地址超出范围或写入无效，则什么也不做。

注意：\textbf{地址越界检查由 \texttt{ac}
完成，写入设备的字不对齐时直接被设备忽略，但是会触发异常。}

注意：\textbf{\texttt{count} 寄存器禁止写入，若试图写入 \texttt{count}
寄存器，也会被设备忽略，而且会触发异常。}

最后，进行状态转移。一共有四种状态，在宏定义中描述。每种状态中没有描述的情况，默认为什么也不做。

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  若为 \texttt{TIMER\_IDLE}，则当
  \texttt{enable\ ==\ 1\textquotesingle{}b1} 时，令
  \texttt{irq\_reg\ \textless{}=\ 1\textquotesingle{}b0}，并转移到
  \texttt{TIMER\_LOAD}。否则，若
  \texttt{allow\_irq\ ==\ 1\textquotesingle{}b0} 时，也令
  \texttt{irq\_reg\ \textless{}=\ 1\textquotesingle{}b0}。
\item
  若为 \texttt{TIMER\_LOAD}，则令
  \texttt{count\ \textless{}=\ preset}，并转移到 \texttt{TIMER\_CNT}。
\item
  若为 \texttt{TIMER\_CNT}，则
  \texttt{enable\ ==\ 1\textquotesingle{}b0} 时，转移到
  \texttt{TIMER\_IDLE}。否则，\texttt{\$unsigned(count)\ \textgreater{}\ \$unsigned(1)}
  时，\texttt{count\ \textless{}=\ \$unsigned(count)\ -\ \$unsigned(1)}；\texttt{\$unsigned(count)\ ==\ \$unsigned(1)}
  时， \texttt{count} 同样按照上一种情况自减 1，并转移到
  \texttt{TIMER\_INT}，但是同时在
  \texttt{allow\_irq\ ==\ 1\textquotesingle{}b1}时，令
  \texttt{irq\_reg\ \textless{}=\ 1\textquotesingle{}b1}。
\item
  若为 \texttt{TIMER\_INT}，则 \texttt{mode\ ==\ 1\textquotesingle{}b0}
  时，
  \texttt{enable\ \textless{}=\ 1\textquotesingle{}b0}，这样可以保持中断信号，但\texttt{allow\_irq\ ==\ 1\textquotesingle{}b0}
  时，也得令
  \texttt{irq\_reg\ \textless{}=\ 1\textquotesingle{}b0}；\texttt{mode\ ==\ 1\textquotesingle{}b1}
  时，\texttt{irq\_reg\ \textless{}=\ 1\textquotesingle{}b0}。\texttt{mode}
  的两种值都要转移到 \texttt{TIMER\_IDLE}。
\end{enumerate}

无论什么时候，\texttt{read\_result} 都是 \texttt{addr}
对应的内部寄存器的值。若 \texttt{addr} 超出范围，则为
\texttt{32\textquotesingle{}b0}。无论什么时候，\texttt{irq\ =\ irq\_reg}。

\hypertarget{ux6ce8ux610fux4e8bux9879-12}{%
\subsection{注意事项}\label{ux6ce8ux610fux4e8bux9879-12}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  改寄存器个数的时候记得同时改 \texttt{read\_result} 的判断
\item
  \textbf{地址运算都是无符号的}
\item
  \textbf{\texttt{allow\_irq} 因为默认不会用，所以初始化为 0}
\item
  \textbf{写不该写的寄存器和写的模式错误，写使能信号会被 \texttt{cpu}
  禁用掉，所以不用担心误写}
\end{enumerate}

\hypertarget{ux9876ux5c42ux6a21ux5757}{%
\section{顶层模块}\label{ux9876ux5c42ux6a21ux5757}}

\hypertarget{ux539fux7406-17}{%
\subsection{原理}\label{ux539fux7406-17}}

顶层模块是整个工程的顶层模块，负责把用到的所有电路综合起来。顶层模块包括
CPU 和 \texttt{bridge}，把它们接在一起，形成综合的模块。

\hypertarget{ux7aefux53e3ux5b9aux4e49-15}{%
\subsection{端口定义}\label{ux7aefux53e3ux5b9aux4e49-15}}

\begin{longtable}[]{@{}|l|l|l|l|@{}}
\hline
\headingcellfirst{端口} & \headingcellmiddle{类型} & \headingcellmiddle{位宽} & \headingcelllast{功能}\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & 输入 & 1 & 时钟信号\tabularnewline\hline
\texttt{rst} & 输入 & 1 & 复位信号\tabularnewline\hline

\end{longtable}

\hypertarget{ux63a5ux7ebf-1}{%
\subsection{接线}\label{ux63a5ux7ebf-1}}

CPU 和 \texttt{bridge} 的接线，除了 \texttt{clk} 和 \texttt{rst}
之外都是可以对应的。所以，可以列出对应关系表。

\begin{longtable}[]{@{}|l|l|l|@{}}
\hline
CPU 端口 & \texttt{bridge} 端口 & 数据流动方向\tabularnewline\hline

\endhead\hiderowcolors
\texttt{clk} & \texttt{clk} & 外部 → CPU 和
\texttt{bridge}\tabularnewline\hline
\texttt{rst} & \texttt{rst} & 外部 → CPU 和
\texttt{bridge}\tabularnewline\hline
\texttt{cpu\_addr} & \texttt{addr} & CPU →
\texttt{bridge}\tabularnewline\hline
\texttt{dev\_write\_enable} & \texttt{write\_enable} & CPU →
\texttt{bridge}\tabularnewline\hline
\texttt{cpu\_write\_data} & \texttt{write\_data} & CPU →
\texttt{bridge}\tabularnewline\hline
\texttt{cpu\_read\_result} & \texttt{read\_result} & \texttt{bridge} →
CPU\tabularnewline\hline
\texttt{hwirq} & \texttt{hwirq} & \texttt{bridge} → CPU\tabularnewline\hline

\end{longtable}

\hypertarget{ux529fux80fd-19}{%
\subsection{功能}\label{ux529fux80fd-19}}

顶层模块按照接线连接起 CPU 和 \texttt{bridge}，通过这种方式确定 CPU 和
\texttt{bridge} 之间数据流的流向。
\end{document}

