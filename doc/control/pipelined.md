## 控制

### 原理

控制是指通过识别指令，控制数据的流通，从而让 CPU 执行指定的计算的过程。数据通路只是得到了数据可能的流向，真正要控制还是控制完成。控制通过已有的控制信号和数据通路的分叉完成控制。

在流水线 CPU 中，由于存在结构冒险和数据冒险，所以需要通过暂停和转发解决。暂停控制和转发控制可以放在单独的控制模块中，从而不影响原来单周期时的控制模块。但是，也可以通过改造控制模块的方式集成暂停和转发功能。通过指令识别系列函数（实际上综合时也会被综合成电路），可以分析指令，做到有效的暂停和转发。

### 总体结构

控制模块是时序部件。不设置成组合逻辑部件的原因如下。

1. 哪怕控制本身不设置成时序部件，也需要流水控制信号，这是流水线 CPU 结构上的需要。
2. 控制本身是时序部件，就可以流水更多的信息。最明显的就是指令读写寄存器的信息。比如暴力转发也把指令读写寄存器的信息放在流水线中流水。
3. 保留单周期处理器的控制机制实际上过渡不是那么平滑，因为还有多周期处理器，它的控制是类似状态机的结构。

控制模块在内部流水指令，从而做到比较有效的控制信号发射和数据冒险分析。负责控制信号发射的部分是纯组合逻辑，用函数实现。

### 数据通路和功能控制信号

由于指令的数据通路可以分成几个类型，每种类型中需要的数据通路是一样的，只是某些控制信号不同。而且，流水线是分级的，所以每级控制数据通路形状的信号可以单独列表。

但是，不同的具体指令对不同部件的某些具体操作不同。比如 `CAL_R` 类指令对 ALU 的具体操作就不同。因此，对这些控制具体操作的信号，需要单独列表。

通过对数据通路形状的分析，可以得到每种数据通路类型需要的控制信号如下。其中表格某一单元格的值有两种情况：若该单元格所在的行最左边的单元格是 MUX，则说明对应的指令需要让该 MUX 的输入端口接入该单元格表示的端口；若该单元格所在的行最左边的单元格是端口，则说明对应的指令需要的控制信号为该单元格表示的控制信号。

若单元格以 `#` 开头，则说明该控制信号或端口只是为了使控制单元功能明晰而加上的，实际上并不需要关心该控制信号或要接入的端口的值。如果想理解该单元格的值，去掉 `#` 再按照上一段理解即可。

#### F 级

无相应的控制信号

#### D 级（ID）

数据通路类型 | `D: ext.mode`
--- | ---
`UNKNOWN` | `#EXT_MODE_SIGNED`
`CAL_R` | `#EXT_MODE_SIGNED`
`CAL_I` | 视具体指令而定
`LOAD` | `EXT_MODE_SIGNED`
`STORE` | `EXT_MODE_SIGNED`
`BRANCH` | `#ExT_MODE_SIGNED`
`NOP` | `#EXT_MODE_SIGNED`

`CAL_I` 类指令类型与 `D: ext.mode` 的关系：

指令类型 | `D: ext.mode`
--- | ---
`LUI` | `EXT_MODE_PAD`
`ORI` | `EXT_MODE_UNSIGNED`

#### E 级（EX）

数据通路类型 | `E: m_alu_num2` | `E: alu.op`
--- | --- | ---
`UNKNOWN` | `#D: rf.read_result2` | `#ALU_OR`
`CAL_R` | `D: rf.read_result2` | 视具体指令而定
`CAL_I` | `D: ext.result` | 视具体指令而定
`LOAD` | `D: ext.result` | `ALU_ADD`
`STORE` | `D: ext.result` | `ALU_ADD`
`BRANCH` | `#D: rf.read_result2` | `#ALU_OR`
`NOP` | `#D: rf.read_result2` | `#ALU_OR`

`CAL_R` 类指令类型与 `E: alu.op` 的关系：

指令类型 | `E: alu.op`
--- | ---
`ADDU` | `ALU_ADD`
`SUBU` | `ALU_SUB`

`CAL_I` 类指令类型与 `E: alu.op` 的关系：

指令类型 | `E: alu.op`
--- | ---
`LUI` | `ALU_OR`
`ORI` | `ALU_OR`

#### M 级（MEM）

数据通路类型 | `M: dm.write_enable`
--- | ---
`UNKNOWN` | `1'b0`
`CAL_R` | `1'b0`
`CAL_I` | `1'b0`
`LOAD` | `1'b0`
`STORE` | `1'b1`
`BRANCH` | `1'b0`
`NOP` | `1'b0`

#### W 级（WB）

数据通路类型 | `W: rf.write_enable` | `m_rf.write_data`
--- | --- | --- | ---
`UNKNOWN` | `1'b0` | `#E: alu.result`
`CAL_R` | `1'b1` | `E: alu.result`
`CAL_I` | `1'b1` | `E: alu.result`
`LOAD` | `1'b0` | `E: dm.read_result`
`STORE` | `1'b1` | `#E: alu.result`

### 转发控制信号

由于流水线 CPU 中存在数据冒险，所以需要转发。由于有了指令识别函数，所以转发是非常抽象的，只需要判断涉及的寄存器号。而且只有两个级是转发的接收端（数据的需求者），因此可以在某一级的角度，一级一级往后排查。

注意：**先检查较新级的数据冒险，再检查较老级的，因为 `rf` 中的内容最终还是较新级的。**

对 D 级，先检查 E 级，再检查 M 级，再检查 W 级。对 E 级的寄存器，先检查 M 级，再检查 W 级。这样就能保证转发的完整性。

转发控制信号最终需要控制的是转发 MUX，因此转发 MUX 也要进行宏定义。

MUX | 宏 | 值 | 意义
--- | --- | --- | ---
`fm_d[12]` | `FW_D_NONE` | 2'b00 | D 级不转发
`fm_d[12]` | `FW_D_E` | 2'b01 | D 级从 E 级转发
`fm_d[12]` | `FW_D_M` | 2'b10 | D 级从 M 级转发（`M: alu.result`）
`fm_d[12]` | `FW_D_W` | 2'b11 | D 级从 W 级转发
`fm_e[12]` | `FW_E_NONE` | 2'b00 | E 级不转发
`fm_e[12]` | `FW_E_M` | 2'b01 | E 级从 M 级转发（`M: alu.result`）
`fm_e[12]` | `FW_E_W` | 2'b10 | E 级从 W 级转发

注意：**`FW_A_B` 表示 A 级从 B 级转发。**

### 暂停控制信号

由于在流水线中指令的相对位置不变，所以暂停在老指令和新指令分别在 D 级和 F 级的时候就能判断出来。需要通过关闭使能 `pc` 和清空 D 级流水线寄存器的方式来插入气泡。**因为使用了延迟槽**，只插入一个气泡就够了，因为这样老指令在 W 级的时候，新指令就在 E 级了，转发来得及。

上一段说明了只需要对 D 级和 F 级是什么数据通路类型的指令进行分析，就能把发生数据冒险时要不要暂停判断出来。分析表格如下，其中横着的表头是 F 级指令的数据通路类型，第一列是 D 级指令的数据通路类型。

有些情况实际上可以简化：

1. 因为 `UNKNOWN` 和 `NOP` 类指令不做任何操作，所以不分析。
2. 类似地，因为 `STORE` 和 `BRANCH` 类指令不写任何寄存器，作为老指令不会有任何新指令来不及转发的情况，所以不作为老指令分析。
3. 因为 `CAL_R` 和 `CAL_I` 类指令在 M 级就能出结果，而新指令最快能到 E 级，这个时候 E 级还来得及转发，所以不作为老指令分析。

 | `LOAD`
`CAL_R` | 1
`CAL_I` | 1
`LOAD` | 1
`STORE` | 1
`BRANCH` | 1

真正暂停时，是通过禁用使能 `d_im_result` 寄存器和冻结 `pc` 来插入气泡的。可以利用表示暂停的信号 `stall` 来简化控制，但是要记住两个禁用信号都是 `1'b0`。

注意：**只有在发现数据冒险的时候才需要暂停，其余的情况下不需要。**

### 暂停和转发的相关分析

#### 暂停保证转发的有效性

为了缩短关键路径，`M: dm.read_result` 不能转发到 D 级和 E 级。因此，需要暂停，才能来得及转发。但是这样转发条件一触发，只能是老指令在 W 级，新指令最晚在 E 级这种情况。虽然一旦转发 M 级，只能转发 `M: alu.result`，但是暂停机制保证了转发的数据是有效的。

#### 重复转发不影响指令执行正确性

重复转发有一种典型情况：`M: alu.result -> D: rf.read_result.`，然后 `W: rf.write_data -> E: rf.read_result.`。但是这样重复转发数据是不变的，而且都是合理的转发。而且前面的暂停机制能反过来保证一旦发生转发，都是产生好了正确的数据再转发。因此，重复转发只是多余的，并不会转发错误。

### 寄存器地址控制信号

由于已经有指令识别函数了，所以寄存器的地址控制可以简化。只需要在 D 级和 M 级的三个地址端口输入指令识别函数相应的结果即可。

### 实现

真正实现控制信号时，都是通过函数实现的。这样总体上能提高可维护性，而且不会引入时序代码。

