## 指令识别系列函数

### 原理

指令识别系列函数是为了判断指令的功能而设计的。它可以实现判断指令的具体类型、数据通路类型、需要的控制信号等功能。用这些函数识别出来的数据，就可以判断指令的数据流、转发和暂停相关信息和异常相关信息等。

#### 宏定义

由于有特殊的指令读写固定的寄存器，所以寄存器号也要宏定义。

由于函数的声明需要一定的范式保证健壮性，所以函数的声明本身也要定义。

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

类别 | 定义 | 值 | 意义
--- | --- | --- | ---
寄存器号 | `ZERO` | `5'd0` | 0 号寄存器（或者表示某指令在某函数下对应的寄存器不存在）
寄存器号 | `NULL` | `ZERO` |
寄存器号 | `RA` | `5'd31` | 31 号寄存器（`$ra`，`jal` 指令要写入）
函数声明 | `ROBUST_FUNCTION` | `function automatic` | `automatic` 保证函数同时调用时一定使用不同的硬件块

### 函数列表

* `kind`
* `dptype`

### 输入输出定义

各函数的输入都相同。

输入 | 位宽 | 功能
--- | --- | ---
`instr` | 32 | 要分析的指令

输出见下表。

函数 | 位宽 | 功能
--- | --- | ---
`kind` | 9 | 当前指令的具体类型
`dptype` | 4 | 当前指令的数据通路类型

### `kind`

#### 功能

获取当前指令的具体类型。返回的结果一共 9 位，前 4 位是数据通路类型，后 5 位是具体类型。

若指令的格式符合 MIPS 指令集中的相应格式，则返回对应指令的代码（在宏定义一节中描述）。否则，返回 0。

#### 宏定义

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

编码方式为前 4 位为数据通路类型，后 5 位为其下的具体类型。

指令的意义在表示相应指令的情况下省略不写。但如果有相应备注，也会在这栏注明。

##### 指令字段

类别 | 定义 | 值 | 意义
--- | --- | --- | ---
指令字段 | `GET_OP(x)` | `(x[31:26])` | 指令的 `op` 字段
指令字段 | `GET_RS(x)` | `(x[25:21])` | 指令的 `rs` 字段
指令字段 | `GET_RT(x)` | `(x[20:16])` | 指令的 `rt` 字段
指令字段 | `GET_RD(x)` | `(x[15:11])` | 指令的 `rd` 字段
指令字段 | `GET_SHAMT(x)` | `(x[10:6])` | 指令的 `shamt` 字段
指令字段 | `GET_FUNCT(x)` | `(x[5:0])` | 指令的 `funct` 字段
指令字段 | `GET_IMM(x)` | `(x[15:0])` | 指令的 `imm` 字段
指令字段 | `GET_IMM_J(x)` | `(x[25:0])` | `j` 指令的 `imm` 字段

##### 指令类型

类别 | 定义 | 值 | 意义
--- | --- | --- | ---
指令类型 | `UNKNOWN` | `9'b0000_00000` | 未知指令
指令类型 | `UNK` | `UNKNOWN` | 
指令类型 | `ADDU` | `9'b0001_00000` | 
指令类型 | `SUBU` | `9'b0001_00001` | 
指令类型 | `LUI` | `9'b0010_00000` | 
指令类型 | `ORI` | `9'b0010_00001` | 
指令类型 | `LW` | `9'b0011_00000` | 
指令类型 | `SW` | `9'b0100_00000` | 
指令类型 | `BEQ` | `9'b0101_00000` | 
指令类型 | `NOP` | `9'b1111_00000` | `nop` 指令是 `sll` 指令的一个特例，所以临时开一栏，在扩充指令时会去掉这一类

### `dptype`

#### 功能

获取当前指令的数据通路类型。返回的结果一共 4 位。就是 `get_kind` 的高 4 位。

不同的指令可以使用实际上相同的数据通路（数据的流向一样，只是某些部件的控制不一样），所以对指令区分出数据通路类型可以做出抽象，很好地调节数据通路的各控制信号。

#### 宏定义

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

类别 | 定义 | 值 | 意义
--- | --- | --- | ---
数据通路类型 | `UNKNOWN` | `4'b0000` | 数据通路未知
数据通路类型 | `UNK` | `UNKNOWN` | 
数据通路类型 | `CAL_R` | `4'b0001` | 数据通路类型为计算指令，而且第二个操作数读取寄存器内容
数据通路类型 | `CAL_I` | `4'b0010` | 数据通路类型为计算指令，而且第二个操作数读取指令中的立即数
数据通路类型 | `LOAD` | `4'b0011` | 数据通路类型为加载指令
数据通路类型 | `STORE` | `4'b0100` | 数据通路类型为存储指令
数据通路类型 | `BRANCH` | `4'b0101` | 数据通路类型为分支指令，而且是比较两个寄存器的值
数据通路类型 | `NOP` | `4'b1111` | 数据通路类型为 nop 指令，也是临时开一栏

### 为什么要用函数？

1. 函数是纯组合逻辑，没有引入锁存器的危险
2. 函数可以设置成可重入（`automatic`）的，每次调用都使用不同的硬件资源
3. 函数可以增强模块化程度
4. 在函数里可以很放心地使用 `if` 和 `case` 等常规编程语言能用的语句

### 注意事项

1. `get_read_reg.*` 和 `can_fw_reg.*` 都是跟电路相关的，因为它们都是转发时要用的函数。

### 琐事

1. `ROBUST_FUNCTION` 这个名字 neta 自 LaTeX 的 `DeclareRobustCommand`。
2. `REG_NULL` 这个名字 neta 自 Unix 的 `/dev/null`。
3. 临时的数据通路类型都是从上往下长的。

