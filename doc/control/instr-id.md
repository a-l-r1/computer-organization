## 指令识别系列函数

### 原理

指令识别系列函数是为了判断指令的功能而设计的。它可以实现判断指令的具体类型、数据通路类型、需要的控制信号等功能。用这些函数识别出来的数据，就可以判断指令的数据流、转发和暂停相关信息和异常相关信息等。

#### 宏定义

由于有特殊的指令读写固定的寄存器，所以寄存器号也要宏定义。

由于函数的声明需要一定的范式保证健壮性，所以函数的声明本身也要定义。

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

类别 | 定义 | 值 | 意义
--- | --- | --- | ---
寄存器号 | `REG_ZERO` | `5'd0` | 0 号寄存器（或者表示某指令在某函数下对应的寄存器不存在）
寄存器号 | `REG_NULL` | `REG_ZERO` |
寄存器号 | `REG_RA` | `5'd31` | 31 号寄存器（`$ra`，`jal` 指令要写入）
函数声明 | `ROBUST_FUNCTION` | `function automatic` | `automatic` 保证函数同时调用时一定使用不同的硬件块

### 函数列表

* `get_kind`
* `get_datapath_type`
* `get_read_reg1`
* `get_read_reg2`
* `get_write_reg`
* `can_fw_reg1`
* `can_fw_reg2`

TODO: 函数需要的控制信号

### 输入输出定义

`get_.*` 各函数的输入都相同。

输入 | 位宽 | 功能
--- | --- | ---
`instr` | 32 | 要分析的指令

`can_fw_.*` 各函数的输入都相同。

输入 | 位宽 | 功能
--- | --- | ---
`instr_newer` | 32 | 要分析的较新的指令
`instr_older` | 32 | 要分析的较老的指令

输出见下表。

函数 | 位宽 | 功能
--- | --- | ---
`get_kind` | 9 | 当前指令的具体类型
`get_datapath_type` | 4 | 当前指令的数据通路类型
`get_read_reg1` | 5 | 当前指令读取的第一个寄存器（对应 `rf.read_addr1`）
`get_read_reg2` | 5 | 当前指令读取的第二个寄存器（对应 `rf.read_addr2`）
`get_write_reg` | 5 | 当前指令要写入的寄存器

### `get_kind`

#### 功能

获取当前指令的具体类型。返回的结果一共 9 位，前 4 位是数据通路类型，后 5 位是具体类型。

若指令的格式符合 MIPS 指令集中的相应格式，则返回对应指令的代码（在宏定义一节中描述）。否则，返回 0。

#### 宏定义

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

编码方式为前 4 位为数据通路类型，后 5 位为其下的具体类型。

指令的意义在表示相应指令的情况下省略不写。但如果有相应备注，也会在这栏注明。

类别 | 定义 | 值 | 意义
--- | --- | --- | ---
指令类型 | `UNKNOWN` | `9'b0000_00000` | 未知指令
指令类型 | `UNK` | `UNKNOWN` | 
指令类型 | `ADDU` | `9'b0001_00000` | 
指令类型 | `SUBU` | `9'b0001_00001` | 
指令类型 | `LUI` | `9'b0010_00000` | 
指令类型 | `ORI` | `9'b0010_00001` | 
指令类型 | `LW` | `9'b0011_00000` | 
指令类型 | `SW` | `9'b0100_00000` | 
指令类型 | `BEQ` | `9'b0101_00000` | 
指令类型 | `NOP` | `9'b1111_00000` | `nop` 指令是 `sll` 指令的一个特例，所以临时开一栏，在扩充指令时会去掉这一类

### `get_datapath_type`

#### 功能

获取当前指令的数据通路类型。返回的结果一共 4 位。就是 `get_kind` 的高 4 位。

不同的指令可以使用实际上相同的数据通路，所以对指令区分出数据通路类型可以做出抽象，很好地调节数据通路的各控制信号。

#### 宏定义

用把宏定义成宏的方法，定义表中值为宏的宏。值为宏的宏的意义，与定义它的宏一样，在表中省略。

类别 | 定义 | 值 | 意义
--- | --- | --- | ---
数据通路类型 | `UNKNOWN` | `4'b0000` | 数据通路未知
数据通路类型 | `UNK` | `UNKNOWN` | 
数据通路类型 | `CAL_R` | `4'b0001` | 数据通路类型为计算指令，而且第二个操作数读取寄存器内容
数据通路类型 | `CAL_I` | `4'b0010` | 数据通路类型为计算指令，而且第二个操作数读取指令中的立即数
数据通路类型 | `LOAD` | `4'b0011` | 数据通路类型为加载指令
数据通路类型 | `STORE` | `4'b0100` | 数据通路类型为存储指令
数据通路类型 | `BRANCH` | `4'b0101` | 数据通路类型为分支指令，而且是比较两个寄存器的值
数据通路类型 | `NOP` | `4'b1111` | 数据通路类型为 nop 指令，也是临时开一栏

### `get_read_reg1`、`get_read_reg2` 和 `get_write_reg`

#### 功能

获取当前指令读取的两个寄存器。由于指令读取的两个寄存器是它的数据通路决定的，而数据通路又分了类，所以根据数据通路类型，决定要读取和写入的寄存器。

若当前指令的某函数对应的寄存器不存在，该函数的结果为 `5'b0`，即 0 号寄存器的地址。因为 0 号寄存器不参与转发，所以这样能避免无谓的转发和错误的转发。也就是说，这种方式是按需转发方式，不是暴力转发。比如，`CAL_I` 类指令没有要读取的第二个寄存器，所以它们在 `get_read_reg2` 下的输出都是 `REG_ZERO`。

具体的结果确定方式，按照关系表中描述的进行。

注意：**由于转发是基于电路的，所以** `get_read_reg1` **对应的是** `rf.read_addr1` **对应的地址**。

#### 关系表

数据通路类型 | `get_read_reg1` | `get_read_reg2` | `get_write_reg`
--- | --- | --- | ---
`UNKNOWN` | `REG_NULL` | `REG_NULL` | `REG_NULL` 
`CAL_R` | `instr[25:21]` | `instr[20:16]` | `instr[15:11]` 
`CAL_I` | `instr[25:21]` | `REG_NULL` | `instr[20:16]` 
`LOAD` | `instr[25:21]` | `REG_NULL` | `instr[20:16]` 
`STORE` | `instr[25:21]` | `instr[20:16]` | `REG_NULL` 
`BRANCH` | `instr[25:21]` | `instr[20:16]` | `REG_NULL` 
`NOP` | `REG_NULL` | `REG_NULL` | `REG_NULL` 

### `can_fw_reg1` 和 `can_fw_reg2`

#### 功能

判断两条指令是否有数据冒险，需要转发。这里这两个函数并不知道两个指令在哪一级，因此每碰到能转发的情况，都会转发。但是，暂停机制会保证，到了允许转发的地方刚好开始转发，而且之后产生的数据都应该不变。而且，指令连续接受转发时只有在 D 级后面和 E 级开头被连续接受转发这一种情况，转发产生的数据不变，因此结果也不会变。所以一直转发对指令的执行结果没有影响。

由于有了对指令读写寄存器的抽象，所以只需要判断指令对寄存器的读写关系即可。而且，由于 0 号寄存器不参与转发，所以只要转发的一方是 0 号寄存器，马上取消转发。

因此，最后 `can_fw_reg1` 的逻辑即为：若 `instr_new` 读取的第一个寄存器和 `instr_old` 写入的寄存器相同且 `instr_new` 读取的第一个寄存器不为 `REG_NULL`。当然也可以加上对 `instr_old` 的判断，不过逻辑上等价，就不需要了。

转发时 `instr_new` 表示较新进入流水线的指令，`instr_old` 表示较老进入流水线的指令。

注意：**由于转发是基于电路的，所以** `can_fw_reg1` **对应的是** `rf.read_addr1` **对应的地址**。

### 为什么要用函数？

1. 函数是纯组合逻辑，没有引入锁存器的危险
2. 函数可以设置成可重入（`automatic`）的，每次调用都使用不同的硬件资源
3. 函数可以增强模块化程度
4. 在函数里可以很放心地使用 `if` 和 `case` 等常规编程语言能用的语句

### 注意事项

1. `get_read_reg.*` 和 `can_fw_reg.*` 都是跟电路相关的，因为它们都是转发时要用的函数。

### 琐事

1. `ROBUST_FUNCTION` 这个名字 neta 自 LaTeX 的 `DeclareRobustCommand`。
2. `REG_NULL` 这个名字 neta 自 Unix 的 `/dev/null`。
3. 临时的数据通路类型都是从上往下长的。

