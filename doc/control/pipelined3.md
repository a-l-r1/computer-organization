## 控制

### 原理

控制是指通过识别指令，控制数据的流通，从而让 CPU 执行指定的计算的过程。数据通路只是得到了数据可能的流向，真正要控制还是控制完成。控制通过已有的控制信号和数据通路的分叉完成控制。

在流水线 CPU 中，由于存在结构冒险和数据冒险，所以需要通过暂停和转发解决。暂停控制和转发控制可以放在单独的控制模块中，从而不影响原来单周期时的控制模块。但是，也可以通过改造控制模块的方式集成暂停和转发功能。通过指令识别系列函数（实际上综合时也会被综合成电路），可以分析指令，做到有效的暂停和转发。

### 端口定义

端口 | 类型 | 位宽 | 功能
--- | --- | --- | ---
`clk` | 输入 | 1 | 时钟信号
`d_instr` | 输入 | 32 | 当前在 D 级（ID）的指令
`e_instr` | 输入 | 32 | 当前在 E 级（EX）的指令
`m_instr` | 输入 | 32 | 当前在 M 级（MEM）的指令
`w_instr` | 输入 | 32 | 当前在 W 级（WB）的指令

端口 | 类型 | 位宽 | 功能
--- | --- | --- | ---
`rf_read_result2` | 输入 | 32 | `rf` 的 2 号读取结果
`e_md_busy` | 输入 | 1 | 输入 `E: md.busy`
`m_dm_addr` | 输入 | 32 | 输入 `M: dm.read_addr`（其实也是 `M: dm.write_addr`）

端口 | 类型 | 位宽 | 功能
--- | --- | --- | ---
`f_pc_invalid` | 输入 | 1 | 输入 `F: pc.invalid`
`e_alu_sig_overflow` | 输入 | 1 | 输入 `E: alu.sig_overflow`
`d_pc_curr_pc` | 输入 | 32 | 输入 `D: pc.curr_pc`
`e_pc_curr_pc` | 输入 | 32 | 输入 `E: pc.curr_pc`
`m_pc_curr_pc` | 输入 | 32 | 输入 `M: pc.curr_pc`
`have2handle` | 输入 | 1 | `cp0` 是否必须进入 ISR

端口 | 类型 | 位宽 | 功能
--- | --- | --- | ---
`cw_f_pc_enable` | 输出 | 1 | 控制 `pc` 使能
`cw_d_pff_enable` | 输出 | 1 | 控制 D 级流水线寄存器使能
`cw_d_pff_rst` | 输出 | 1 | 控制 D 级流水线寄存器复位
`cw_e_pff_rst` | 输出 | 1 | 控制 E 级流水线寄存器复位
`cw_m_pff_rst` | 输出 | 1 | 控制 M 级流水线寄存器复位
`cw_w_pff_rst` | 输出 | 1 | 控制 W 级流水线寄存器复位

端口 | 类型 | 位宽 | 功能
--- | --- | --- | ---
`cw_f_npc_jump_mode` | 输出 | 4 | 控制 `npc` 的跳转模式

端口 | 类型 | 位宽 | 功能
--- | --- | --- | ---
`cw_d_ext_mode` | 输出 | 3 | 控制 `D: ext.mode`
`cw_d_rf_read_addr1` | 输出 | 5 | 控制 `D: rf.read_addr1`
`cw_d_rf_read_addr2` | 输出 | 5 | 控制 `D: rf.read_addr2`

端口 | 类型 | 位宽 | 功能
--- | --- | --- | ---
`cw_e_m_alusrc` | 输出 | 1 | 控制 `E: m_alusrc`
`cw_e_alu_op` | 输出 | 5 | 控制 `E: alu.op`
`cw_e_md_op` | 输出 | 3 | 控制 `E: md.op`
`cw_e_m_hilo` | 输出 | 1 | 控制 `E: m_hilo`

端口 | 类型 | 位宽 | 功能
--- | --- | --- | ---
`cw_m_m_bridge` | 输出 | 1 | 控制 `M: m_bridge`
`cw_m_dm_write_enable` | 输出 | 1 | 控制 `M: dm.write_enable`
`cw_m_dm_mode` | 输出 | 1 | 控制 `M: dm.mode`
`cw_m_cp0_write_enable` | 输出 | 1 | 控制 `M: cp0.write_enable`
`cw_m_cp0_exit_isr` | 输出 | 1 | 控制 `M: cp0.exit_isr`
`cw_m_cp0_in_bds` | 输出 | 1 | 控制 `M: cp0.in_bds`
`cw_m_cp0_exc` | 输出 | 5 | 控制 `M: cp0.exc`
`cw_m_cp0_curr_pc` | 输出 | 32 | 控制 `M: cp0.curr_pc`

端口 | 类型 | 位宽 | 功能
--- | --- | --- | ---
`cw_w_rf_write_enable` | 输出 | 1 | 控制 `W: rf.write_enable`
`cw_w_m_regdata` | 输出 | 3 | 控制 `W: m_rf_write_data`
`cw_w_rf_write_addr` | 输出 | 5 | 控制 `W: rf.write_addr`

端口 | 类型 | 位宽 | 功能
--- | --- | --- | ---
`cw_fm_d[12]` | 输出 | 4 | 控制 `fm_d[12]`
`cw_fm_e[12]` | 输出 | 4 | 控制 `fm_e[12]`
`cw_fm_m` | 输出 | 3 | 控制 `fm_w`
`cw_fm_epc` | 输出 | 3 | 控制 `fm_epc`

### 总体结构

控制模块是时序部件。不设置成组合逻辑部件的原因如下。

1. 哪怕控制本身不设置成时序部件，也需要流水控制信号或者异常信号，这是流水线 CPU 结构上的需要。
2. 控制本身是时序部件，就可以流水更多的信息。最明显的就是指令读写寄存器的信息。比如暴力转发也把指令读写寄存器的信息放在流水线中流水。
3. 保留单周期处理器的控制机制实际上过渡不是那么平滑，因为还有多周期处理器，它的控制是类似状态机的结构。

但是实际上控制模块在内部并不流水指令，而是把流水指令放到了数据通路中。这是因为数据通路的 E 级和 M 级都需要指令，而且在处理暂停和进入 ISR 时，统一的指令存储和流水线寄存器清除逻辑实际上更方便。

控制模块在内部流水异常信号和指令需要的寄存器，把流水指令的任务交给数据通路，从而做到比较有效的控制信号发射、数据冒险分析和异常收集与分析。负责控制信号发射的部分是纯组合逻辑，用函数实现。

同时，控制模块也在内部计算出指令需要读取和写入的三个寄存器。因为流水线 CPU 和单周期 CPU 逻辑上应该一样，所以一条指令需要读取和写入的三个寄存器可以直接判断出来。这样也可以更方便地处理数据冒险。

### 数据通路和功能控制信号

由于指令的数据通路可以分成几个类型，每种类型中需要的数据通路是一样的，只是某些控制信号不同。而且，流水线是分级的，所以每级控制数据通路形状的信号可以单独列表。

但是，不同的具体指令对不同部件的某些具体操作不同。比如 `CAL_R` 类指令对 ALU 的具体操作就不同。因此，对这些控制具体操作的信号，需要单独列表。

通过对数据通路形状的分析，可以得到每种数据通路类型需要的控制信号如下。其中表格某一单元格的值有两种情况：若该单元格所在的行最左边的单元格是 MUX，则说明对应的指令需要让该 MUX 的输入端口接入该单元格表示的端口；若该单元格所在的行最左边的单元格是端口，则说明对应的指令需要的控制信号为该单元格表示的控制信号。

若单元格以 `#` 开头，则说明该控制信号或端口只是为了使控制单元功能明晰而加上的，实际上并不需要关心该控制信号或要接入的端口的值。如果想理解该单元格的值，去掉 `#` 再按照上一段理解即可。

由于加入了中断和异常处理，而且有些中断和异常处理是需要覆盖当前指令的正常控制信号的，所以跟中断和异常处理有关的控制信号省略不写。

#### F 级

数据通路类型 | `F: npc.jump_mode`
--- | ---
`BRANCH` | 视具体指令而定
`JUMP_I` | `NPC_J`
`JUMP_R` | `NPC_REG`
`JUMP_C0` | `NPC_EPC`
（其它）| `NPC_JUMP_DISABLED`

`BRANCH` 类指令类型与 `F: npc.jump_mode` 的关系：

指令类型 | `F: npc.jump_mode`
--- | ---
`BEQ` | `NPC_EQUAL`
`BNE` | `NPC_NOT_EQUAL`
`BLEZ` | `NPC_SIG_SMALLER_OR_EQUAL`
`BGEZ` | `NPC_SIG_LARGER_OR_EQUAL`
`BLTZ` | `NPC_SIG_SMALLER`
`BGTZ` | `NPC_SIG_LARGER`

注意：**F 级的控制信号是由 D 级指令控制的。**

注意：**BRANCH 类指令要跟 0 比较的那些指令，是通过读 `$0` 比较的，所以能直接进行大小比较。**

#### D 级（ID）

数据通路类型 | `D: ext.mode`
--- | ---
`CAL_I` | 视具体指令而定
`LOAD` | `EXT_MODE_SIGNED`
`STORE` | `EXT_MODE_SIGNED`
（其它）| `#EXT_MODE_SIGNED`

`CAL_I` 类指令类型与 `D: ext.mode` 的关系：

指令类型 | `D: ext.mode`
--- | ---
`LUI` | `EXT_PAD`
`ORI` | `EXT_UNSIGNED`
`ADDI` | `EXT_SIGNED`
`ADDIU` | `EXT_SIGNED`
`ANDI` | `EXT_UNSIGNED`
`XORI` | `EXT_UNSIGNED`
`SLTI` | `EXT_SIGNED`
`SLTIU` | `EXT_SIGNED`

注意：**`SLTIU` 扩展立即数的时候确实是按照有符号扩展的，但比较是按照无符号数比较，可以查指令手册。**

#### E 级（EX）

数据通路类型 | `E: m_alusrc` | `E: alu.op` | `E: md.op` | `E: m_hilo`
--- | --- | --- | --- | ---
`CAL_R` | `D: rf.read_result2` | 视具体指令而定 | `MD_NONE` | `#E: md.hi`
`CAL_I` | `D: ext.result` | 视具体指令而定 | `MD_NONE` | `#E: md.hi`
`LOAD` | `D: ext.result` | `ALU_ADD` | `MD_NONE` | `#E: md.hi`
`STORE` | `D: ext.result` | `ALU_ADD` | `MD_NONE` | `#E: md.hi`
`BRANCH` | `D: rf.read_result2` | `#ALU_OR` | `MD_NONE` | `#E: md.hi`
`CMOV` | `D: rf.read_result2` | 视具体指令而定 | `MD_NONE` | `#E: md.hi`
`CAL_M` | `#D: rf.read_result2` | `#ALU_OR` | 视具体指令而定 | `#E: md.hi`
`LOAD_M` | `#D: rf.read_result2` | `#ALU_OR` | 视具体指令而定 | 视具体指令而定
`STORE_M` | `#D: rf.read_result2` | `#ALU_OR` | 视具体指令而定 | `#E: md.hi`
（其它）| `#D: rf.read_result2` | `#ALU_OR` | `MD_NONE` | `#E: md.hi`

`CAL_R` 类指令类型与 `E: alu.op` 的关系：

指令类型 | `E: alu.op`
--- | ---
`ADDU` | `ALU_ADD`
`SUBU` | `ALU_SUB`
`ADD` | `ALU_ADD`
`SUB` | `ALU_SUB`
`AND` | `ALU_AND`
`OR` | `ALU_OR`
`NOR` | `ALU_NOR`
`XOR` | `ALU_XOR`
`SLT` | `ALU_SLT`
`SLTU` | `ALU_SLTU`
`SLL` | `ALU_SLL`
`SRL` | `ALU_SRL`
`SRA` | `ALU_SRA`
`SLLV` | `ALU_SLLV`
`SRLV` | `ALU_SRLV`
`SRAV` | `ALU_SRAV`

`CAL_I` 类指令类型与 `E: alu.op` 的关系：

指令类型 | `E: alu.op`
--- | ---
`LUI` | `ALU_OR`
`ORI` | `ALU_OR`
`ADDI` | `ALU_ADD`
`ADDIU` | `ALU_ADD`
`ANDI` | `ALU_AND`
`XORI` | `ALU_XOR`
`SLTI` | `ALU_SLT`
`SLTIU` | `ALU_SLTU`

`CMOV` 类指令类型与 `E: alu.op` 的关系：

指令类型 | `E: alu.op`
--- | ---
`MOVZ` | `ALU_MOVZ`

`CAL_M` 类指令类型与 `E: md.op` 的关系：

指令类型 | E: md.op
--- | ---
`MULT` | `MD_MULT`
`MULTU` | `MD_MULTU`
`DIV` | `MD_DIV`
`DIVU` | `MD_DIVU`

`LOAD_M` 类指令类型与 `E: md.op` 的关系：

指令类型 | `E: md.op`
--- | ---
`MFHI` | `MD_MFHI`
`MFLO` | `MD_MFLO`

`STORE_M` 类指令类型与 `E: md.op` 的关系：

指令类型 | `E: md.op`
--- | ---
`MTHI` | `MD_MTHI`
`MTLO` | `MD_MTLO`

`LOAD_M` 类指令类型与 `E: m_hilo` 的关系：

指令类型 | `E: m_hilo`
--- | ---
`MFHI` | `E: md.hi`
`MFLO` | `E: md.lo`

#### M 级（MEM）

数据通路类型 | `M: dm.write_enable` | `M: dm.mode` | `M: cp0.write_enable`
--- | --- | --- | ---
`LOAD` | 1'b0 | 视具体指令而定 | `1'b0`
`STORE` | `1'b1` | 视具体指令而定 | `1'b0`
`LOAD_C0` | `1'b0` | `DM_NONE` | `1'b0`
`STORE_C0` | `1'b0` | `DM_NONE` | `1'b1`
（其它）| `1'b0` | `DM_NONE` | `1'b0`

注意：**`STORE` 类指令类型会把 `dm` 和 `bridge` 的写使能都打开，但是它们两个写到无效地址时会无效，而且有 `ac` 检查地址，所以出错时不会有副作用。**

注意：**`M: ac.dm_mode` 和 `M: dm.write_enable` 和 `M: dm.mode` 相同，实现的时候把它的信号设置成 `dm` 对应的信号。**

`LOAD` 类指令类型与 `M: dm.mode` 的关系：

指令类型 | `M: dm.mode`
--- | ---
`LW` | `DM_W`
`LH` | `DM_H`
`LHU` | `DM_HU`
`LB` | `DM_B`
`LBU` | `DM_BU`

`STORE` 类指令类型与 `M: dm.mode` 的关系：

指令类型 | `M: dm.mode`
--- | ---
`SW` | `DM_W`
`SH` | `DM_H`
`SB` | `DM_B`

#### W 级（WB）

数据通路类型 | `W: rf.write_enable` | `W: m_regdata`
--- | --- | ---
`CAL_R` | `1'b1` | `E: alu.result`
`CAL_I` | `1'b1` | `E: alu.result`
`LOAD` | `1'b1` | `E: dm.read_result`
`JUMP_I` | `1'b1` | `D: npc.next_pc`
`JUMP_R` | `1'b1` | `D: npc.next_pc`
`CMOV` | `1'b1` | `E: alu.result`
`LOAD_M` | 1'b1 | `E: md.out`
`LOAD_C0` | `1'b1` | `E: cp0.read_result`
（其它）| `1'b0` | `#E: alu.result`

#### 流水的内容

流水 E 级、M 级、W 级指令及其要读的两个寄存器和要写的一个寄存器。不流水 D 级指令是为了配合暂停机制，D 级一被暂停，D 级指令只在组合逻辑跟着变化，不需要再在控制模块里改变 D 级指令的值。

为了处理异常和中断，还要把每级指令的异常流水。下一级的异常默认流水这一级保存的异常，但是如果这一级又新增了异常，那么就流水这一级新增的异常。D 级异常流水寄存器默认流水 `EXC_NONE`。这样可以保证异常不断流水，而且能够做到先处理老异常再处理新异常。

注意：**检测到新异常就流水会让一条指令中更新级的异常覆盖这条指令更老级产生的异常，比如 `lw` 指令加法溢出了同时不对齐。**

#### 指令读写寄存器识别

比较显然的一点是数据通路类型决定指令要读写的寄存器号。所以，可以直接用取指令字段的宏来完成。

数据通路类型和指令读写寄存器的关系如下。如果指令不读写哪个寄存器，就用 `ZERO` 替换，因为 `ZERO` 不参与转发。这样，对转发正确性也没有影响。其中使用的获取指令字段的宏隐含着用要分析的指令作为参数。

指令读写寄存器识别并没有识别 `cp0` 的相应寄存器，因为 `cp0` 大体上和 `dm` 类似，需要解决数据冒险的只是 `STORE_C0` +` JUMP_C0` 着一种情况。这种情况只要在转发逻辑上加入相应逻辑即可解决。

指令读写寄存器识别也要在进入 ISR 时把所有流水指令读写寄存器号的寄存器全部清空。为了使设计更简洁，也是通过借用数据通路流水线的复位信号实现的。如果某一级数据通路流水线寄存器的复位信号为 `1'b1`，那么这一级对应的流水指令读写寄存器号的寄存器也要复位。否则，就直接写入上一级数据通路流水线寄存器的值。

注意：**W 级也有这一级数据通路流水线寄存器的复位信号（为了防止出现异常的指令进入下一级），所以也要设置上一段说的复位逻辑。**

数据通路类型 | `reg1` | `reg2` | `regw`
--- | --- | --- | ---
`CAL_R` | `RS` | `RT` | `RD`
`CAL_I` | `RS` | `ZERO` | `RT`
`LOAD` | `RS` | `ZERO` | `RT`
`STORE` | `RS` | `RT` | `ZERO`
`BRANCH` | `RS` | 视指令类型而定（[4]） | `ZERO`
`JUMP_I` | `ZERO` | `ZERO` | 视指令而定（[2]）
`JUMP_R` | `RS` | `ZERO` | 视指令而定（[3]）
`CMOV` | `RS` | `RT` | 视寄存器值而定（[1]）
`CAL_M` | `RS` | `RT` | `ZERO`
`LOAD_M` | `ZERO` | `ZERO` | `RD`
`STORE_M` | `RS` | `ZERO` | `ZERO`
`LOAD_C0` | `ZERO` | `ZERO` | `RT`
`STORE_C0` | `ZERO` | `RT` | `ZERO`
`JUMP_C0` | `ZERO` | `ZERO` | `ZERO`
（其它）| `ZERO` | `ZERO` | `ZERO`

注：

1. 有一点就是 `CMOV` 类指令。这类指令的一种实现是无条件把要写入的数据看成是 `$rs` 的值，但是**改变要写入的寄存器号**。如果 `$rt == 32'b0`，就写入 `$rd`，否则写入 `$0 / ZERO`。这样，加上把要读写的寄存器号流水的机制，能保证 `CMOV` 类指令的数据冒险处理不出错。哪怕在 W 级打开了 `rf` 的写使能，写入 `$0` 也没有影响。
2. `JUMP` 类指令若为 `jal`，则 `regw == RA`。若为 `j`，则 `regw == ZERO`。
3. `JUMP_R` 类指令若为 `jr`，则 `regw == ZERO`。若为 `jalr`，则 `regw == RD`。由于 `jr` 指令 `RS` 字段永远为 0，所以这样分析是正确的。
4. `BRANCH` 类指令若为 `beq` 或 `bne`，则 `reg2 == RT`。若为 `blez, bgez, bltz, bgtz`，则 `reg2 == ZERO`。由于这样会让 `cmp` 的比较结果变成对应寄存器与 0 的比较，符合指令功能描述，所以这样分析是正确的。

### 转发控制信号

由于流水线 CPU 中存在数据冒险，所以需要转发。由于有了指令识别函数，所以转发是非常抽象的，只需要判断涉及的寄存器号。而且只有两个级是转发的接收端（数据的需求者），因此可以在某一级的角度，一级一级往后排查。

注意：**先检查较新级的数据冒险，再检查较老级的，因为 `rf` 中的内容最终还是较新级的。**

对 D 级，先检查 E 级，再检查 M 级，再检查 W 级。对 E 级的寄存器，先检查 M 级，再检查 W 级。这样就能保证转发的完整性。

对 M 级的 `epc`，先检查 D 级，再检查 E 级，这样也是为了保证转发的完整性。现在只有一种情况可以转发，就是 `mtc0` + `eret`。如果 `mtc0` 要写入的寄存器号正好是 `epc` 的寄存器号，就要转发。

转发控制信号最终需要控制的是转发 MUX，因此转发 MUX 也要进行定义。

下表是所有转发的情况和具体的描述。意义中说的数据通路类型，都是源指令的数据通路类型。

类别 | 定义 | 值 | 意义
--- | --- | --- | ---
所有转发 MUX | `orig` | `0` | 不转发，保持原样
`fm_d[12]` | `E2D_rf` | `1` | E 级到 D 级，数据通路类型是 `CMOV`，要写入的数据在 D 级产生好了，到了 E 级才能转发
`fm_d[12]` | `E2D_npc` | `2` | E 级到 D 级，数据通路类型是 `JUMP_I / JUMP_R`，要写入的数据在 D 级产生好了，到了 E 级才能转发
`fm_d[12]` |  `M2D_npc` | `3` | M 级到 D 级，之后同上
`fm_d[12]` | `M2D_alu` | `4` | M 级到 D 级，数据通路类型是 `CAL_R / CAL_I / CMOV`，数据在 D 级或 E 级产生好了，但对 `CAL_R / CAL_I` 来说，到了 M 级才能转发
`fm_d[12]` | `W2D_rf` | `5` | W 级到 D 级，数据通路类型是所有能够写入寄存器的类型，数据在 W 级都可以转发了
`fm_d[12]` | `M2D_md` | `6` | M 级到 D 级，数据通路类型是 `LOAD_M`，数据在 E 级产生好了
`fm_d[12]` | `E2D_md` | `7` | E 级到 D 级，数据通路类型是 `LOAD_M`，数据在 E 级产生好了
`fm_d[12]` | `M2D_cp0` | `8` | E 级到 D 级，数据通路类型是 `LOAD_C0`，数据在 M 级产生好了

类别 | 定义 | 值 | 意义
--- | --- | --- | ---
`fm_e[12]` | `M2E_npc` | `1` | M 级到 E 级，数据通路类型是 `JUMP_I / JUMP_R`，要写入的数据在 D 级产生好了，到了 E 级才能转发
`fm_e[12]` | `M2E_alu` | `2` | M 级到 E 级，数据通路类型是 `CAL_R / CAL_I / CMOV`，数据在 D 级或 E 级产生好了，但对 `CAL_R / CAL_I` 来说，到了 M 级才能转发
`fm_e[12]` | `W2E_rf` | `3` | W 级到 E 级，数据通路类型是所有能够写入寄存器的类型，数据在 W 级都可以转发了
`fm_e[12]` | `M2E_md` | `4` | M 级到 E 级，数据通路类型为 `LOAD_M`，数据在 E 级产生好了
`fm_e[12]` | `M2E_cp0` | `5` | M 级到 E 级，数据通路类型是 `LOAD_C0`，数据在 M 级产生好了 

类别 | 定义 | 值 | 意义
--- | --- | --- | ---
`fm_m` | `W2M_rf` | `1` | W 级到 M 级，数据通路类型是所有能够写入寄存器的类型，数据在 W 级都可以转发了（比如 `sw` 指令转发 `rf` 内容）

类别 | 定义 | 值 | 意义
--- | --- | --- | ---
`fm_epc` | `EPC_D2M_rf` | `1` | D 级到 M 级，数据通路类型是 `STORE_C0`，数据在 D 级产生好了
`fm_epc` | `EPC_E2M_rf` | `2` | E 级到 M 级，数据通路类型是 `STORE_C0`，数据在 D 级产生好了
`fm_epc` | `EPC_M2M_rf` | `3` | M 级到 M 级，数据通路类型是 `STORE_C0`，数据在 M 级产生好了，但是 D 级的 `JUMP_C0` 类指令马上就需要新的 `epc` 值了，来不及等到下一个时钟上升沿

注意：
1. **`B2A_.*` 表示 B 级从 A 级转发。**
2. **宏的值要和对应转发 MUX 的接线顺序相符。**
3. **`E2D_rf` 表示把 E 级的第一个寄存器转发出去，因为用到这条指令的是 `CMOV` 类指令，它可以在 D 级完成要写入数据的判断。**
4. *`fm_m` 检查的是要读取的第二个寄存器，因为现在用到的所有写入内存或设备的指令，要写入内存的数据都与相应指令第二个寄存器的读取结果对应。类似地，`fm_epc` 检查的也是要读取的第二个寄存器，因为现在用到的所有写入 `epc` 的指令，要写入 `cp0` 的数据也是都与相应指令第二个寄存器的读取结果对应。以后可能加上检查要读取的第一个寄存器，不过也是要根据指令类型判断了。**

### 暂停控制信号

由于流水线中有些数据冒险通过转发解决不了，所以需要暂停机制。暂停机制的前提是产生数据冒险。暂停机制是通过 Tuse 和 Tnew 机制实现的。

Tuse 是指指令到 D 级以后还剩最晚多少时间就需要新值。Tnew 是指指令还需要多长时间才能开始转发。因此只要 Tuse < Tnew，就需要暂停，因为在流水线中如果没有暂停，两条指令的相对位置是不变的，如果不暂停，就不能解决数据冒险。

数据冒险可以只在 D 级检测和在 E 级解决，因为在 E 级插入气泡，就可以保证 Tuse 和 Tnew 最终会回归正常。

插入气泡是通过锁定 `pc` 和清空 E 级各个流水线寄存器实现的。但是，控制内部的流水线也要插入气泡。同时，判断异常的流水线也要插入气泡。

暂停要分两个寄存器，因为数据冒险也是要分成两个寄存器的情况的。

注意：**Tnew 的计算是要看能够开始转发的时间，而不是生成好要转发数据的时间，因为不是所有转发路径都是可能的。**

注意：**控制内部的流水线和判断异常的流水线也要插入气泡。**

在 D 级各种数据通路类型的 Tuse 如下。

数据通路类型 | Tuse (read\_addr1) | Tuse (read\_addr2)
--- | --- | ---
`UNKNOWN` | | 
`CAL_R` | 1 | 1
`CAL_I` | 1 | 1
`LOAD` | 1 |
`STORE` | 1 | 2
`BRANCH` | 0 | 0
`JUMP_I` | | 
`JUMP_R` | 0 |
`CMOV` | 0 | 0
`CAL_M` | 1 | 1
`LOAD_M` | |
`STORE_M` | 1 | 1
`LOAD_C0` | |
`STORE_C0` | | 2
`JUMP_C0` | |

在 E 级和 M 级各种数据通路类型的 Tnew 如下。忽略 W 级，因为所有指令到 W 级时都可以马上转发数据。

数据通路类型 | Tnew (E) | Tnew (M)
--- | --- | ---
`UNKNOWN` | |
`CAL_R` | 1 | 0
`CAL_I` | 1 | 0
`LOAD` | 2 | 1
`STORE` | |
`BRANCH` | | 
`JUMP_I` | 0 | 0
`JUMP_R` | 0 | 0
`CMOV` | 0 | 0
`NOP` | |
`CAL_M` | |
`LOAD_M` | 0 | 0
`STORE_M` | |
`LOAD_C0` | 1 | 0
`STORE_C0` | |
`JUMP_C0` | |

以上列表中 Tuse 没有列出的，是因为它没有意义，认为 Tuse 足够大。Tnew 同理，认为 Tnew 为 0。

这样，只要算出每个阶段的 Tuse 和 Tnew，并且保证发生数据冒险时对两个寄存器，Tuse >= Tnew，就能控制暂停和转发。当且仅当 `t_use_reg[12]` 小于 `t_new_[em]` 中的任何一个时，需要暂停。

`e_md_busy == 1'b1` 时，会一直插入气泡，直到 `e_md_busy == 1'b0`。而且，`CAL_M` 类指令虽然进行计算，但不写普通寄存器，所以跟其它指令没有转发解决不了的数据冒险，所以不停地插入气泡这种方式是可以解决数据冒险的。而且，跟 `dm` 类似，`md` 的 `HI` 和 `LO` 寄存器也没有数据冒险。因此，乘除法相关指令和其它指令之间，可以看成解决了需要暂停的问题，虽然 `md` 需要多个周期运行。

由于 `cp0` 和 `dm` 类似，只有一种需要转发的情况，所以暂停不需要通过 Tuse 和 Tnew 机制来实现。但是，确实有一种情况需要暂停，就是 D 级为 `JUMP_C0`、E 级为 `STORE_C0` 而且写入的寄存器就是 `epc`，M 级 Tnew 为 1 的情况。这是因为 `JUMP_C0` 只能在 D 级，`STORE_C0` 在 M 级或者往后就直接能转发了。如果 `STORE_C0` 在 E 级，那么 M 级的 Tnew 为 0 时，就能两级转发了。但是，如果 M 级的 Tnew 大于 0，两级转发就构造不起来，但是 D 级的 `JUMP_C0` 这类指令又马上要用，所以只能暂停了。

注意：**比较 Tuse 和 Tnew 应该用无符号比较，避免数值最高位是 1 时被看成负数。**

注意：**异常处理需要的 F 级暂停在异常处理一节里。**

### 寄存器地址控制信号

由于已经有指令识别机制了，所以寄存器的地址控制可以简化。只需要在 D 级和 M 级的三个地址端口输入指令识别机制相应的结果即可。

### 设备访问

#### 设备读写

设备读写是通过 `bridge` 模块进行的。`bridge` 模块通过把设备的内部寄存器读写映射成类似 `dm` 的方式，通过按字索引操作设备的内部寄存器。

但是，读写的地址验证，还是通过专门的 `ac` 模块进行的，`bridge`、`dm` 和外部设备只是忽略不合法的读写操作。

#### 控制读入结果

由于有了 `bridge` 和 `dm`，所以会有两个并行的读入结果。在这种情况下，选择哪个读入结果是根据地址决定的。这样就把 `bridge` 和 `dm` 的结果统一成了 `M: dm.read_result`，使数据冒险的处理更为简便。

由于内存的地址范围是固定的，所以采用只判断内存地址范围的方式来选择 `M: dm.read_result` 其实是哪个结果。如果 `m_dm_addr` 在内存地址的范围之内，就选择原来的 `M: dm.read_result`，否则选择 `cpu_read_result`。选择的 MUX 是 `m_bridge`，定义原来的 `M: dm.read_result` 和 `cpu_read_result` 分别为 `1'b0` 和 `1'b1`，按照这种选择逻辑选择相应的信号。

注意：**地址比较要用无符号数比较。**

### 异常和中断处理

#### 异常处理

通过异常流水线的机制处理异常。但是，下一级的存储异常的寄存器能够用这一级的异常覆盖这一级存储异常的寄存器原来存储的值。而且，在暂停时，相应级的寄存器也要插入气泡，也就是 `EXC_NONE`。

由于 `cp0` 部署在 M 级处理异常，但需要防止受害指令进入 M 级，所以在 D 级、E 级、M 级和 W 级有异常流水寄存器。然后，在 M 级把这一级的异常流水寄存器和这一级产生的异常再进行比较，如果这一级有地址异常（也就是 `M: ac.validity != AC_VALID`），就认为 M 级指令产生了异常，首先处理 M 级指令的异常，把 M 级指令的异常字段设成 `ac.validity` 的非正常情况对应的值，同时根据 `dm` 是否写使能的原来的信号判断 `dm` 的读写模式。然后，把最终得到的 M 级指令的异常输出给 `cp0`。

注意：**为了正确判断 `dm` 写使能原来的信号，需要在控制模块内部判断。不能用输出的 `dm` 写使能信号，因为这样能被 `have2handle` 覆盖。**

如果需要进入 ISR，就把 D 级、E 级、M 级和 W 级的流水线寄存器全部复位，并加上相应的钩子机制，使下个时钟上升沿带来的数据写入被取消，而且把 PC 改成 ISR 的。

注意：**为了防止受害指令进入 M 级，需要把 M 级流水线寄存器复位。**

由于暂停会让 F 级和 D 级的指令停住不动，所以它的优先级最大。由于 `JUMP_C0` 类指令不是跳转指令，所以不能实现延迟槽，不暂停的时候需要复位 D 级流水线寄存器，通过这种方式插入气泡。这样，存储异常的寄存器的更改逻辑需要一定的调整。

每级存储异常的寄存器更新逻辑如下：

流水线级 | 更新逻辑
--- | ---
D 级 | 若 `cw_d_pff_rst == 1'b1`，则值变为 `EXC_NONE`。若需要暂停，则值不变。否则，若 D 级数据通路类型为 `JUMP_C0`，则插入气泡。否则，若 `F: pc.invalid == 1'b1`，则写入 `EXC_ADEL`。否则，写入 `EXC_NONE`。
E 级 | 若 `cw_e_pff_rst == 1'b1`，则值变为 `EXC_NONE`。若需要暂停，则写入 `EXC_NONE`。否则，若 `d_instr_kind == UNKNOWN`，则写入 `EXC_RI`。否则，写入 D 级的值。
M 级 | 若 `cw_m_pff_rst == 1'b1`，则值变为 `EXC_NONE`。若 `ekind` 为 `ADD / ADDI / SUB` 且 `E: alu.sig_overflow == 1'b1`，则写入 `EXC_OV`。否则，写入 E 级的值。

因为每级存储异常的流水线寄存器的复位逻辑与每级数据通路中的流水线寄存器是一致的，而每级数据通路中流水线寄存器的复位逻辑是正确的，因此可以这样借用控制信号。

TODO: `EXC_RI` 好像只是 `opcode` 未知

#### 中断处理

中断处理是通过 `bridge` 进行的。`bridge` 负责捕获硬件的中断，并把它送到 `cp0` 的端口。如果当前指令发生了异常，也要优先处理中断，因为中断的优先级更高。

注意：**中断的优先级比异常高。**

#### 进入 ISR

`cp0` 中有专门的输出端口 `have2handle` 来做这件事。如果在 ISR 外面执行指令突然碰到异常或中断，`have2handle` 由组合逻辑驱动，就会变成 `1'b1`。下一个时钟周期的时候，就会处理中断或异常。`cp0` 会与控制模块写作，保存中断发生时需要的信息。

首先，为了干净地处理中断或异常，需要复位所有的流水线寄存器，然后把新 PC 定位为 ISR 的起始地址。这就需要把原来对 NPC 模式的控制信号 `cw_npc_mode` 加上钩子，如果出现了中断或异常，就直接改成 `NPC_ISR`，让 `pc` 跳转。这就需要四个控制信号：`[demw]_pff_rst`。其中 `e_pff_rst` 已经有了，所以需要加上钩子。同时，由于 `JUMP_C0` 类指令不需要延迟槽，所以 `d_pff_rst` 在 D 级指令为 `JUMP_C0` 类指令的时候，也需要为 `1'b1`。

其次，为了彻底地取消流水线的效果，需要在下个时钟上升沿禁止所有可写入部件的写入。这也需要把原来对 `dm`、`bridge`、`cp0` 和 `md` 的控制信号屏蔽掉，同样也是加入钩子机制，如果出现了中断或异常，哪怕写入使能也要取消使能。但是，`rf` 不需要这样做，因为把 `cp0` 部署在 M 级以后，任何出现异常的指令最晚到 M 级都会被处理，而且 W 级指令只有写回寄存器，不会产生异常，在下一个时钟上升沿正好写入寄存器，完成了最终的指令功能。

对 `md`，如果 E 级或 M 级指令是 `STORE_M` 类指令，那么需要把 `restore` 信号置成 `1'b1`，因为在下一个时钟下降沿，`md` 已经开始或者早已结束解析控制信号并存储新值了。因为 E 级或 M 级指令会重新执行。如果 E 级或 M 级指令是 `CAL_M` 类指令，那么把 `stop` 信号置成 `1'b1`，因为有正在进行的运算，需要停止。

注意：**如果有 `mult / multu / div / divu` 指令执行完了然后 `md` 在执行，`md` 执行结束前有指令出现异常，那么 `md` 的值同样会更新。暂停机制保证了操作 `md` 的三类数据通路类型都是实际上顺序执行的，所以 `md` 的值会更新，不过会出现在 ISR 里，让 ISR 用。**

控制信号与其加了钩子后的控制信号的关系如下。

控制信号 | 加钩子后的控制信号 | 与原来控制信号和 `have2handle` 的关系 | 备注
--- | --- | --- | ---
`cw_m_dm_write_enable_orig` | `cw_m_dm_write_enable` | `cw_m_dm_write_enable & (~have2handle)` |
`cw_m_cp0_write_enable_orig` | `cw_cp0_write_enable` | `cw_cp0_write_enable_orig & (~have2handle)` | [1]
`cw_e_pff_rst_orig` | `cw_e_pff_rst` | `cw_e_pff_rst_orig` 或 `have2handle` |
`cw_f_npc_jump_mode_orig` | `cw_f_npc_jump_mode` | `(have2handle == 1'b1) ? NPC_ISR : cw_f_npc_jump_mode_orig` | [2]
`cw_f_pc_enable_orig` | `cw_f_pc_enable` | `cw_f_pc_enable_orig` 或 `have2handle` | [3]

注：
1. 实际上不需要加钩子，因为 `cp0` 内部就是写入的优先级比处理异常和中断的优先级低。
2. 如果 `have2handle == 1'b1`，那么 `cw_f_npc_jump_mode` 必须为 `NPC_ISR`，因为需要强制跳转到 ISR 的起始地址。
3. 为了避免暂停时 `pc` 不动的问题，暂停时 `pc` 必须强行跳到 ISR 的起始地址

然后，为了能让 `cp0` 获得准确的数据，必须把控制模块分析出来的相应的 `cp0` 控制信号接入 `cp0` 相应的输入漩口。接入关系及意义如下。

控制模块输出端口 | `cp0` 输入端口 | 生成方法 | 意义 | 备注
--- | --- | --- | --- | ---
`cw_m_cp0_write_enable` | `write_enable` | M 级指令为 `STORE_C0` 类指令 | 能够让 `STORE_C0` 类指令写入 `cp0` 内部寄存器 | [5]
`cw_m_cp0_exit_isr` | `exit_isr` | M 级指令为 `JUMP_C0` 类指令 | 能够让 `JUMP_C0` 类指令正常去掉中断状态 | [1]
`cw_m_cp0_in_bds` | `in_bds` | W 级指令为 `BRANCH / JUMP_I / JUMP_R` 类指令 | 能够让 `cp0` 判断出受害指令是否在延迟槽内 | [2]
`cw_m_cp0_exc` | `exc` | M 级存储异常的流水线寄存器和 M 级的异常情况综合后的结果 | 能够让 `cp0` 得到当前发生的异常 | [3]
`cw_m_cp0_curr_pc` | `curr_pc` | 若 `M: curr_pc != 0`，则为 `M: curr_pc`；否则一直追溯到 D 级的 `curr_pc` 为止 | 能够让 `cp0` 得到受害指令的 PC 作为 `epc` | [4]

注：

1. 一般来说 `JUMP_C0` 类指令应该马上写 `cp0` 的相应寄存器，从而去掉 `exl`，以方便之后的 `LOAD_C0` 类指令。但是，`JUMP_C0` 类指令由于不是跳转类指令却在 D 级译码，后面一定跟着一个气泡。所以，它到了 M 级的时候，`LOAD_C0` 类指令最早才到 D 级，下一个时钟上升沿后就可以转发，转发来得及，因此不需要再做 `cp0` 内部寄存器的转发，直接让 M 级指令为 `JUMP_C0` 类指令时设置 `cw_m_cp0_exit_isr <= 1'b1` 即可。
2. 受害指令是 M 级指令，所以如果 M 级指令在延迟槽中，W 级指令一定为以上三种类型。W 级指令为 `JUMP_C0` 类指令时，后面一定跟着一个气泡，再说 `JUMP_C0` 类指令没有延迟槽，所以不需要考虑。如果受害指令在延迟槽内，保存的 `epc` 是受害指令的 PC 作为无符号数再减去 4，因为要恢复到跳转指令，把跳转指令再执行一遍。
3. 异常情况按照处理异常这一节，是一定要综合的。综合以后就能让 `cp0` 得到 M 级指令最近的异常情况，因为异常原则上都是一级一级往下传递，而且新异常会覆盖老异常。
4. M 级指令出现异常，那么 M 级一定有指令，所以 `M: curr_pc != 0`，受害指令的 PC 就能被找到。但是，如果出现中断而且 M 级是气泡，`M: curr_pc == 0`，这是就应该回溯找到没有气泡的指令。回溯到 D 级就可以，因为一般暂停产生的气泡都是只在 E 级生成，只有一种情况例外，就是 `JUMP_C0` 类指令。但是它在 D 级生成气泡的时候，自己也到了 E 级，表格中的逻辑照样适合。流水线刚被全部清空，正要进入 ISR 的那个上升沿不会再出现中断。这是因为中断被屏蔽了，况且 ISR 起始地址肯定是关于字对齐的，否则就是硬件设计缺陷了，之后各级由于都是气泡，也不会再出现中断。所以，用表格中的逻辑不用担心找不到不合法的 PC。
5. 这里的信号是原来的信号，注意要像加钩子表格那样加上钩子。

#### CP0

`cp0` 主要是负责获取中断时的情况和保存中断的相关信息。`cp0` 输入了当前的中断和异常情况、`epc`、受害指令是否再延迟槽内这些相关信息，等到从 ISR 返回时恢复。同时，`cp0` 也支持读写它内部的寄存器。

`cp0` 需要通过组合电路判断这个时钟上升沿后 M 级是否出现了异常，以及是否出现了硬件中断。它的内部寄存器有全局中断使能、硬件中断使能掩码和中断层级等设置。硬件中断首先与硬件中断使能掩码相与，然后再根据全局中断使能和中断层级来判断是否进入 ISR。软件异常直接根据全局中断使能和中断层级来判断是否进入 ISR。如果中断层级为 `1'b1`，就不需要再进入 ISR 了。

`cp0` 首先是在 `have2handle == 1'b1` 的情况下进入 ISR 并设定相应的状态，其次才是处理写请求，最后是处理清除 `exl` 的请求。这样能保证中断机制符合一般的认知，而且不妨碍指令执行逻辑上的顺序性。

#### 从 ISR 返回

从 ISR 返回是用 `JUMP_C0` 类指令，现在只有一条，就是 `ERET` 指令。`ERET` 指令需要读取 `M: cp0.epc` 作为 `F: npc.next_pc`，而且有 `STORE_C0` 类指令，所以 `epc` 也要转发，这在前面的转发一节中已经提到了。

虽然 `JUMP_C0` 类指令也写 `cp0` 的内部寄存器，但是它们不需要转发，因为它并没有延迟槽，后面会带一个气泡。这样保证了它在 M 级的时候，新指令才会进来，转发来得及，更何况还有暂停机制。实际上，`ERET` 指令并不算跳转类指令，所以它没有延迟槽。在 `JUMP_C0` 类指令后面插入气泡的方法，是 D 级指令为 `JUMP_C0` 类指令时，如果不暂停，在下个时钟上升沿就复位 D 级寄存器。这样，D 级就会插入一个气泡，同时不跟暂停机制冲突，因为暂停时 D 级指令是不动的。实际上，这跟流水线寄存器的复位和暂停优先级冲突了，但是暂时没有好的办法。

从 ISR 返回时，在 D 级的跳转模式是 `NPC_EPC`，是经过转发的 `M: cp0.epc`。转发也是较新的级优先级较大，因为这样符合逻辑。转发后就不需要清空流水线了，因为正常的指令可以继续执行下去，不像进入 ISR 时需要撤销比 M 级还新的几条指令的执行结果。

注意：**D 级流水线寄存器的复位逻辑是在前面进入 ISR 时实现的，并不在最后。**

注意：**D 级流水线只有不暂停的时候才能复位，否则一暂停会把 D 级的 `JUMP_C0` 类指令清空。**

注意：**可以在 M 级时判断出 `JUMP_C0` 类指令再清空 `exl`，因为 `JUMP_C0` 类指令清空 `exl` 后到了 W 级，会正常执行完，这时正好当时的受害指令到了 M 级，如果还有中断或者异常，该指令及其之后指令仍然会被中断，重新进入 ISR。但是，会出现 `eret` 没到 M 级的时候或者刚清空流水线 ISR 的第一条指令还来不及进入 M 级的时候不持续的硬件中断不会响应的问题，这种问题应该可以忽略，把它当成 ISR 已经进入或者还没退出来解决。**

